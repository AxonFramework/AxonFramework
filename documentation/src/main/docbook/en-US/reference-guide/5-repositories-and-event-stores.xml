<?xmlle it produces more a compact  version="1.0" encoding="UTF-8"?>
<!--
  ~ Copyright (c) 2010-2014. Axon Framework
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~     http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->
<chapter xml:id="repositories-and-event-stores" version="5.0" xmlns="http://docbook.org/ns/docbook">
    <title>Repositories and Event Stores</title>
    <para>The repository is the mechanism that provides access to aggregates. The repository
        acts as a gateway to the actual storage mechanism used to persist the data. In CQRS, the
        repositories only need to be able to find aggregates based on their unique identifier. Any
        other types of queries should be performed against the query database, not the
        Repository.
    </para>
    <para>In the Axon Framework, all repositories must implement the <code>Repository</code>
        interface. This interface prescribes three methods: <code>load(identifier, version)</code>,
            <code>load(identifier)</code> and <code>add(aggregate)</code>. The <code>load</code>
        methods allows you to load aggregates from the repository. The optional <code>version</code>
        parameter is used to detect concurrent modifications (see <xref
            linkend="conflict-resolution"/>). <code>add</code> is used to register newly created
        aggregates in the repository. </para>
    <para>Depending on your underlying persistence storage and auditing needs, there are a number of
        base implementations that provide basic functionality needed by most repositories. Axon
        Framework makes a distinction between repositories that save the current state of the
        aggregate (see <xref linkend="standard-repositories"/>), and those that store the events of
        an aggregate (see <xref linkend="event-sourcing-repositories"/>). </para>
    <para>Note that the Repository interface does not prescribe a
        <code>delete(identifier)</code>
        method. Deleting aggregates is done by invoking the (protected)
        <code>markDeleted()</code>
        method in an aggregate. This method is protected and not available from outside the
        aggregate. The motivation for this, is that the aggregate is responsible for maintaining its
        own state. Deleting an aggregate is a state migration like any other, with the only
        difference that it is irreversible in many cases. You should create your own meaningful
        method on your aggregate which sets the aggregate's state to "deleted". This also allows you
        to register any events that you would like to have published.
    </para>
    <para>Repositories should use the
        <code>isDeleted()</code>
        method to find out if an aggregate
        has been marked for deletion. If such an aggregate is then loaded again, the repository
        should throw an
        <code>AggregateNotFoundException</code>
        (or when possible, an
        <code>AggregateDeletedException</code>). Axon's standard repository implementations will
        delete an aggregate from the repository, while event sourcing repositories will throw an
        Exception when an aggregate is marked deleted after initialization.
    </para>
    <sect1 xml:id="standard-repositories">
        <title>Standard repositories</title>
        <para>Standard repositories store the actual state of an Aggregate. Upon each change, the
            new state will overwrite the old. This makes it possible for the query components of the
            application to use the same information the command component also uses. This could,
            depending on the type of application you are creating, be the simplest solution. If that
            is the case, Axon provides some building blocks that help you implement such a
            repository.
        </para>
        <simplesect>
            <title><code>AbstractRepository</code>
            </title>
            <para>The most basic implementation of the repository is
                <code>AbstractRepository</code>. It takes care of the event publishing when an
                aggregate is saved. The actual persistence mechanism must still be implemented. This
                implementation doesn't provide any locking mechanism and expects the underlying data
                storage mechanism to provide it. </para>
            <para>The <code>AbstractRepository</code> also ensures that activity is synchronized
                with the current Unit of Work. That means the aggregate is saved when the Unit of
                Work is committed.</para>
        </simplesect>
        <simplesect xml:id="locking-repository">
            <title><code>LockingRepository</code>
            </title>
            <para>If the underlying data store does not provide any locking mechanism to prevent
                concurrent modifications of aggregates, consider using the abstract
                <code>LockingRepository</code>
                implementation. Besides providing event
                dispatching logic, it will also ensure that aggregates are not concurrently
                modified.
            </para>
            <para>You can configure the <code>LockingRepository</code> with a locking strategy.
                A pessimistic locking strategy is the default strategy. Pessimistic locks will
                prevent concurrent access to the aggregate.  A custom locking strategy can be provided
                by implementing the  <code>LockFactory</code> interface.</para>
            <para>Deadlocks are a common problem when threads use more than one lock to complete
                their operation. In the case of Sagas, it is not uncommon that a command is
                dispatched -causing a lock to be acquired-, while still holding a lock on the
                aggregate that cause the Saga to be invoked. The <code>PessimisticLockFactory</code>
                will automatically detect an imminent deadlock and will throw a
                    <code>DeadlockException</code> before the deadlock actually occurs. It is safe
                to retry the operation once all nested Units of Work have been rolled back (to
                ensure all locks are released). The <code>CommandGateway</code> will not invoke the
                    <code>RetryScheduler</code> if a <code>DeadlockException</code> occurred to
                prevent a retry before all held locks have been released.</para>
            <para>
                <note>
                    <title>ConcurrencyException vs ConflictingModificationException</title>
                    <para>Note that there is a clear distinction between a
                        <code>ConcurrencyException</code>
                        and a
                        <code>ConflictingModificationException</code>. The first is used to
                        indicate that a repository cannot save an aggregate, because the changes it
                        contains were not applied to the latest available version. The latter
                        indicates that the loaded aggregate contains changes that might not have
                        been seen by the end-user. See
                        <xref linkend="conflict-resolution"/>
                        for
                        more information.
                    </para>
                </note>
            </para>
        </simplesect>
        <simplesect>
            <title><code>GenericJpaRepository</code>
            </title>
            <para>This is a repository implementation that can store JPA compatible Aggregates. It
                is configured with an <code>EntityManager</code> to manage the actual persistence,
                and a class specifying the actual type of Aggregate stored in the Repository. </para>
        </simplesect>
    </sect1>
    <sect1 xml:id="event-sourcing-repositories">
        <title>Event Sourcing repositories</title>
        <para>Aggregate roots that implement the
            <code>EventSourcedAggregateRoot</code>
            interface can be stored in an event sourcing repository. Those repositories do not
            store the aggregate itself, but the series of events generated by the aggregate.
            Based on these events, the state of an aggregate can be restored at any time.
        </para>
        <simplesect>
            <title>EventSourcingRepository</title>
            <para>The <code>EventSourcingRepository</code> implementation provides the basic
                functionality needed by any event sourcing repository in the AxonFramework. It
                depends on an <code>EventStore</code> (see <xref
                    linkend="implementing-an-eventstore"/>), which abstracts the actual storage
                mechanism for the events and an <code>AggregateFactory</code>, which is responsible
                for creating uninitialized aggregate instances. </para>
            <para>The AggregateFactory specifies which aggregate needs to be created and how. Once
                an aggregate has been created, the
                <code>EventSourcingRepository</code>
                can
                initialize it using the Events it loaded from the Event Store. Axon Framework comes
                with a number of
                <code>AggregateFactory</code>
                implementations that you may use. If
                they do not suffice, it is very easy to create your own implementation.
            </para>
            <para><emphasis>GenericAggregateFactory</emphasis>
            </para>
            <para>The <code>GenericAggregateFactory</code> is a special
                    <code>AggregateFactory</code> implementation that can be used for any type of
                Event Sourced Aggregate Root. The <code>GenericAggregateFactory</code> creates an
                instance of the Aggregate type the repository manages. The Aggregate class must be
                non-abstract and declare a default no-arg constructor that does no initialization at
                all. </para>
            <para>The GenericAggregateFactory is suitable for most scenarios where aggregates do not
                need special injection of non-serializable resources. </para>
            <para><emphasis>SpringPrototypeAggregateFactory</emphasis>
            </para>
            <para>Depending on your architectural choices, it might be useful to inject dependencies
                into your aggregates using Spring. You could, for example, inject query repositories
                into your aggregate to ensure the existence (or nonexistence) of certain values. </para>
            <para>To inject dependencies into your aggregates, you need to configure a prototype
                bean of your aggregate root in the Spring context that also defines the
                    <code>SpringPrototypeAggregateFactory</code>. Instead of creating regular
                instances of using a constructor, it uses the Spring Application Context to
                instantiate your aggregates. This will also inject any dependencies in your
                aggregate. </para>
            <para><emphasis>Implementing your own AggregateFactory</emphasis>
            </para>
            <para>In some cases, the <code>GenericAggregateFactory</code> just doesn't deliver what
                you need. For example, you could have an abstract aggregate type with multiple
                implementations for different scenarios (e.g. <code>PublicUserAccount</code> and
                    <code>BackOfficeAccount</code> both extending an <code>Account</code>). Instead
                of creating different repositories for each of the aggregates, you could use a
                single repository, and configure an AggregateFactory that is aware of the different
                implementations. </para>
            <para>The AggregateFactory must specify the aggregate type identifier. This is a String
                that the Event Store needs to figure out which events belong to which type of
                aggregate. Typically, this name is deducted from the abstract super-aggregate. In
                the given example that could be: Account. </para>
            <para>The bulk of the work the Aggregate Factory does is creating uninitialized
                Aggregate instances. It must do so using a given aggregate identifier and the first
                Event from the stream. Usually, this Event is a creation event which contains hints
                about the expected type of aggregate. You can use this information to choose an
                implementation and invoke its constructor. Make sure no Events are applied by that
                constructor; the aggregate must be uninitialized. </para>
        </simplesect>
        <simplesect>
            <title>CachingEventSourcingRepository</title>
            <para>Initializing aggregates based on the events can be a time-consuming effort,
                compared to the direct aggregate loading of the simple repository implementations.
                The
                <code>CachingEventSourcingRepository</code>
                provides a cache from which
                aggregates can be loaded if available. You can configure any JCache implementation
                with this repository. Note that this implementation can only use caching in
                combination with a pessimistic locking strategy.
            </para>
            <note>
                <title>Cache API compatibility warning</title>
                <para>The Cache API has only been recently defined. As at the moment Axon was
                    developed, the most recent version of the specification was not implemented,
                    version 0.5 has been used. This API version is implemented by EhCache-JCache
                    version "1.0.5-0.5". Axon 2.1 has been tested against this version.</para>
                <para>In a future version of Axon, the 1.0 version of the Cache API will be
                    implemented, if the Cache providers have done that migration as well. Until
                    then, you might have to select your cache implementation version
                    carefully.</para>
            </note>
        </simplesect>
        <simplesect>
            <title>HybridJpaRepository</title>
            <para>The
                <code>HybridJpaRepository</code>
                is a combination of the
                <code>GenericJpaRepository</code>
                and an Event Sourcing repository. It can only
                deal with event sourced aggregates, and stores them in a relational model as well as
                in an event store. When the repository reads an aggregate back in, it uses the
                relational model exclusively.
            </para>
            <para>This repository removes the need for Event Upcasters (see <xref
                    xmlns:xlink="http://www.w3.org/1999/xlink" linkend="event-upcasting"/>), making
                data migrations potentially easier. Since the aggregates are event sourced, you keep
                the ability to use the given-when-then test fixtures (see <xref linkend="testing"
                />). On the other hand, since it doesn't use the event store for reading, it doesn't
                allow for automated conflict resolution. </para>
        </simplesect>
    </sect1>
    <sect1 xml:id="implementing-an-eventstore">
        <title>Event store implementations</title>
        <para>Event Sourcing repositories need an event store to store and load events from
            aggregates. Typically, event stores are capable of storing events from multiple
            types of aggregates, but it is not a requirement.
        </para>
        <para>Axon provides a number of implementations of event stores, all capable of storing all
            domain events (those raised from an Aggregate). These event stores use a
                <code>Serializer</code> to serialize and deserialize the event. By default, Axon
            provides some implementations of the Event Serializer that serializes events to XML: the
                <code>XStreamSerializer</code> and one that Serializes to JSON (using Jackson):
                <code>JacksonSerializer</code>.</para>
        <sect2>
            <title><code>FileSystemEventStore</code>
            </title>
            <para>The <code>FileSystemEventStore</code> stores the events in a file on the file
                system. It provides good performance and easy configuration. The downside of this
                event store is that is does not provide transaction support and doesn't cluster very
                well. The only configuration needed is the location where the event store may store
                its files and the serializer to use to actually serialize and deserialize the
                events. </para>
            <para>Note that the <code>FileSystemEventStore</code> is not aware of transactions and cannot
                automatically recover from crashes. Furthermore, it stores a single file for each
                aggregate, potentially creating too many files for the OS to handle. It is therefore
                not a suitable implementation for production environments.<tip>
                    <title>Out of disk space</title>
                    <para>When using the <code>FileSystemEventStore</code> in a test environment (or
                        other environment where many aggregate may be created), you may end up with
                        an "Out of disk space" error, even if there is plenty of
                            <emphasis>room</emphasis> on the disk. The cause is that the filesystem
                        runs out of i-nodes (or an equivalent when not on a Unix filesystem). This
                        typically means that a filesystem holds too many files.</para>
                    <para>To prevent this problem, make sure the output directory of the
                            <code>FileSystemEventStore</code> is cleaned after each test run.</para>
                </tip></para>
        </sect2>
        <sect2>
            <title><code>JpaEventStore</code>
            </title>
            <para>The <code>JpaEventStore</code> stores events in a JPA-compatible data source.
                Unlike the file system version, the <code>JPAEventStore</code> supports
                transactions. The JPA Event Store stores events in so called entries. These entries
                contain the serialized form of an event, as well as some fields where meta-data is
                stored for fast lookup of these entries. To use the <code>JpaEventStore</code>, you
                must have the JPA (<code>javax.persistence</code>) annotations on your classpath. </para>
            <para>By default, the event store needs you to configure your persistence context
                (defined in <code>META-INF/persistence.xml</code> file) to contain the classes
                    <code>DomainEventEntry</code> and <code>SnapshotEventEntry</code> (both in the
                    <code>org.axonframework.eventsourcing.eventstore.jpa</code> package). </para>
            <para>Below is an example configuration of a persistence context configuration:</para>
            <programlistingco>
                <areaspec units="linecolumn">
                    <area coords="2 40" xml:id="persistence-unit-name-co"/>
                    <area coords="3 62" xml:id="domain-event-entry-co"/>
                </areaspec>
                <programlisting language="xml"><![CDATA[<persistence xmlns="http://java.sun.com/xml/ns/persistence" version="1.0">
    <persistence-unit name="eventStore" transaction-type="RESOURCE_LOCAL">
        <class>org...eventstore.jpa.DomainEventEntry</class>
        <class>org...eventstore.jpa.SnapshotEventEntry</class>
    </persistence-unit>
</persistence>]]></programlisting>
                <calloutlist>
                    <callout arearefs="persistence-unit-name-co">
                        <para>In this sample, there is is specific persistence unit for the event
                            store. You may, however, choose to add the third line to any other
                            persistence unit configuration. </para>
                    </callout>
                    <callout arearefs="domain-event-entry-co">
                        <para>This line registers the <code>DomainEventEntry</code> (the class used
                            by the <code>JpaEventStore</code>) with the persistence context. </para>
                    </callout>
                </calloutlist>
            </programlistingco>
            <note>
                <title>Detecting duplicate key violations in the database</title>
                <para>Axon uses Locking to prevent two threads from accessing the same Aggregate.
                    However, if you have multiple JVMs on the same database, this won't help you. In
                    that case, you'd have to rely on the database to detect conflicts. Concurrent
                    access to the event store will result in a Key Constraint Violation, as the
                    table only allows a single Event for an aggregate with any sequence number.
                    Inserting a second event for an existing aggregate with an existing sequence
                    number will result in an error. </para>
                <para>The JPA EventStore can detect this error and translate it to a
                    <code>ConcurrencyException</code>. However, each database system reports this violation
                    differently. If you register your <code>DataSource</code> with the <code>JpaEventStore</code>, it will try
                    to detect the type of database and figure out which error codes represent a Key
                    Constraint Violation. Alternatively, you may provide a
                    <code>PersistenceExceptionTranslator</code> instance, which can tell if a given exception
                    represents a Key Constraint Violation. </para>
                <para>If no <code>DataSource</code> or <code>PersistenceExceptionTranslator</code> is provided, exceptions
                    from the database driver are thrown as-is. </para>
            </note>
            <simplesect>
                <title>Working with multiple Persistence Contexts</title>
                <para>By default, the JPA Event Store expects the application to have only a single,
                    container managed, persistence context. In many cases, however, an application
                    has more than one. In that case, you must provide an explicit
                        <code>EntityManagerProvider</code> implementation that returns the
                        <code>EntityManager</code> instance for the <code>EventStore</code> to use.
                    This also allows for application managed persistence contexts to be used. It is
                    the <code>EntityManagerProvider</code>'s responsibility to provide a correct
                    instance of the <code>EntityManager</code>. </para>
                <para>There are a few implementations of the <code>EntityManagerProvider</code>
                    available, each for different needs. The
                        <code>SimpleEntityManagerProvider</code> simply returns the
                        <code>EntityManager</code> instance which is given to it at construction
                    time. This makes the implementation a simple option for Container Managed
                    Contexts. Alternatively, there is the
                        <code>ContainerManagedEntityManagerProvider</code>, which returns the
                    default persistence context, and is used by default by the Jpa Event Store. </para>
                <para>If you have a persistence unit called "myPersistenceUnit" which you wish to
                    use in the <code>JpaEventStore</code>, this is what the <code>EntityManagerProvider</code>
                    implementation could look like:
                    <programlisting language="java">public class MyEntityManagerProvider implements EntityManagerProvider {

    private EntityManager entityManager;

    @Override
    public EntityManager getEntityManager() {
        return entityManager;
    }

    @PersistenceContext(unitName = "myPersistenceUnit")
    public void setEntityManager(EntityManager entityManager) {
        this.entityManager = entityManager;
    }                </programlisting>
                </para>
            </simplesect>
            <simplesect>
                <title>Customizing the Event storage</title>
                <para>By default, the JPA Event Store stores entries in
                        <code>DomainEventEntry</code> and <code>SnapshotEventEntry</code> entities.
                    While this will suffice in many cases, you might encounter a situation where the
                    meta-data provided by these entities is not enough. Or you might want to store
                    events of different aggregate types in different tables. </para>
                <para>If that is the case, you may provide your own implementation of
                        <code>EventEntryStore</code> in the JPA Event Store's constructor. You will
                    need to provide implementations of methods that load and store serialized
                    events. Check the API Documentation of the <code>EventEntryStore</code> class
                    for implementation requirements. </para>
                <para>If you only want to change the table name or want to add some extra fields to
                    the table, you can also create a class that extends from
                    DefaultEventEntryStore, and override the <code>createDomainEventEntry</code>
                    and/or <code>createSnapshotEventEntryMethod</code>. This method must return a
                        <code>DomainEventEntry</code> and <code>SnapshotEventEntry</code> instance,
                    respectively. By returning your own subclass of these, you can store different
                    events in different tables, or add extra information in separate columns.</para>
                <warning>
                    <title>Memory consumption warning</title>
                    <para>Note that persistence providers, such as Hibernate, use a first-level
                        cache on their <code>EntityManager</code> implementation. Typically, this means that all
                        entities used or returned in queries are attached to the <code>EntityManager</code>. They
                        are only cleared when the surrounding transaction is committed or an
                        explicit "clear" in performed inside the transaction. This is especially the
                        case when the Queries are executed in the context of a transaction. </para>
                    <para>To work around this issue, make sure to exclusively query for non-entity
                        objects. You can use JPA's "SELECT new SomeClass(parameters) FROM ..." style
                        queries to work around this issue. Alternatively, call
                            <code>EntityManager.flush()</code> and
                            <code>EntityManager.clear()</code> after fetching a batch of events.
                        Failure to do so might result in <code>OutOfMemoryException</code>s when
                        loading large streams of events. </para>
                </warning>
            </simplesect>
        </sect2>
        <sect2>
            <title>JDBC Event Store</title>
            <para>The JDBC event store uses a JDBC Connection to store Events in a JDBC compatible
                data storage. Typically, these are relational databases. Theoretically, anything
                that has a JDBC driver could be used to back the JDBC Event Store.</para>
            <para>Similar to the JPA Event Store, the JDBC Event Store stores Events in entries. By
                default, each Event is stored in a single Entry, which corresponds with a row in a
                table. One table is used for Events and another for the Snapshots.</para>
            <para>The <code>JdbcEventStore</code> can be configured with an
                    <code>EventEntryStore</code> and a <code>Serializer</code>. The EventEntryStore
                defines how Events are appended to the event store. The serializer is used to
                convert the payload and meta data of an event into an array of bytes, ready for
                storage. In most cases, the DefaultEventEntryStore will suffice. It can be configured
                to accommodate all sort of different scenarios.</para>
            <para>The <code>DefaultEventEntryStore</code> uses a <code>ConnectionProvider</code> to
                obtain connections. Typically, these connections can be obtained directly from a
                DataSource. However, Axon will bind these connections to a Unit of Work, so that a
                single connection is used in a Unit of Work. This ensures that a single transaction is used
                to store all events, even when multiple Units of Work are nested in the same
                thread.</para>
            <note>
                <title>JDBC Event Store and Spring</title>
                <para>Spring users are recommended to use the namespace support to define a JDBC
                    Event Store: <code>&lt;axon:jdbc-event-store .../></code> This will ensure that
                    connections are bound to a transaction using the Platform Transaction Manager,
                    if available.</para>
                <para>If you don't use namespace support, or define your own
                        <code>ConnectionProvider</code>, you can use the
                        <code>SpringDataSourceConnectionProvider</code> to attach a connection from
                    a <code>DataSource</code> to an existing transaction. It is also recommended to
                    wrap the <code>ConnectionProvider</code> in a
                        <code>UnitOfWorkAwareConnectionProviderWrapper</code>, to ensure a single
                    connection is used during the course of a single Unit of Work.</para>
            </note>
            <para>Most databases speak more or less the same language. However, there many so-called
                SQL Dialects. While the JDBC Event Store speaks a language all databases should be
                able to understand, it is possible that specific database vendors provide better
                performing alternatives to generic SQL commands. To accommodate those, the
                    <code>DefaultEventEntryStore</code> works with a <code>EventSqlSchema</code>.
                The <code>EventSqlSchema</code> is an interface that prescribes a number of
                operations the <code>EventEntryStore</code> does on the underlying database. The
                    <code>EventSqlSchema</code> is responsible for creating the correct
                    <code>PreparedStatement</code>s for those. When you need to change a query that
                is executed against the database, it will usually suffice to override a single
                method in the <code>GenericEventSqlSchema</code>. The is, for example, a
                    <code>PostgresEventSqlSchema</code> implementaion for use with a PostgreSQL
                database.</para>
            <warning>
                <title>Timestamps and time zones</title>
                <para>By default, Axon stores time stamps in the system timezone. However, many
                    regions use daylight savings time, causing them to effectively change timezone
                    throughout the year. This could cause events to be returned in a different order
                    than how they were originally stored. It is recommended to store timestamps in
                    the UTC timezone, or use the millis-since-epoch format.</para>
                <para>To force the JDBC Event Store to store dates in the UTC timezone, either
                    configure Joda to generate all dates in UTC timezone, or tell the JDBC Event
                    Store to convert all timestamps to UTC. This can be done by setting
                    &lt;axon:jdbc-event-store ... force-utc-timestamp="true" ... />, or by calling
                        <code>setForceUtc(true);</code> on the
                    <code>GenericEventSqlSchema</code>.</para>
            </warning>
        </sect2>
        <sect2>
            <title>MongoDB Event Store</title>
            <para>MongoDB is a document based NoSQL store. Its scalability characteristics make it
                suitable for use as an Event Store. Axon provides the <code>MongoEventStore</code>, which uses
                MongoDB as backing database. It is contained in the Axon Mongo module (Maven
                artifactId <code>axon-mongo</code>).</para>
            <para>Events are stored in two separate collections: one for the actual event streams
                and one for the snapshots.</para>
            <para>By default, the <code>MongoEventStore</code> stores each event in a separate document. It is,
                however, possible to change the <code>StorageStrategy</code> used. The alternative
                provided by Axon is the <code>DocumentPerCommitStorageStrategy</code>, which creates a single
                document for all Events that have been stored in a single commit (i.e. in the same
                <code>DomainEventStream</code>).</para>
            <para>Storing an entire commit in a single document has the advantage that a commit is
                stored atomically. Furthermore, it requires only a single roundtrip for any number
                of events. A disadvantage is that it becomes harder to query events manually or
                through the <code>EventStoreManagement</code> methods. When refactoring the domain
                model, for example, it is harder to "transfer" events from one aggregate to another
                if they are included in a "commit document".</para>
            <para>The MongoDB doesn't take a lot of configuration. All it needs is a reference to
                the collections to store the Events in, and you're set to go. For production
                environments, you may want to double check the indexes on your collections.</para>
        </sect2>
        <sect2>
            <title>Event Store Utilities</title>
            <para>Axon provides a number of wrappers for Event Stores that may be useful in certain
                circumstances. For example, an environment may replay events up to a certain moment
                in time, in order to reproduce the state of the application at that moment.</para>
            <para>The <code>TimestampCutoffReadonlyEventStore</code> is, as the name suggests, a
                read-only event store that only returns events older than a specific time. This
                allows you to reproduce state of an application at a specific time. This class is a
                wrapper around another event store (e.g. the one used in production).</para>
            <para>The <code>SequenceEventStore</code> is a wrapper around two other Event Stores.
                When reading, it returns the events from both event stores. Appended events are only
                appended to the second event store. This is useful in cases where two different
                implementations of Event Stores are used for performance reasons, for example. The
                first would be a larger, but slower event store, while the second is optimized for
                quick reading and writing.</para>
            <para>There is also an Event Store implementation that keeps te stored events in memory:
                the <code>VolatileEventStore</code>. While it probably outperforms any other event
                store out there, it is not really meant for long-term production use. However, it is
                very useful in short-lived tools or tests that require an event store.</para>
        </sect2>
        <sect2>
            <title>Implementing your own event store</title>
            <para>If you have specific requirements for an event store, it is quite easy to
                implement one using different underlying data sources. Reading and appending events
                is done using a <code>DomainEventStream</code>, which is quite similar to iterator
                implementations. </para>
            <para>Instead of eagerly deserializing Events, consider using the
                    <code>SerializedDomainEventMessage</code>, which will postpone deserialization
                of Meta Data and Payload until it is actually used by a handler.</para>
            <tip>
                <para>The <code>SimpleDomainEventStream</code> class will make the contents of a
                    sequence ( <code>List</code> or <code>array</code>) of <code>EventMessage</code>
                    instances accessible as event stream. </para>
            </tip>
        </sect2>
        <sect2>
            <title>Influencing the serialization process</title>
            <para>Event Stores need a way to serialize the Event to prepare it for storage. By
                default, Axon uses the <code>XStreamSerializer</code>, which uses <link
                    xmlns:ns1="http://www.w3.org/1999/xlink" ns1:href="http://xstream.codehaus.org/"
                    >XStream</link> to serialize Events into XML. XStream is reasonably fast and is
                more flexible than Java Serialization. Furthermore, the result of XStream
                serialization is human readable. Quite useful for logging and debugging purposes. </para>
            <para>The XStreamSerializer can be configured. You can define aliases it should use for
                certain packages, classes or even fields. Besides being a nice way to shorten
                potentially long names, aliases can also be used when class definitions of events
                change. For more information about aliases, visit the <link
                    xmlns:ns1="http://www.w3.org/1999/xlink" ns1:href="http://xstream.codehaus.org/"
                    >XStream website</link>.</para>
            <para>Alternatively, Axon also provides the <code>JacksonSerializer</code>, which uses
                    <link xmlns:xlink="http://www.w3.org/1999/xlink"
                    xlink:href="https://github.com/FasterXML/jackson">Jackson</link> to serialize
                Events into JSON. While it produces a more compact serialized form, it does require
                that classes stick to the conventions (or configuration) required by Jackson.</para>
            <note>
                <title>Spring XML Configuration and Serializer Customization</title>
                <para>Configuring the serializer using Java code (or other JVM languages) is easy.
                    However, configuring it in a Spring XML Application Context is not so trivial,
                    due to its limitations to invoke methods. One of the options is to create a
                        <code>FactoryBean</code> that creates an instance of an XStreamSerializer
                    and configures it in code. Check the Spring Reference  for more
                    information.</para>
            </note>
            <para>You may also implement your own Serializer, simply by creating a class that
                implements <code>Serializer</code>, and configuring the Event Store to use that
                implementation instead of the default. </para>
        </sect2>
    </sect1>
    <sect1 xml:id="event-upcasting">
        <title>Event Upcasting</title>
        <para>Due to the ever-changing nature of software applications it is likely that event
            definitions also change over time. Since the Event Store is considered a read and
            append-only data source, your application must be able to read all events, regardless of
            when they have been added. This is where upcasting comes in. </para>
        <para>Originally a concept of object-oriented programming, where "a subclass gets cast to
            its superclass automatically when needed", the concept of upcasting can also be applied
            to event sourcing. To upcast an event means to transform it from its original structure
            to its new structure. Unlike OOP upcasting, event upcasting cannot be done in full
            automation because the structure of the new event is unknown to the old event. Manually
            written Upcasters have to be provided to specify how to upcast the old structure to the
            new structure. </para>
        <para>Upcasters are classes that take one input event of revision <code>x</code> and output
            zero or more new events of revision <code>x + 1</code>. Moreover, upcasters are
            processed in a chain, meaning that the output of one upcaster is sent to the input of
            the next. This allows you to update events in an incremental manner, writing an Upcaster
            for each new event revision, making them small, isolated, and easy to understand. </para>
        <note>
            <para> Perhaps the greatest benefit of upcasting is that it allows you to do
                non-destructive refactoring, i.e. the complete event history remains intact. </para>
        </note>
        <para>In this section we'll explain how to write an upcaster, describe the two
            implementations of the Upcaster Chain that come with Axon, and explain how the
            serialized representations of events affects how upcasters are written. </para>
        <para>To allow an upcaster to see what version of serialized object they are receiving, the
            Event Store stores a revision number as well as the fully qualified name of the Event.
            This revision number is generated by a <code>RevisionResolver</code>, configured in the
            serializer. Axon provides several implementations of the <code>RevisionResolver</code>,
            such as the <code>AnnotationRevisionResolver</code>, which checks for an
                <code>@Revision</code> annotation on the Event payload, a
                <code>SerialVersionUIDRevisionResolver</code> that uses the
                <code>serialVersionUID</code> as defined by Java Serialization API and a
                <code>FixedValueRevisionResolver</code>, which always returns a predefined value.
            The latter is useful when injecting the current application version. This will allow you
            to see which version of the application generated a specific event.</para>
        <para>Maven users can use the <code>MavenArtifactRevisionResolver</code> to automatically
            use the project version. It is initialized using the groupId and artifactId of the
            project to obtain the version for. Since this only works in JAR files created by Maven,
            the version cannot always be resolved by an IDE. If a version cannot be resolved,
                <code>null</code> is returned.</para>
        <sect2>
            <title>Writing an upcaster</title>
            <para>To explain how to write an upcaster for Axon we'll walk through a small example,
                describing the details of writing an upcaster as we go along. </para>
            <para>Let's assume that there is an Event Store containing many
                    <code>AdministrativeDetailsUpdated</code> events. New requirements have let to
                the introduction of two new events: <code>AddressUpdatedEvent</code> and
                    <code>InsurancePolicyUpdatedEvent</code>. Previously though, all information in
                these two events was contained in the old
                    <code>AdministrativeDetailsUpdatedEvent</code>, which is now deprecated. To
                nicely handle this situation we'll write an upcaster to transform the
                    <code>AdministrativeDetailsUpdatedEvent</code> into an
                    <code>AddressUpdatedEvent</code> and an
                <code>InsurancePolicyUpdatedEvent</code>. </para>
            <para>Here is the code for an upcaster: <programlistingco>
                    <areaspec>
                        <area xml:id="content-type" coords="3 83"/>
                        <area xml:id="can-upcast" coords="6 63"/>
                        <area xml:id="expected-representation" coords="12 59"/>
                        <area xml:id="upcast-body" coords="18 90"/>
                        <area xml:id="upcast-type" coords="40 73"/>
                    </areaspec>
                    <programlisting language="java">import org.dom4j.Document;
                
public class AdministrativeDetailsUpdatedUpcaster implements Upcaster&lt;Document> {

    @Override
    public boolean canUpcast(SerializedType serializedType) {
        return serializedType.getName().equals("org.example.AdministrativeDetailsUpdated") &amp;&amp;
               "0".equals(serializedType.getRevision());
    }

    @Override
    public Class&lt;Document> expectedRepresentationType() {
        return Document.class;
    }

    @Override
    public List&lt;SerializedObject&lt;Document>> upcast(SerializedObject&lt;Document> intermediateRepresentation,
                                                   List&lt;SerializedType> expectedTypes, UpcastingContext context) {
        Document administrativeDetailsUpdatedEvent = intermediateRepresentation.getData();

        Document addressUpdatedEvent =
                new DOMDocument(new DOMElement("org.example.AddressUpdatedEvent"));
        addressUpdatedEvent.getRootElement()
                .add(administrativeDetailsUpdatedEvent.getRootElement().element("address").createCopy());

        Document insurancePolicyUpdatedEvent =
                new DOMDocument(new DOMElement("org.example.InsurancePolicyUpdatedEvent").createCopy());
        insurancePolicyUpdatedEvent.getRootElement()
                .add(administrativeDetailsUpdatedEvent.getRootElement().element("policy").createCopy());

        List&lt;SerializedObject&lt;?>> upcastedEvents = new ArrayList&lt;SerializedObject&lt;?>>();
        upcastedEvents.add(new SimpleSerializedObject&lt;Document>(
                addressUpdatedEvent, Document.class, expectedTypes.get(0)));
        upcastedEvents.add(new SimpleSerializedObject&lt;Document>(
                insurancePolicyUpdatedEvent, Document.class, expectedTypes.get(1)));
        return upcastedEvents;
    }

    @Override
    public List&lt;SerializedType> upcast(SerializedType serializedType) {
        SerializedType addressUpdatedEventType = 
                new SimpleSerializedType("org.example.AddressUpdatedEvent", "1");
        SerializedType insurancePolicyUpdatedEventType = 
                new SimpleSerializedType("org.example.InsurancePolicyUpdatedEvent", "1");
        return Arrays.asList(addressUpdatedEventType, insurancePolicyUpdatedEventType);
    }
}</programlisting>
                    <calloutlist>
                        <callout arearefs="content-type">
                            <para>First we have to create a class that implements the
                                    <code>Upcaster</code> interface. Then we have to decide on which
                                content type to work. For this example dom4j documents are used as
                                they'll fit nicely with an event store that uses XML to store
                                events.</para>
                        </callout>
                        <callout arearefs="can-upcast">
                            <para>In Axon, Events have a revision, if the definition of an event
                                changes, you should update its revision as well. The
                                    <code>canUpcast</code> method can then be used to check if an
                                event needs to be upcasted. In the example we return true on the
                                    <code>canUpcast</code> method only when the incoming event has
                                the type <code>org.example.AdministrativeDetailsUpdatedEvent</code>
                                and has revision number 0. Axon will take care of calling the
                                Upcaster's <code>upcast</code> method if the <code>canUpcast</code>
                                method on that Upcaster returns true.</para>
                        </callout>
                        <callout arearefs="expected-representation">
                            <para>Due to Java's type erasure we have to implement the
                                    <code>expectedRepresentationType</code> method to provide Axon
                                with runtime type information on the content type by returning the
                                    <code>Class</code> object of the content type. The content type
                                is used at runtime to determine how the incoming event needs to be
                                converted to provide the upcaster with the event with the correct
                                type.</para>
                        </callout>
                        <callout arearefs="upcast-body">
                            <para> By copying the address and policy element from the
                                <code>AdministrativeDetailsUpdatedEvent</code> each into its own document, the
                                event is upcasted. Deserializing the result would get us an instance
                                of the InsurancePolicyUpdatedEvent and an instance of the
                                <code>AddressUpdatedEvent</code>.</para>
                        </callout>
                        <callout arearefs="upcast-type">
                            <para> Upcasting can be expensive, possibly involving type conversion,
                                deserialization and logic. Axon is smart enough to prevent this from
                                happening when it is not necessary through the concept of
                                <code>SerializedType</code>s. <code>SerializedType</code>s provide Axon with the information
                                to delay event upcasting until the application requires it.</para>
                        </callout>
                    </calloutlist>
                </programlistingco></para>
            <note>
                <title>Conditional upcasting</title>
                <para>In some occasions, it is necessary to upcast an event to one of multiple
                    potential types, based on the contents of the event itself. This is the case
                    where one historical event has been split into several new events, each one for
                    a specific case. The Upcaster interface doesn't provide the event itself in the
                        <code>upcast(SerializedType)</code> method.</para>
                <para>Alternatively, you may implement the <code>ExtendedUpcaster</code> interface.
                    Unlike the <code>Upcaster</code> interface, this interface declares an
                        <code>upcast(SerializedType, SerializedObject)</code> method. This method
                    serves as a replacement for the <code>upcast(SerializedType)</code> method, for
                    UpcasterChain implementations that support ExtendedUpcaster. The UpcasterChain
                    implementations provided by Axon will always support this. Upcasters
                    implementing <code>ExtendedUpcaster</code> may throw an
                        <code>UnsupportedOperationException</code> in the
                        <code>upcast(SerializedType)</code> method.</para>
            </note>
        </sect2>
        <sect2>
            <title>The Upcaster Chain</title>
            <para>The Upcaster Chain is responsible for upcasting events by chaining the output of
                one upcaster to the next. It comes in the following two flavours:</para>
            <itemizedlist>
                <listitem>
                    <para>The <code>SimpleUpcasterChain</code> immediately upcasts all events given
                        to it and returns them.</para>
                </listitem>
                <listitem>
                    <para>The <code>LazyUpcasterChain</code> prepares the events to be upcasted but
                        only upcasts the events that are actually used. Depending on whether or not your
                        application needs all events, this can give you a significant performance
                        benefit. In the worst case it's as slow as the <code>SimpleUpcasterChain</code>. The
                        <code>LazyUpcasterChain</code> does not guarantee that all the events in an Event Stream
                        are in fact upcasted. When your upcasters rely on information from previous
                        events, this may be a problem.</para>
                </listitem>
            </itemizedlist>
            <para>The <code>LazyUpcasterChain</code> is a safe choice if your upcasters are stateless or do not
                depend on other upcasters. Always consider using the <code>LazyUpcasterChain</code> since it can
                provide a great performance benefit over the <code>SimpleUpcasterChain</code>. If you want
                guaranteed upcasting in a strict order, use the <code>SimpleUpcasterChain</code>.</para>
        </sect2>
        <sect2>
            <title>Content type conversion</title>
            <para>An upcaster works on a given content type (e.g. dom4j Document). To provide extra
                flexibility between upcasters, content types between chained upcasters may vary.
                Axon will try to convert between the content types automatically by using
                <code>ContentTypeConverter</code>s. It will search for the shortest path from type <code>x</code>
                to type <code>y</code>, perform the conversion and pass the converted value into the
                requested upcaster. For performance reasons, conversion will only be performed if
                the <code>canUpcast</code> method on the receiving upcaster yields true. </para>
            <para>The <code>ContentTypeConverter</code>s may depend on the type of serializer used. Attempting to
                convert a <code>byte[]</code> to a dom4j <code>Document</code> will not make any sense unless a <code>Serializer</code> was
                used that writes an event as XML. To make sure the <code>UpcasterChain</code> has access to the
                serializer-specific <code>ContentTypeConverter</code>s, you can pass a reference to the
                serializer to the constructor of the <code>UpcasterChain</code>.</para>
            <tip>
                <para>To achieve the best performance, ensure that all upcasters in the same chain
                    (where one's output is another's input) work on the same content type. </para>
            </tip>
            <para>If the content type conversion that you need is not provided by Axon you can
                always write one yourself using the <code>ContentTypeConverter</code> interface.
            </para>
            <para>The <code>XStreamSerializer</code> supports Dom4J as well as XOM as XML document
                representations. The <code>JacksonSerializer</code> supports Jackson's
                    <code>JsonNode</code>.</para>
        </sect2>
    </sect1>
    <sect1 xml:id="using-snapshot-events">
        <title>Snapshotting</title>
        <para>When aggregates live for a long time, and their state constantly changes, they will
            generate a large amount of events. Having to load all these events in to rebuild an
            aggregate's state may have a big performance impact. The snapshot event is a domain
            event with a special purpose: it summarises an arbitrary amount of events into a single
            one. By regularly creating and storing a snapshot event, the event store does not have
            to return long lists of events. Just the last snapshot events and all events that
            occurred after the snapshot was made.
        </para>
        <para>For example, items in stock tend to change quite often. Each time an item is sold, an
            event reduces the stock by one. Every time a shipment of new items comes in, the stock
            is incremented by some larger number. If you sell a hundred items each day, you will
            produce at least 100 events per day. After a few days, your system will spend too much
            time reading in all these events just to find out whether it should raise an
            "ItemOutOfStockEvent". A single snapshot event could replace a lot of these events, just
            by storing the current number of items in stock.
        </para>
        <sect2>
            <title>Creating a snapshot</title>
            <para>Snapshot creation can be triggered by a number of factors, for example the number
                of events created since the last snapshot, the time to initialize an aggregate
                exceeds a certain threshold, time-based, etc. Currently, Axon provides a mechanism
                that allows you to trigger snapshots based on an event count threshold.
            </para>
            <para>The
                <code>EventCountSnapshotterTrigger</code>
                provides the mechanism to trigger
                snapshot creation when the number of events needed to load an aggregate exceeds a
                certain threshold. If the number of events needed to load an aggregate exceeds a
                certain configurable threshold, the trigger tells a
                <code>Snapshotter</code>
                to
                create a snapshot for the aggregate.
            </para>
            <para>The snapshot trigger is configured on an Event Sourcing Repository and has a
                number of properties that allow you to tweak triggering:
                <itemizedlist>
                    <listitem>
                        <para><code>Snapshotter</code> sets the actual snapshotter instance,
                            responsible for creating and storing the actual snapshot event; </para>
                    </listitem>
                    <listitem>
                        <para><code>Trigger</code> sets the threshold at which to trigger snapshot
                            creation; </para>
                    </listitem>
                    <listitem>
                        <para><code>ClearCountersAfterAppend</code> indicates whether you want to
                            clear counters when an aggregate is stored. The optimal setting of this
                            parameter depends mainly on your caching strategy. If you do not use
                            caching, there is no problem in removing event counts from memory. When
                            an aggregate is loaded, the events are loaded in, and counted again. If
                            you use a cache, however, you may lose track of counters. Defaults to
                                <code>true</code> unless the <code>AggregateCache</code> or
                                <code>AggregateCaches</code> is set, in which case it defaults to
                                <code>false</code>. </para>
                    </listitem>
                    <listitem>
                        <para><code>AggregateCache</code> and <code>AggregateCaches</code> allows
                            you to register the cache or caches that you use to store aggregates in.
                            The snapshotter trigger will register itself as a listener on the cache.
                            If any aggregates are evicted, the snapshotter trigger will remove the
                            counters. This optimizes memory usage in the case your application has
                            many aggregates. Do note that the keys of the cache are expected to be
                            the Aggregate Identifier. </para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>A Snapshotter is responsible for the actual creation of a snapshot. Typically,
                snapshotting is a process that should disturb the operational processes as little as
                possible. Therefore, it is recommended to run the snapshotter in a different thread.
                The
                <code>Snapshotter</code>
                interface declares a single method:
                <code>scheduleSnapshot()</code>, which takes the aggregate's type and identifier
                as parameters.
            </para>
            <para>Axon provides the <code>AggregateSnapshotter</code>, which creates and stores
                    <code>AggregateSnapshot</code> instances. This is a special type of snapshot,
                since it contains the actual aggregate instance within it. The repositories provided
                by Axon are aware of this type of snapshot, and will extract the aggregate from it,
                instead of instantiating a new one. All events loaded after the snapshot events are
                streamed to the extracted aggregate instance. </para>
            <note>
                <para>Do make sure that the <code>Serializer</code> instance you use (which defaults
                    to the <code>XStreamSerializer</code>) is capable of serializing your aggregate.
                    The <code>XStreamSerializer</code> requires you to use either a Hotspot JVM, or
                    your aggregate must either have an accessible default constructor or implement
                    the <code>Serializable</code> interface. </para>
            </note>
            <para>The <code>AbstractSnapshotter</code> provides a basic set of properties that allow you to tweak
                the way snapshots are created:
                <itemizedlist>
                    <listitem>
                        <para><code>EventStore</code> sets the event store that is used to load past
                            events and store the snapshots. This event store must implement the
                                <code>SnapshotEventStore</code> interface. </para>
                    </listitem>
                    <listitem>
                        <para><code>Executor</code> sets the executor, such as a
                                <code>ThreadPoolExecutor</code> that will provide the thread to
                            process actual snapshot creation. By default, snapshots are created in
                            the thread that calls the <code>scheduleSnapshot()</code> method, which
                            is generally not recommended for production. </para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>The <code>AggregateSnapshotter</code> provides on more property: <itemizedlist>
                    <listitem>
                        <para><code>AggregateFactories</code> is the property that allows you to set
                            the factories that will create instances of your aggregates. Configuring
                            multiple aggregate factories allows you to use a single Snapshotter to
                            create snapshots for a variety of aggregate types. The
                                <code>EventSourcingRepository</code> implementations provide access
                            to the <code>AggregateFactory</code> they use. This can be used to
                            configure the same aggregate factories in the Snapshotter as the ones
                            used in the repositories.</para>
                    </listitem>
                </itemizedlist></para>
            <note>
                <para>If you use an executor that executes snapshot creation in another thread, make
                    sure you configure the correct transaction management for your underlying event
                    store, if necessary. Spring users can use the
                        <code>SpringAggregateSnapshotter</code>, which allows you to configure a
                        <code>PlatformTransactionManager</code>. The
                        <code>SpringAggregateSnapshotter</code> will autowire all aggregate
                    factories (either directly, or via the <code>Repository</code>), if a list is not explicitly
                    configured. </para>
            </note>
        </sect2>
        <sect2>
            <title>Storing Snapshot Events</title>
            <para>All Axon-provided Event Store implementations are capable of storing snapshot
                events. They provide a special method that allows a <code>DomainEventMessage</code>
                to be stored as a snapshot event. You have to initialize the snapshot event
                completely, including the aggregate identifier and the sequence number. There is a
                special constructor on the <code>GenericDomainEventMessage</code> for this purpose.
                The sequence number must be equal to the sequence number of the last event that was
                included in the state that the snapshot represents. In most cases, you can use the
                    <code>getVersion()</code> on the <code>AggregateRoot</code> (which each event
                sourced aggregate implements) to obtain the sequence number to use in the snapshot
                event. </para>
            <para>When a snapshot is stored in the Event Store, it will automatically use that
                snapshot to summarize all prior events and return it in their place. All event store
                implementations allow for concurrent creation of snapshots. This means they allow
                snapshots to be stored while another process is adding Events for the same
                aggregate. This allows the snapshotting process to run as a separate process
                altogether.</para>
            <note>
                <para>Normally, you can archive all events once they are part of a snapshot event.
                    Snapshotted events will never be read in again by the event store in regular
                    operational scenario's. However, if you want to be able to reconstruct aggregate
                    state prior to the moment the snapshot was created, you must keep the events up
                    to that date.
                </para>
            </note>
            <para>Axon provides a special type of snapshot event: the
                <code>AggregateSnapshot</code>, which stores an entire aggregate as a snapshot. The
                motivation is simple: your aggregate should only contain the state relevant to take
                business decisions. This is exactly the information you want captured in a snapshot.
                All Event Sourcing Repositories provided by Axon recognize the
                <code>AggregateSnapshot</code>, and will extract the aggregate from it. Beware
                that using this snapshot event requires that the event serialization mechanism needs
                to be able to serialize the aggregate.
            </para>
        </sect2>
        <sect2>
            <title>Initializing an Aggregate based on a Snapshot Event</title>
            <para>A snapshot event is an event like any other. That means a snapshot event is
                handled just like any other domain event. When using annotations to demarcate event
                handlers (<code>@EventHandler</code>), you can annotate a method that initializes
                full aggregate state based on a snapshot event. The code sample below shows how
                snapshot events are treated like any other domain event within the aggregate. </para>
            <para>
                <programlisting language="java">public class MyAggregate extends AbstractAnnotatedAggregateRoot {

    // ... code omitted for brevity

    @EventHandler
    protected void handleSomeStateChangeEvent(MyDomainEvent event) {
        // ...
    }

    @EventHandler
    protected void applySnapshot(MySnapshotEvent event) {
        // the snapshot event should contain all relevant state
        this.someState = event.someState;
        this.otherState = event.otherState;
    }
}                </programlisting>
            </para>
            <para>There is one type of snapshot event that is treated differently: the
                    <code>AggregateSnapshot</code>. This type of snapshot event contains the actual
                aggregate. The aggregate factory recognizes this type of event and extracts the
                aggregate from the snapshot. Then, all other events are re-applied to the extracted
                snapshot. That means aggregates never need to be able to deal with
                    <code>AggregateSnapshot</code> instances themselves. </para>
        </sect2>
        <sect2>
            <title>Pruning Snapshot Events</title>
            <para>Once a snapshot event is written, it prevents older events and snapshot events
                from being read. Domain Events are still used in case a snapshot event becomes
                obsolete due to changes in the structure of an aggregate. The older snapshot events
                are hardly ever needed.
                <code>SnapshotEventStore</code>
                implementation may choose to
                keep only a limited amount of snapshots (e.g. only one) for each aggregate.
            </para>
            <para>The
                <code>JpaEventStore</code>
                allows you to configure the amount of snapshots to
                keep per aggregate. It defaults to 1, meaning that only the latest snapshot event is
                kept for each aggregate. Use
                <code>setMaxSnapshotsArchived(int)</code>
                to change
                this setting. Use a negative integer to prevent pruning altogether.
            </para>
        </sect2>
    </sect1>
    <sect1 xml:id="conflict-resolution">
        <title>Advanced conflict detection and resolution</title>
        <para>One of the major advantages of being explicit about the meaning of changes, is that
            you can detect conflicting changes with more precision. Typically, these conflicting
            changes occur when two users are acting on the same data (nearly) simultaneously.
            Imagine two users, both looking at a specific version of the data. They both decide to
            make a change to that data. They will both send a command like "on version X of this
            aggregate, do that", where X is the expected version of the aggregate. One of them will
            have the changes actually applied to the expected version. The other user won't.
        </para>
        <para>Instead of simply rejecting all incoming commands when aggregates have been modified
            by another process, you could check whether the user's intent conflicts with any unseen
            changes. One way to do this, is to apply the command on the latest version of the
            aggregate, and check the generated events against the events that occurred since the
            version the user expected. For example, two users look at a Customer, which has version
            4. One user notices a typo in the customer's address, and decides to fix it. Another
            user wants to register the fact that the customer moved to another address. If the fist
            user applied his command first, the second one will make the change to version 5,
            instead of the version 4 that he expected. This second command will generate a
            CustomerMovedEvent. This event is compared to all unseen events: AddressCorrectedEvent,
            in this case. A <code>ConflictResolver</code> will compare these events, and decide that these
            conflicts may be merged. If the other user had committed first, the <code>ConflictResolver</code>
            would have decided that a AddressCorrectedEvent on top of an unseen CustomerMovedEvent
            is considered a conflicting change.
        </para>
        <para>Axon provides the necessary infrastructure to implement advanced conflict detection.
            By default, all repositories will throw a
            <code>ConflictingModificationException</code>
            when the version of a loaded aggregate is not equal to the expected version. Event
            Sourcing Repositories offer support for more advanced conflict detection, as described in
            the paragraph above.
        </para>
        <para>To enable advanced conflict detection, configure a <code>ConflictResolver</code> on
            the <code>EventSourcingRepository</code>. This <code>ConflictResolver</code> is
            responsible for detecting conflicting modifications, based on the events representing
            these changes. Detecting these conflicts is a matter of comparing the two lists of
            <code>DomainEvent</code>s provided in the <code>resolveConflicts</code> method declared on the
                <code>ConflictResolver</code>. If such a conflict is found, a
                <code>ConflictingModificationException</code> (or better, a more explicit and
            explanatory subclass of it) must be thrown. If the <code>ConflictResolver</code> returns
            normally, the events are persisted, effectively meaning that the concurrent changes have
            been merged. </para>
    </sect1>
</chapter>
