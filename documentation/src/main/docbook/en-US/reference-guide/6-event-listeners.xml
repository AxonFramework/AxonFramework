<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Copyright (c) 2010-2012. Axon Framework
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~     http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->
<chapter xml:id="event-processing" version="5.0" xmlns="http://docbook.org/ns/docbook">
    <title>Event Processing</title>
    <para>The Events generated by the application need to be dispatched to the components that
        update the query databases, search engines or any other resources that need them: the Event
        Listeners. This is the responsibility of the Event Bus.</para>
    <sect1 xml:id="event-bus">
        <title>Event Bus</title>
        <para>The <code>EventBus</code> is the mechanism that dispatches events to the subscribed
            event listeners. Axon Framework provides two implementation of the event bus:
                <code>SimpleEventBus</code> and <code>ClusteringEventBus</code>. Both
            implementations manage subscribed <code>EventListeners</code> and forward all incoming
            events to all subscribed listeners. This means that Event Listeners must be explicitly
            registered with the Event Bus in order for them to receive events. The registration
            process is thread safe. Listeners may register and unregister for events at any
            time.</para>
        <sect2>
            <title>Simple Event Bus</title>
            <para>The <code>SimpleEventBus</code> is, as the name suggests, a very basic
                implementation of the <code>EventBus</code> interface. It just dispatches each
                incoming <code>Event</code> to each of the subscribed <code>EventListeners</code>
                sequentially. If an EventListener throws an <code>Exception</code>, dispatching
                stops and the exception is propagated to the component publising the
                    <code>Event</code>.</para>
            <para>The <code>SimpleEventBus</code> is suitable for most cases where dispatching is
                done synchronously and locally, (i.e. in a single JVM). Once you application
                requires <code>Events</code> to be published across multiple JVMs, you could
                consider using the <code>ClusteringEventBus</code> instead.</para>
        </sect2>
        <sect2>
            <title>Clustering Event Bus</title>
            <para>The <code>ClusteringEventsBus</code> allows application developers to bundle
                    <code>EventListener</code>s into <code>Cluster</code>s based on their properties
                and non-functional requirements. The ClusteringEventBus is also more capable to deal
                with Events being dispatched among different machines.</para>
            <figure>
                <title>Structure of the Clustering Event Bus</title>
                <mediaobject>
                    <imageobject role="fo">
                        <imagedata align="center" format="svg"
                            fileref="clustering-eventbus.svg" width="8cm"/>
                    </imageobject>
                    <imageobject role="html">
                        <imagedata format="png" fileref="clustering-eventbus.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>The ClusteringEventsBus contains two mechanisms: the <code>ClusterSelector</code>,
                which selects a <code>Cluster</code> instance for each of the registered
                    <code>EventListener</code>s, and the <code>EventBusTerminal</code>, which is
                responsible for dispatching Events to each of the relevant clusters.</para>
            <note>
                <title>Background: Axon Terminal</title>
                <para>In the nervous system, an Axon (one of the components of a Neuron) transports
                    electrical signals. These Neurons are interconnected in very complex
                    arrangements. The Axon Terminal is responsible for transmitting these signals
                    from one Neuron to another.</para>
                <para>More information: <link xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="www.wikipedia.org/wiki/Axon_terminal"
                        >www.wikipedia.org/wiki/Axon_terminal</link>.</para>
            </note>
            <simplesect>
                <title><code>ClusterSelector</code></title>
                <para>The primary responsibility of the <code>ClusterSelector</code> is to, as the
                    name suggests, select a cluster for each Event Listener that subscribes to the
                    Event Bus. By default, all Event Listeners are placed in a single Cluster
                    instance, which dispatches events to its members sequentially and in the calling
                    thread (similar to how the <code>SimpleEventBus</code> works). By providing a
                    custom implementation, you can arrange the Event Listeners into different
                    Cluster instances to suit the requirements of your architecture.</para>
                <para>A number of <code>ClusterSelector</code> implementations are available. The
                        <code>ClassNamePrefixClusterSelector</code>, for example, uses a mapping of
                    package prefixes to decide which cluster is (most) suitable for an Event
                    Listener. Similarly, the <code>ClassNamePatternClusterSelector</code> uses
                    pattern matching to decide whether a given cluster is suitable. You can use the
                        <code>CompositeClusterSelector</code> to combine several cluster selectors
                    into a single one.</para>
                <para>The <code>Cluster</code> interface describes the behavior of a Cluster. By
                    adding information in the Meta Data of a Cluster, the selector can provide hints
                    to the Terminal about the expected behavior.</para>
                <note>
                    <title>Clusters and Cluster Selectors in Spring</title>
                    <para>Spring users can define clusters using the &lt;axon:cluster> element. This
                        element allows you to define the selection criteria for Event Handlers in
                        that cluster. These criteria are transformed into cluster selectors and used
                        to assign each Listener to one of the clusters. By default, this creates a
                        cluster that handles events in the publishing thread. To use a cluster with
                        other semantics, you can define a bean inside the &lt;axon:cluster> element
                        that specifies the Cluster implementation to use.</para>
                    <para>The Clusters are automatically detected and connected to the Event Bus in
                        the application context.</para>
                </note>
            </simplesect>
            <simplesect>
                <title><code>EventBusTerminal</code></title>
                <para>The <code>EventBusTerminal</code> forms the bridge between the Clusters inside
                    the Event Bus. While some terminals will dispatch within the same JVM, others
                    are aware of messaging technologies, such as AMQP to dispatch Event Messages to
                    clusters on remote machines. The default implementation dispatches published
                    events to each of the (local) clusters using the publishing thread. This means
                    that with the default terminal, and the default <code>ClusterSelector</code>,
                    the behavior of the <code>ClusteringEventBus</code> is exactly the same as that
                    of the <code>SimpleEventBus</code>.</para>
                <para>In a typical AMQP based configuration, the <code>EventBusTerminal</code> would
                    send published events to an Exchange. For each cluster, a Queue would be
                    connected to that exchange. The <code>EventBusTerminal</code> will create a
                    consumer for each cluster, which reads from its related Queue and forwards each
                    message to that cluster. Event Listeners in a distributed environment where at
                    most one instance should receive an Events should be placed in a separate
                    cluster, which competes with the other instances on a single Queue. See <xref
                        xmlns:xlink="http://www.w3.org/1999/xlink" linkend="distributed-event-bus"/>
                    for more information.</para>
            </simplesect>
        </sect2>
    </sect1>
    <sect1 xml:id="event-listeners">
        <title>Event Listeners</title>
        <para>Event listeners are the component that act on incoming events. Events may be of any
            type. In the Axon Framework, all event listeners must implement the
                <code>EventListener</code> interface. </para>
        <sect2>
            <title>Basic implementation</title>
            <para>Event listeners need to be registered with an event bus (see <xref
                    linkend="event-bus"/>) to be notified of events. The EventListener interface
                prescribes a single method to be implemented. This method is invoked for each Event
                Message passed on the Event Bus that it is subscribed
                to:<programlisting language="java">public class MyEventListener implements EventListener {

    public void handle(EventMessage message) {
        if (SomeEvent.class.isAssignableFrom(message.getPayloadType) {
            // handle SomeEvent
        } else if (OtherEvent.class.isAssignableFrom(message.getPayloadType) {
            // handle SomeOtherEvent
        }
    }
}</programlisting></para>
        </sect2>
        <sect2 xml:id="annotated-event-handlers">
            <title>Annotated Event Handler</title>
            <para>Implementing the EventListener interface can produce a large if-statement and
                verbose plumbing code. Using annotations to demarcate Event Handler methods is a
                cleaner alternative. </para>
            <simplesect>
                <title>
                    <code>AnnotationEventListenerAdapter</code></title>
                <para>The <code>AnnotationEventListenerAdapter</code> can wrap any object into an
                    event listener. The adapter will invoke the most appropriate event handler
                    method available. These event handler methods must be annotated with the
                        <code>@EventHandler</code> annotation.</para>
                <para>The <code>AnnotationEventListenerAdapter</code>, as well as the
                        <code>AbstractAnnotatedAggregateRoot</code>, use
                        <code>ParameterResolver</code>s to resolve the value that should be passed
                    in the parameters of methods annotated with <code>@EventHandler</code>. By
                    default, Axon provides a number of parameter resolvers that allow you to use the
                    following parameter types: <itemizedlist>
                        <listitem>
                            <para>The first parameter is always the payload of the Event
                                message</para>
                        </listitem>
                        <listitem>
                            <para>Parameters annotated with <code>@MetaData</code> will resolve to
                                the Meta Data value with the key as indicated on the annotation. If
                                    <code>required</code> is <code>false</code> (default),
                                    <code>null</code> is passed when the meta data value is not
                                present. If <code>required</code> is <code>true</code>, the resolver
                                will not match and prevent the method from being invoked when the
                                meta data value is not present.</para>
                        </listitem>
                        <listitem>
                            <para>Parameters of type <code>MetaData</code> will have the entire
                                    <code>MetaData</code> of an <code>EventMessage</code>
                                injected.</para>
                        </listitem>
                        <listitem>
                            <para>Parameters annotated with <code>@Timestamp</code> and of type
                                    <code>org.joda.time.DateTime</code> will resolve to the
                                timestamp of the <code>EventMessage</code>. This is the time at
                                which the Event was generated.</para>
                        </listitem>
                        <listitem>
                            <para>Parameters annotated with <code>@SequenceNumber</code> and of type
                                <code>java.lang.Long</code> or <code>long</code> will resolve to the
                                sequenceNumber of a <code>DomainEventMessage</code>. This provides the order in
                                which the Event was generated.</para>
                        </listitem>
                        <listitem>
                            <para>Parameters assignable to Message will have the entire
                                    <code>EventMessage</code> injected (if the message is assignable
                                to that parameter). If the first parameter is of type message, it
                                effectively matches an Event of any type, even if generic parameters
                                would suggest otherwise. Due to type erasure, Axon cannot detect
                                what parameter is expected. In such case, it is best to declare a
                                parameter of the payload type, followed by a parameter of type
                                Message.</para>
                        </listitem>
                        <listitem>
                            <para>When using Spring and <code>&lt;axon:annotation-config/></code> is
                                declared, any other parameters will resolve to autowired beans, if
                                exactly one autowirable candidate is available in the application
                                context. This allows you to inject resources directly into
                                    <code>@EventHandler</code> annotated methods.</para>
                        </listitem>
                    </itemizedlist></para>
                <para>You can configure additional <code>ParameterResolver</code>s by extending the
                        <code>ParameterResolverFactory</code> class and creating a file named
                        <code>/META-INF/service/org.axonframework.common.annotation.ParameterResolverFactory</code>
                    containing the fully qualified name of the implementing class. Alternatively,
                    you can register your implementation at runtime using
                        <code>ParameterResolverFactory.registerFactory()</code>. Make sure to do so
                    before any adapters are created, otherwise handlers may have been initialized
                    without those parameter resolvers.</para>
                <para>In all circumstances, exactly one event handler method is invoked per listener
                    instance. Axon will search the most specific method to invoke, in the following
                    order: <orderedlist>
                        <listitem>
                            <para>On the actual instance level of the class hierarchy (as returned
                                by <code>this.getClass()</code>), all annotated methods are
                                evaluated </para>
                        </listitem>
                        <listitem>
                            <para>If one or more methods are found of which all parameters can be
                                resolved to a value, the method with the most specific type is
                                chosen and invoked </para>
                        </listitem>
                        <listitem>
                            <para>If no methods are found on this level of the class hierarchy, the
                                super type is evaluated the same way</para>
                        </listitem>
                        <listitem>
                            <para>When the top level of the hierarchy is reached, and no suitable
                                event handler is found, the event is ignored.</para>
                        </listitem>
                    </orderedlist><programlisting language="java">// assume EventB extends EventA 
// and    EventC extends EventB

public class TopListener {

    @EventHandler
    public void handle(EventA event) {
    }

    @EventHandler
    public void handle(EventC event) {
    }
}

public class SubListener extends TopListener {

    @EventHandler
    public void handle(EventB event) {
    }

}</programlisting>In
                    the example above, the <code>SubListener</code> will receive all instances of
                        <code>EventB</code> as well as <code>EventC</code> (as it extends
                        <code>EventB</code>). In other words, the <code>TopListener</code> will not
                    receive any invocations for <code>EventC</code> at all. Since
                        <code>EventA</code> is not assignable to <code>EventB</code> (it's its
                    superclass), those will be processed by <code>TopListener</code>.</para>
                <para>The constructor of the <code>AnnotationEventListenerAdapter</code> takes two
                    parameters: the annotated bean, and the <code>EventBus</code>, to which the
                    listener should subscribe. You can subscribe and unsubscribe the event listener
                    using the <code>subscribe()</code> and <code>unsubscribe()</code> methods on the
                    adapter. Alternatively, you can use
                        <code>AnnotationEventListenerAdapter.subscribe(listener, eventBus)</code> to
                    create and subscribe the listener in one invocation.</para>
                <tip>
                    <para>If you use Spring, you can automatically wrap all annotated event
                        listeners with an adapter automatically by adding
                            <code>&lt;axon:annotation-config/></code> to your application context.
                        Axon will automatically find and wrap annotated event listeners in the
                        Application Context with an <code>AnnotationEventListenerAdapter</code> and
                        register them with the Event Bus.</para>
                </tip>
            </simplesect>
        </sect2>
    </sect1>
    <sect1>
        <title>Asynchronous Event Processing</title>
        <para>By default, event listeners process events in the thread that dispatches them. This
            means that the thread that executes the command will have to wait untill all event
            handling has finished. For some types of event listeners this is not the optimal form of
            processing. Asynchronous event processing improves the scalability of the application,
            with the penalty of added complexity to deal with "eventual consistency". Axon Framework
            provides the <code>AsynchronousCluster</code> implementation, which dispatches Events to
            Event Listeners asynchronously from the thread that published them to the
            cluster.</para>
        <note>
            <title>Configuring the Asynchronous Cluster in Spring</title>
            <para>In Spring, you can place a Spring <code>&lt;bean></code> element inside the
                    <code>&lt;axon:cluster></code> element, to indicate which cluster implementation
                you wish to use. Simply specify the bean configuration of an
                    <code>AsynchronousCluster</code> implementation to make a Cluster
                asynchronous.</para>
        </note>
        <para>The <code>AsynchronousCluster</code> needs an <code>Executor</code>, for example a
                <code>ThreadPoolExecutor</code> and a <code>SequencingPolicy</code>, a definition of
            which events may be processed in parallel, and which sequentially. Finally a
                <code>TransactionManager</code> can be provided to process events within a
            transaction, such as a database transaction.</para>
        <para>The <code>Executor</code> is responsible for executing the event processing. The
            actual implementation most likely depends on the environment that the application runs
            in and the SLA of the event handler. An example is the <code>ThreadPoolExecutor</code>,
            which maintains a pool of threads for the event handlers to use to process events. The
                <code>AsynchronousCluster</code> will manage the processing of incoming events in
            the provided executor. If an instance of a <code>ScheduledThreadPoolExecutor</code> is
            provided, the <code>AsynchronousCluster</code> will automatically leverage its ability
            to schedule processing in the cases of delayed retries.</para>
        <para>The <code>SequencingPolicy</code> defines whether events must be handled sequentially,
            in parallel or a combination of both. Policies return a sequence identifier of a given
            event. If the policy returns an equal itentifier for two events, this means that they
            must be handled sequentially be the event handler. A <code>null</code> sequence
            identifier means the event may be processed in parallel with any other event. </para>
        <para>Axon provides a number of common policies you can use: <itemizedlist>
                <listitem>
                    <para>The <code>FullConcurrencyPolicy</code> will tell Axon that this event
                        handler may handle all events concurrently. This means that there is no
                        relationship between the events that require them to be processed in a
                        particular order. </para>
                </listitem>
                <listitem>
                    <para>The <code>SequentialPolicy</code> tells Axon that all events must be
                        processed sequentially. Handling of an event will start when the handling of
                        a previous event is finished.</para>
                </listitem>
                <listitem>
                    <para>
                        <code>SequentialPerAggregatePolicy</code> will force domain events that were
                        raised from the same aggregate to be handled sequentially. However, events
                        from different aggregates may be handled concurrently. This is typically a
                        suitable policy to use for event listeners that update details from
                        aggregates in database tables. </para>
                </listitem>
            </itemizedlist>Besides these provided policies, you can define your own. All policies
            must implement the <code>EventSequencingPolicy</code> interface. This interface defines
            a single method, <code>getSequenceIdentifierFor</code>, that returns the identifier
            sequence identifier for a given event. Events for which an equal sequence identifer is
            returned must be processed sequentially. Events that produce a different sequence
            identifier may be processed concurrently. For performance reasons, policy
            implementations should return <code>null</code> if the event may be processed in
            parallel to any other event. This is faster, because Axon does not have to check for any
            restrictions on event processing.</para>
        <para>A <code>TransactionManager</code> can be assigned to a
                <code>AsynchronousCluster</code> to add transactional processing of events. To
            optimize processing, events can be processed in small batches inside a transaction. When
            using Spring, you can use the <code>SpringTransactionManager</code> to manage
            transactions with Spring's <code>PlatformTransactionManager</code> . For more
            customization of transactional behavior, you can alternatively configure a
                <code>UnitOfWorkFactory</code>. That factory will be used to generate the Unit of
            Work wrapping the Event Handling process. By default, a
                <code>DefaultUnitOfWorkFactory</code> is used, which uses the provided
                <code>TransactionManager</code>, if any, to manage the backing Transactions.</para>
        <simplesect>
            <title>Error handling</title>
            <para>The <code>AsynchronousCluster</code> uses an <code>ErrorHandler</code> to decide
                what needs to be done when an Event Listener or Unit of Work throws an Exception.
                The default behavior depends on the availability of a TransactionManager. If a
                    <code>TransactionManager</code> is provided, the default
                    <code>ErrorHandler</code> will request a rollback and retry the Event Handling
                after 2 seconds. If no <code>TransactionManager</code> is provided, the defautl
                    <code>ErrorHandler</code> will simply log the Exception and proceed with the
                next Event Listener, guaranteeing that each Event Listener will receive each Event.
                In any situation, a rollback will <emphasis>not</emphasis> be requested when the
                exception is explicitly non-transient (i.e. is caused by an
                    <code>AxonNonTransientException</code>).</para>
            <para>You can change this behavior by configuring another
                    <emphasis>ErrorHandler</emphasis>, or by creating your own. The ErrorHandler
                interface has a single method, which provides the Exception that occurred, the
                EventMessage being processed and a reference to the EventListener throwing the
                exception. The return value is of type RetryPolicy. The RetryPolicy tells the Event
                Processor what it needs to do with the failure. There are three static methods on
                RetryPolicy for the most common scenarios:</para>
            <para><itemizedlist>
                    <listitem>
                        <para><code>retryAfter(int timeout, TimeUnit unit)</code> tells the
                            scheduler that the Unit of Work should be rolled back, and the Event
                            Message should be rescheduled for handling after the given amount of
                            time. This means that some Event Listeners may have received the Event
                            more than once. </para>
                    </listitem>
                    <listitem>
                        <para><code>proceed()</code> tells the scheduler to ignore the Exception and
                            proceed with the processing of the Event Message. This may be with the
                            intent to skip the Event on the Event Listener, or because the
                                <code>ErrorHandler</code> has managed to resolve the problem by
                            retrying invoking the <code>EventHandler</code> itself.</para>
                    </listitem>
                    <listitem>
                        <para><code>skip()</code> tells the scheduler to rollback the Unit of Work
                            and proceed with the next Event Message. If all Event Listeners properly
                            support Transactions, will effectively mean that the Event is skipped
                            altogether.</para>
                    </listitem>
                </itemizedlist>If the <code>RetryPolicy</code> you wish to use does not depend on
                the type of <code>Exception</code>, <code>EventMessage</code> or
                    <code>EventListener</code>, you can use the <code>DefaultErrorHandler</code> and
                pass the desired <code>RetryPolicy</code> as its constructor parameter. It will
                return that <code>RetryPolicy</code> on each exception, unless it requests a retry
                of an Event that caused an explicitly non-transient exception.</para>
        </simplesect>
    </sect1>
    <sect1>
        <title xml:id="distributed-event-bus">Distributing the Event Bus</title>
        <para>In a distributed environment, it may be necessary to transport Event Messages between
            JVM's. The <code>ClusteringEventBus</code> has a possiblity to define an
                <code>EventBusTerminal</code>. This is an interface to a mechansim that publishes
            Events to all relevant clusters. Some EventBusTerminal implementations allow
            distribution of Events over multiple JVM's.</para>
        <para>
            <note>
                <title>Background of the name "Terminal"</title>
                <para>While most developers association the word "terminal" to a thin client
                    computer connected to a mainframe, the association to make here is slightly
                    different. In Neurology, an Axon Terminal is an endpoint of an Axon that
                    transmits electronic impulses from one Neuron to another.</para>
                <para>For more detailed information, see <link
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        xlink:href="http://en.wikipedia.org/wiki/Axon_terminal"
                        >http://en.wikipedia.org/wiki/Axon_terminal</link>.</para>
            </note>
        </para>
        <sect2>
            <title>Spring AMQP Terminal</title>
            <para>The Spring AMQP Terminal uses the Spring AMQP module to transmit events to an AMQP
                compatible message broker, such as Rabbit MQ. It also connects local clusters to
                queues on that message broker.</para>
            <para>The <code>axon-amqp</code> namespace
                    (<code>http://www.axonframework.org/schema/amqp</code>) allows you to configure
                an AMQP Terminal by adding the <code>&lt;axon-amqp:terminal></code> element to the
                Spring application context. On this element, you can define different properties for
                the terminal, as well as a configuration containing defaults to use to connect each
                cluster to an AMQP Queue.</para>
            <para>The example below shows an example configuration for an AMQP Terminal. The
                    <code>default-configuration</code> element specified the defaults for the
                Clusters if they don't provide their own
                values.<programlisting>&lt;axon-amqp:terminal id="terminal" 
                    connection-factory="amqpConnection" 
                    serializer="serializer"
                    exchange-name="AxonEventBusExchange">
    &lt;axon-amqp:default-configuration transaction-manager="transactionManager"
                                     transaction-size="25" prefetch="200"
                                     error-handler="loggingErrorHandler"/>
&lt;/axon-amqp:terminal>

&lt;bean id="amqpConnection" class="org.springframework.amqp.rabbit.connection.CachingConnectionFactory"/></programlisting>
                The configure the Spring AMQP Terminal "manually", you need to specify a number of
                beans in your application context:</para>
            <itemizedlist>
                <listitem>
                    <para>The <code>ListenerContainerLifecycleManager</code> is responsible for
                        creating ListenerContainers. These are the Spring classes that listen for
                        messages on the AMQP Queues and forward them to the processing components.
                        The <code>ListenerContainerLifecycleManager</code> allows you to configure
                        the number of messages to process in a single transaction, the number of
                        messages it may read ahead, etc.</para>
                    <para>Note that the <code>ListenerContainerLifecycleManager</code> must be
                        defined as a top-level bean.</para>
                </listitem>
                <listitem>
                    <para>An AMQP <code>ConnectionFactory</code>, which creates the connections to
                        the AMQP Message Broker. Spring provides the
                            <code>CachingConnectionFactory</code>, which is a sensible
                        default.</para>
                </listitem>
                <listitem>
                    <para>The Spring AMQPTerminal itself, which connects the aforementioned
                        components to the event publishers and event listeners. There is a large
                        number of configuration options that allow you to tweak the terminal's behavior:
                        <itemizedlist>
                            <listitem>
                                <para>transactional: indicates whether the messages should be
                                    dispatched to the AMQP Broker inside a transaction. This is
                                    especially useful when multiple events need to be sent either
                                    completely, or not at all.</para>
                            </listitem>
                            <listitem>
                                <para>durable: indicates whether messsages should be durable (i.e.
                                    survive a Broker shutdown) or not. Obviously, message durability
                                    involves a performance impact.</para>
                            </listitem>
                            <listitem>
                                <para>connectionFactory: configures the ConnectionFactory to use.
                                    Useful when the application context contains more than one
                                    instance. Otherwise, the only available instance is
                                    autowired.</para>
                            </listitem>
                            <listitem>
                                <para>serializer: the serializer to serialize the MetaData and
                                    Payload of EventMessages with. Defaults to an autowired
                                    serializer.</para>
                            </listitem>
                            <listitem>
                                <para>exchangeName or exchange: defines the exchange (either defined
                                    by the name, or by a reference to an Exchange bean) to which
                                    published Event Messages should be sent. Defaults to
                                    "Axon.EventBus"</para>
                            </listitem>
                            <listitem>
                                <para>queueNameResolver: defines the mechanism that chooses the
                                    Queue that each Cluster should be connected to. By default, the
                                    resolver will use the configuration provided in each Cluster's
                                    Meta Data under the name "AMQP.Config". Otherwise, it uses the
                                    Cluster's name as Queue Name.</para>
                            </listitem>
                            <listitem>
                                <para>routingKeyResolver: defines the mechanism that generates an
                                    AMQP routing key for an outgoing Message. Defaults to a routing
                                    key resolver that returns the package name of the Message's
                                    payload. Routing keys can be used by echanges to define which
                                    queues should receive a (copy of a) Message</para>
                            </listitem>
                            <listitem>
                                <para>listenerContainerLifecycleManager: when the application
                                    context contains more than one, defines which
                                    listenerContainerLifecycleManager instance to use.</para>
                            </listitem>
                            <listitem>
                                <para>exclusive: indicates whether this Cluster accepts to share a
                                    Queue with other Cluster instances. Default to
                                    <code>true</code>. If a second cluster is attampting to connect
                                    exclusively to a queue, an exception is thrown. The Connector
                                    catches this exception and reattempts to connect each 2 seconds.
                                    This allows for automatic failover when a machine drops its
                                    connection.</para>
                            </listitem>
                        </itemizedlist></para>
                </listitem>
            </itemizedlist>
            <para>When a cluster is selected for an Event Listener, it will be registered with the
                terminal. At that point, the Spring AMQP terminal will check if there is any
                cluster-specific configuration available. It does so by checking the
                    <code>AMQP.Config</code> MetaData value. If that value is an instance of
                    <code>AMQPConsumerConfiguration</code> (such as
                    <code>SpringAMQPConsumerConfiguration</code>) any settings configured there will
                override the defaults set on the terminal itself. This allows you to specify
                different behavior (such as transaction size) for different clusters.</para>
            <programlisting>// XML Configuration for a Cluster with AMQPConsumerConfiguration
&lt;axon:cluster id="myDefaultCluster" default="true">
    &lt;axon:meta-data>
        &lt;entry key="AMQP.Config">
            &lt;axon-amqp:configuration transaction-size="20000"/>
        &lt;/entry>
    &lt;/axon:meta-data>
&lt;/axon:cluster></programlisting>
        </sect2>
    </sect1>
    <sect1>
        <title>Replaying Events on a Cluster</title>
        <para>One of the advantages of Event Sourcing is that you keep track of the entire history
            of the application. This history allows you to extract valuable information and build
            new models out of them. For example, when a screen is added to the application, you can
            create a new query model and database tables, and have these filled using events you
            have collected in the past. Sometimes, replays of the Event Store are also needed to fix
            data that has been corrupted due to a bug.</para>
        <simplesect>
            <title>Configuration of Replays</title>
            <para>Axon provides the <code>ReplayingCluster</code>, a wrapper around another
                    <code>Cluster</code> implementation that adds the replay capability. The
                ReplayingCluster is initialized with a number of resources. First of all, it needs
                another Cluster implementation. That other cluster is the actual cluster that takes
                care of dispatching Event Messages to subscribed listeners. It also needs a
                reference to the Event Store (implementing <code>EventStoreManagement</code>) that
                will supply the Events for the replay. A transaction manager is used to wrap the
                replay in a transaction. Since a single transaction may be too large to be
                efficient, you can configure a "commit threshold" to indicate the number of messages
                that should be processed before performing an intermediate commit. Finally, you need
                to supply an <code>IncomingMessageHandler</code>. The
                    <code>IncomingMessageHandler</code> tells the ReplayingCluster what to do when
                an Event Message is published to the cluster while it is replaying.</para>
            <warning>
                <para>Make sure not to replay onto Clusters that contain Event Listeners that do not
                    support replaying. A typical example is an Event Listener that sends emails.
                    Replaying on a cluster that contains such an Event Listener can have nasty
                    side-effects.</para>
            </warning>
            <para>Axon provides two <code>IncomingMessageHandler</code> implementations. The
                    <code>BackloggingIncomingMessageHandler</code> simply backlogs any incoming
                events (in-memory) and postpones processing of these events until the replay is
                finished. If an event is backlogged, but was also part of the replay, it is
                automatically removed from the backlog to prevent duplicate processing. The other
                implementation is the <code>DiscardingIncomingMessageHandler</code>. As the name
                suggests, it simply discards any messages published during a replay. This
                implementation will ensure the fastest replay, but is not safe to use when you
                expect messages to be published to the cluster during the replay. You can also
                create your own implementation. The JavaDoc describes the requirements (incl. thread
                safety) for each method.</para>
            <note>
                <para>Although it is technically possible to do a full replay at runtime, it should
                    be considered a maintenance operation and be executed while the cluster is not
                    in active use by the application.</para>
            </note>
        </simplesect>
        <simplesect>
            <title>ReplayCluster configuration in Spring</title>
            <para>In Spring, a Cluster can be marked as replayable by adding the
                    <code>&lt;axon:replay-config></code> element as a child if the
                    <code>&lt;axon:cluster></code> element. When the replay-config element is
                present, Axon will automatically wrap the cluster in a <code>ReplayingCluster</code>
                using the provided configuration. This also means that
                    <code>applicationContext.getBean(clusterName)</code> will return a bean of type
                    <code>ReplayingCluster</code>.<!--TODO: Example--></para>
        </simplesect>
        <simplesect>
            <title>Preparing for a replay</title>
            <para>In many cases, the data source used by Event Listeners needs to be prepared for a
                replay. Database tables, for example, typically need to be cleared. Event Listeners
                can implement the <code>ReplayAware</code> interface. When they do, their
                    <code>beforeReplay</code> and <code>afterReplay</code> will be invoked before
                and after the replay respectively. Both methods are invoked within the scope of a
                transaction.</para>
        </simplesect>
        <simplesect>
            <title>Triggering a Replay</title>
            <para>Axon does not automatically trigger a replay. The ReplayingCluster provides two
                methods that can start a replay: <code>startReplay()</code> and
                    <code>startReplay(Executor)</code>. The first will execute the replay in the
                calling thread, meaning that the call will return when the replay is finished. The
                latter will execute the replay using the given executor and return a Future object
                that allows the caller to check if the replay is finished.</para>
            <note>
                <para>Note that a replay may take a long time to finish, depending on the number of
                    Events that need to be processed. Therefore, ensure that it is not possible to
                    rebuild the model using other models already available, which is typically
                    faster. Also make sure to properly test a replay before applying it in a
                    production environment.</para>
            </note>
        </simplesect>
    </sect1>
</chapter>
