<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Copyright (c) 2010-2012. Axon Framework
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~     http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->
<chapter xml:id="command-handling" version="5.0" xmlns="http://docbook.org/ns/docbook">
    <title>Command Handling</title>
    <para>A state change within an application starts with a Command. A Command is a combination of
        expressed intent (which describes what you want done) as well as the information required to
        undertake action based on that intent. A Command Handler is responsible for handling
        commands of a certain type and taking action based on the information contained inside
        it.
    </para>
    <para>The use of an explicit command dispatching mechanism has a number of advantages. First of
        all, there is a single object that clearly describes the intent of the client. By logging
        the command, you store both the intent and related data for future reference. Command
        handling also makes it easy to expose your command processing components to remote clients,
        via web services for example. Testing also becomes a lot easier, you could define test
        scripts by just defining the starting situation (given), command to execute (when) and
        expected results (then) by listing a number of events and commands (see <xref
            linkend="testing"/>). The last major advantage is that it is very easy to switch between
        synchronous and asynchronous command processing. </para>
    <para>This doesn't mean Command dispatching using explicit command object is the only right way
        to do it. The goal of Axon is not to prescribe a specific way of working, but to support you
        doing it your way. It is still possible to use a Service layer that you can invoke to
        execute commands. The method will just need to start a unit of work (see <xref
            linkend="unit-of-work"/>) and perform a commit or rollback on it when the method is
        finished. </para>
    <para>The next sections provide an overview of the tasks related to creating a Command
        Handling infrastructure with the Axon Framework.
    </para>
    <sect1>
        <title>The Command Gateway</title>
        <para>The Command Gateway is a convenient interface towards the Command dispatching
            mechanism. While you are not required to use a Gateway to dispatch Commands, it is
            generally the easiest option to do so. </para>
        <para>There are two ways to use a Command Gateway. The first is to use the
                <code>CommandGateway</code> interface and <code>DefaultCommandGateway</code>
            implementation provided by Axon. The command gateway provides a number of methods that
            allow you to send a command and wait for a result either synchronously, with a timeout
            or asynchronously.</para>
        <para>The other option is perhaps the most flexible of all. You can turn almost any
            interface into a Command Gateway using the <code>GatewayProxyFactory</code>. This allows
            you to define your application's interface using strong typing and declaring your own
            (checked) business exceptions. Axon will automatically generate an implementation for
            that interface at runtime.</para>
        <sect2>
            <title>Configuring the Command Gateway</title>
            <para>Both your custom gateway and the one provided by Axon need to be configured with
                at least access to the Command Bus. In addition, the Command Gateway can be
                configured with a <code>RetryScheduler</code> and any number of
                    <code>CommandDispatchInterceptor</code>s.</para>
            <para>The <code>RetryScheduler</code> is capable of scheduling retries when command
                execution has failed. The <code>IntervalRetryScheduler</code> is an implementation
                that will retry a given command at set intervals until it succeeds, or a maximum
                number of retries is done. When a command fails due to an exception that is
                explicitly non-transient, no retries are done at all. Note that the retry scheduler
                is only invoked when a command fails due to a <code>RuntimeException</code>. Checked
                exceptions are regarded "business exception" and will never trigger a retry.</para>
            <para><code>CommandDispatchInterceptor</code>s allow modification of
                    <code>CommandMessage</code>s prior to dispatching them to the Command Bus. In
                contrast to <code>CommandDispatchInterceptor</code>s configured on the CommandBus,
                these interceptors are only invoked when messages are sent through this gateway. The
                interceptors can be used to attach meta data to a command or do validation, for
                example.</para>
        </sect2>
        <sect2>
            <title>Creating a Custom Command Gateway</title>
            <para>The <code>GatewayProxyFactory</code> creates an instance of a Command Gateway
                based on an interface class. The behavior of each method is based on the parameter
                types, return type and declared exception. Using this gateway is not only
                convenient, it makes testing a lot easier by allowing you to mock your interface
                where needed.</para>
            <para>This is how parameter affect the behavior of the CommandGateway:</para>
            <itemizedlist>
                <listitem>
                    <para>The first parameter is expected to be the actual command object to
                        dispatch.</para>
                </listitem>
                <listitem>
                    <para>Parameters annotated with <code>@MetaData</code> will have their value
                        assigned to the meta data field with the identifier passed as annotation
                        parameter</para>
                </listitem>
                <listitem>
                    <para>Parameters of type <code>CommandCallback</code> will have their
                            <code>onSuccess</code> or <code>onFailure</code> invoked after the
                        Command is handled. You may pass in more than one callback, and it may be
                        combined with a return value. In that case, the invocations of the callback
                        will always match with the return value (or exception).</para>
                </listitem>
                <listitem>
                    <para>The last two parameters may be of types <code>long</code> (or
                            <code>int</code>) and <code>TimeUnit</code>. In that case the method
                        will block at most as long as these parameters indicate. How the method
                        reacts on a timeout depends on the exceptions declared on the method (see
                        below). Note that if other properties of the method prevent blocking
                        altogether, a timeout will never occur.</para>
                </listitem>
            </itemizedlist>
            <para>The declared return value of a method will also affect its behavior:</para>
            <itemizedlist>
                <listitem>
                    <para>A <code>void</code> return type will cause the method to return
                        immediately, unless there are other indications on the method that one would
                        want to wait, such as a timeout or declared exceptions.</para>
                </listitem>
                <listitem>
                    <para>A Future return type will cause the method to return immediately. You can
                        access the result of the Command Handler using the Future instance returned
                        from the method. Exceptions and timeouts declared on the method are
                        ignored.</para>
                </listitem>
                <listitem>
                    <para>Any other return type will cause the method to block until a result is
                        available. The result is cast to the return type (causing a
                        ClassCastException if the types don't match).</para>
                </listitem>
            </itemizedlist>
            <para>Exceptions have the following effect:</para>
            <itemizedlist>
                <listitem>
                    <para>Any declared checked exception will be thrown if the Command Handler (or
                        an interceptor) threw an exceptions of that type. If a checked exception is
                        thrown that has not been declared, it is wrapped in a
                            <code>CommandExecutionException</code>, which is a
                            <code>RuntimeException</code>.</para>
                </listitem>
                <listitem>
                    <para>When a timeout occurs, the default behavior is to return <code>null</code>
                        from the method. This can be changed by declaring a
                            <code>TimeoutException</code>. If this exception is declared, a
                            <code>TimeoutException</code> is thrown instead.</para>
                </listitem>
                <listitem>
                    <para>When a Thread is interrupted while waiting for a result, the default
                        behavior is to return null. In that case, the interrupted flag is set back
                        on the Thread. By declaring an <code>InterruptedException</code> on the
                        method, this behavior is changed to throw that exception instead. The
                        interrupt flag is removed when the exception is thrown, consistent with the
                        java specification.</para>
                </listitem>
                <listitem>
                    <para>Other Runtime Exceptions may be declared on the method, but will not have
                        any effect other than clarification to the API user.</para>
                </listitem>
            </itemizedlist>
            <para>Finaly, there is the possiblity to use annotations:</para>
            <itemizedlist>
                <listitem>
                    <para>As specified in the parameter section, the <code>@MetaData</code>
                        annotation on a parameter will have the value of that parameter added as
                        meta data value. The key of the meta data entry is provided as parameter to
                        the annotation.</para>
                </listitem>
                <listitem>
                    <para>Methods annotated with <code>@Timeout</code> will block at most the
                        indicated amount of time. This annotation is ignored if the method declares
                        timeout parameters.</para>
                </listitem>
                <listitem>
                    <para>Classes annotated with <code>@Timeout</code> will cause all methods
                        declared in that class to block at most the indicated amount of time, unless
                        they are annotated with their own <code>@Timeout</code> annotation or
                        specify timeout parameters.</para>
                </listitem>
            </itemizedlist>
            <programlisting language="java">public interface MyGateway {
    
    // fire and forget
    void sendCommand(MyPayloadType command);

    // method that attaches meta data and will wait for a result for 10 seconds
    @Timeout(value = 20, unit = TimeUnit.SECONDS)
    ReturnValue sendCommandAndWaitForAResult(MyPayloadType command, 
                                             @MetaData("userId") String userId);

    // alternative that throws exceptions on timeout
    @Timeout(value = 20, unit = TimeUnit.SECONDS)
    ReturnValue sendCommandAndWaitForAResult(MyPayloadType command) 
                         throws TimeoutException, InterruptedException;

    // this method will also wait, caller decides how long
    void sendCommandAndWait(MyPayloadType command, long timeout, TimeUnit unit) 
                         throws TimeoutException, InterruptedException;
}</programlisting>
            <simplesect>
                <title>Configuring a custom Command Gateway Spring</title>
                <para>When using Spring, the easiest way to create a custom Command Gateway is by
                    using the <code>CommandGatewayFactoryBean</code>. It uses setter injection,
                    making it easier to configure. Only the "commandBus" and "gatewayInterface"
                    properties are mandatory.</para>
            </simplesect>
        </sect2>
    </sect1>
    <sect1 xml:id="command-bus">
        <title>The Command Bus</title>
        <para>The Command Bus is the mechanism that dispatches commands to their respective Command
            Handler. Commands are always sent to only one (and exactly one) command handler. If no
            command handler is available for a dispatched command, an exception
                (<code>NoHandlerForCommandException</code>) is thrown. Subscribing multiple command
            handlers to the same command type will result in subscriptions replacing each other. In
            that case, the last subscription wins. </para>
        <sect2>
            <title>Dispatching commands</title>
            <para>The CommandBus provides two methods to dispatch commands to their respective
                handler: <code>dispatch(commandMessage, callback)</code> and
                    <code>dispatch(commandMessage)</code>. The first parameter is a message
                containing the actual command to dispatch. The optional second parameter takes a
                callback that allows the dispatching component to be notified when command handling
                is completed. This callback has two methods: <code>onSuccess()</code> and
                    <code>onFailure()</code>, which are called when command handling returned
                normally, or when it threw an exception, respectively. </para>
            <para>The calling component may not assume that the callback is invoked in the same
                thread that dispatched the command. If the calling thread depends on the result
                before continuing, you can use the <code>FutureCallback</code>. It is a combination
                of a <code>Future</code> (as defined in the java.concurrent package) and Axon's
                    <code>CommandCallback</code>. Alternatively, consider using a Command
                Gateway.</para>
            <para>Best scalability is achieved when your application is not interested in the result
                of a dispatched command at all. In that case, you should use the single-parameter
                version of the <code>dispatch</code> method. If the <code>CommandBus</code> is fully
                asynchronous, it will return immediately after the command has been successfully
                dispatched. Your application will just have to guarantee that the command is
                processed and with "positive outcome", sooner or later... </para>
        </sect2>
        <sect2>
            <title>SimpleCommandBus</title>
            <para>The <code>SimpleCommandBus</code> is, as the name suggests, the simplest
                implementation. It does straightforward processing of commands in the thread that
                dispatches them. After a command is processed, the modified aggregate(s) are saved
                and generated events are published in that same thread. In most scenario's, such as
                web applications, this implementation will suit your needs. </para>
            <para>The SimpleCommandBus allows interceptors to be configured.
                    <code>CommandDispatchInterceptor</code>s are invoked when a command is
                dispatched on the Command Bus. The <code>CommandHandlerInterceptor</code>s are
                invoked before the actual command handler method is, allowing you to do modify or
                block the command. See <xref linkend="command-handler-interceptors"/> for more
                information. </para>
            <para>The SimpleCommandBus maintains a Unit of Work for each command published. This
                Unit of Work is created by a factory: the UnitOfWorkFactory. To suit any specifc
                needs your application might have, you can supply your own factory to change the
                Unit of Work implementation used. </para>
            <para>Since all command processing is done in the same thread, this implementation is
                limited to the JVM's boundaries. The performance of this implementation is good, but
                not extraordinary. To cross JVM boundaries, or to get the most out of your CPU
                cycles, check out the other CommandBus implementations. </para>
        </sect2>
        <sect2>
            <title>DisruptorCommandBus</title>
            <para>The SimpleCommandBus has reasonable performance characteristics, especially when
                you've gone through the performance tips in <xref linkend="performance-tuning"/>.
                The fact that the SimpleCommandBus needs locking to prevent multiple threads from
                concurrently accessing the same aggregate causes processing overhead and lock
                contention. </para>
            <para>The <code>DisruptorCommandBus</code> takes a different approach to multithreaded
                processing. Instead of having multiple threads each doing the same process, there
                are multiple threads, each taking care of a piece of the process. The
                    <code>DisruptorCommandBus</code> uses the Disruptor (<link
                    xmlns:ns1="http://www.w3.org/1999/xlink"
                    ns1:href="http://code.google.com/p/disruptor"
                    >http://code.google.com/p/disruptor</link>), a small framework for concurrent
                programming, to achieve much better performance, by just taking a different approach
                to multithreading. Instead of doing the processing in the calling thread, the tasks
                are handed of to two groups of threads, that each take care of a part of the
                processing. The first group of threads will execute the command handler, changing an
                aggregate's state. The second group will store and publish the events to the Event
                Store and Event Bus. </para>
            <para>While the <code>DisruptorCommandBus</code> easily outperforms the
                    <code>SimpleCommandBus</code> by a factor 4(!), there are a few limitations: <itemizedlist>
                    <listitem>
                        <para>The DisruptorCommandBus only supports Event Sourced Aggregates. This
                            Command Bus also acts as a Repository for the aggreates processed by the
                            Disruptor. To get a reference to the Repository, use
                                <code>createRepository(AggregateFactory)</code>.</para>
                    </listitem>
                    <listitem>
                        <para>A Command can only result in a state change in a single aggregate
                            instance. </para>
                    </listitem>
                    <listitem>
                        <para>Commands should generally not cause a failure that requires a rollback
                            of the Unit of Work. When a rollback occurs, the DisruptorCommandBus
                            cannot guarantee that Commands are processed in the order they were
                            dispatched. Furthermore, it requires a retry of a number of other
                            commands, causing unnecessary computations. </para>
                    </listitem>
                    <listitem>
                        <para>When creating a new Aggregate Instance, commands updating that created
                            instance may not all happen in the exact order as provided. Once the
                            aggregate is created, all commands will be executed exactly in the order
                            they were dispatched. To ensure the order, use a callback on the
                            creating command to wait for the aggregate being created. It shouldn't
                            take more than a few milliseconds. </para>
                    </listitem>
                </itemizedlist></para>
            <simplesect>
                <title>Configuring the DisruptorCommandBus</title>
                <para>To construct a <code>DisruptorCommandBus</code> instance, you need an
                        <code>AggregateFactory</code>, an <code>EventBus</code> and
                        <code>EventStore</code>. These components are explained in <xref
                        xmlns:xlink="http://www.w3.org/1999/xlink"
                        linkend="repositories-and-event-stores"/> and <xref
                        xmlns:xlink="http://www.w3.org/1999/xlink" linkend="event-bus"/>. Finally,
                    you also need a <code>CommandTargetResolver</code>. This is a mechanism that
                    tells the disruptor which aggregate is the target of a specific Command. There
                    are two implementations provided by Axon: the
                        <code>AnnotationCommandTargetResolver</code>, which uses annotations to
                    describe the target, or the <code>MetaDataCommandTargetResolver</code>, which
                    uses the Command's Meta Data fields. </para>
                <para>Optionally, you can provide a <code>DisruptorConfiguration</code> instance,
                    which allows you to tweak the configuration to optimize performance for your
                    specific environment. Spring users can use the &lt;axon:disruptor-command-bus>
                    element for easier configuration of the <code>DisruptorCommandBus</code>.<itemizedlist>
                        <listitem>
                            <para>ClaimStrategy: Sets the ClaimStrategy instance, which defines how
                                a Thread dispatching a command can claim a "position" in the
                                DisruptorCommandBus. Defaults to a
                                    <code>MultiThreadedClaimStrategy</code> with 4096 positions,
                                which is safe to use when multiple threads can publish to the
                                CommandBus.</para>
                        </listitem>
                        <listitem>
                            <para>WaitStrategy: The strategy to use when the processor threads (the
                                three threads taking care of the actual processing) need to wait for
                                eachother. The best WaitStrategy depends on the number of cores
                                available in the machine, and the number of other processes running.
                                If low latency is crucial, and the DisruptorCommandBus may claim
                                cores for itself, you can use the <code>BusySpinWaitStrategy</code>.
                                To make the Command Bus claim less of the CPU and allow other
                                threads to do processing, use the <code>YieldingWaitStrategy</code>.
                                Finally, you can use the <code>SleepingWaitStrategy</code> and
                                    <code>BlockingWaitStrategy</code> to allow other processes a
                                fair share of CPU. The latter is suitable if the Command Bus is not
                                expected to be processing full-time. Defaults to the
                                    <code>BlockingWaitStrategy</code>.</para>
                        </listitem>
                        <listitem>
                            <para>Executor: Sets the Executor that provides the Threads for the
                                DisruptorCommandBus. This executor must be able to provide at least
                                4 threads. 3 threads are claimed by the processing components of the
                                DisruptorCommandBus. Extra threads are used to invoke callbacks and
                                to schedule retries in case an Aggregate's state is detected to be
                                corrupt. Defaults to a CachedThreadPool that provides threads from a
                                thread group called "DisruptorCommandBus".</para>
                        </listitem>
                        <listitem>
                            <para>TransactionManager: Defines the Transaction Manager that should
                                ensure the storage of events and their publication are executed
                                transactionally.</para>
                        </listitem>
                        <listitem>
                            <para>InvokerInterceptors: Defines the
                                    <code>CommandHandlerInterceptor</code>s that are to be used in
                                the invocation process. This is the process that calls the actual
                                Command Handler method.</para>
                        </listitem>
                        <listitem>
                            <para>PublisherInterceptors: Defines the
                                    <code>CommandHandlerInterceptor</code>s that are to be used in
                                the publication process. This is the process that stores and
                                publishes the generated events.</para>
                        </listitem>
                        <listitem>
                            <para>RollbackConfiguration: Defines on which Exceptions a Unit of Work
                                should be rolled back. Defaults to a configuration that rolls back
                                on unchecked exceptions.</para>
                        </listitem>
                        <listitem>
                            <para>RescheduleCommandsOnCorruptState: Indicates whether Commands that
                                have been executed against an Aggregate that has been corrupted
                                (e.g. because a Unit of Work was rolled back) should be rescheduled.
                                If <code>false</code> the callback's <code>onFailure()</code> method
                                will be invoked. If <code>true</code> (the default), the command
                                will be rescheduled instead.</para>
                        </listitem>
                        <listitem>
                            <para>CoolingDownPeriod: Sets the number of seconds to wait to make sure
                                all commands are processed. During the cooling down period, no new
                                commands are accepted, but existing commands are processed, and
                                rescheduled when necessary. The cooling down period ensures that
                                threads are available for rescheduling the commands and calling
                                callbacks. Defaults to 1000 (1 second).</para>
                        </listitem>
                        <listitem>
                            <para>Cache: Sets the cache that stores aggregate instances that have
                                been reconstructed from the Event Store. The cache is used to store
                                aggregate instances that are not in active use by the
                                disruptor.</para>
                        </listitem>
                        <listitem>
                            <para>InvokerThreadCount: The number of threads to assign to the
                                invocation of command handlers. A good starting point is half the
                                number of cores in the machine.</para>
                        </listitem>
                        <listitem>
                            <para>PublisherThreadCount: The number of threads to use to publish
                                events. A good starting point is half the number of cores, and could
                                be increased if a lot of time is spent on IO.</para>
                        </listitem>
                        <listitem>
                            <para>SerializerThreadCount: The number of threads to use to
                                pre-serialize events. This defaults to 1, but is ignored if no
                                serializer is configured.</para>
                        </listitem>
                        <listitem>
                            <para>Serializer: The serializer to perform pre-serialization with. When
                                a serializer is configured, the DisruptorCommandBus will wrap all
                                generated events in a SerializationAware message. The serialized
                                form of the payload and meta data is attached before they are
                                published to the Event Store or Event Bus. This can drastically
                                improve performance when the same serializer is used to store and
                                publish events to a remote destination.</para>
                        </listitem>
                    </itemizedlist></para>
            </simplesect>
        </sect2>
    </sect1>
    <sect1>
        <title>Command Handlers</title>
        <para>The Command Handler is the object that receives a Command of a pre-defined type and
            takes action based on its contents. In Axon, a Command may be any object. There is no
            predefined type that needs to be implemented.
        </para>
        <sect2>
            <title>Creating a Command Handler</title>
            <para>A Command Handler must implement the <code>CommandHandler</code> interface. This
                interface declares only a single method: <code>Object handle(CommandMessage&lt;T>
                    command, UnitOfWork uow)</code>, where T is the type of Command this Handler can
                process. The concept of the UnitOfWork is explained in <xref linkend="unit-of-work"
                />. Be weary when using return values. Typically, it is a bad idea to use return
                values to return server-generated identifiers. Consider using client-generated
                (random) identifiers, such as UUIDs. They allow for a "fire and forget" style of
                command handlers, where a client does not have to wait for a response. As return
                value in such a case, you are recommended to simply return <code>null</code>. </para>
        </sect2>
        <sect2>
            <title>Subscribing to a Command Bus</title>
            <para>You can subscribe and unsubscribe command handlers using the
                    <code>subscribe</code> and <code>unsubscribe</code> methods on
                    <code>CommandBus</code>, respectively. They both take two parameters: the type
                of command to (un)subscribe the handler to, and the handler to (un)subscribe. An
                unsubscription will only be successful if the handler passed as the second parameter
                was currently assigned to handle that type of command. If another command was
                subscribed to that type of command, nothing happens.
                <programlisting language="java">CommandBus commandBus = new SimpleCommandBus();

// to subscribe a handler:
commandBus.subscribe(MyPayloadType.class.getName(), myCommandHandler);

// we can subscribe the same handler to different command types
commandBus.subscribe(MyOtherPayload.class.getName(), myCommandHandler);

// we can also unsubscribe the handler from one of these types:
commandBus.unsubscribe(MyOtherPayload.class.getName(), myCommandHandler);

// we don't have to use the payload to identifier the command type (but it's a good default)
commandBus.subscribe("MyCustomCommand", myCommandHandler);</programlisting></para>
        </sect2>
        <sect2>
            <title>Annotation based handlers</title>
            <para>More often than not, a command handler will need to process several types of
                closely related commands. With Axon's annotation support you can use any POJO as
                command handler. Just add the <code>@CommandHandler</code> annotation to your
                methods to turn them into a command handler. These methods should declare the
                command to process as the first parameter. They may take optional extra parameters,
                such as the <code>UnitOfWork</code> for that command (see <xref
                    linkend="unit-of-work"/>). Note that for each command type, there may only be
                one handler! This restriction counts for all handlers registered to the same command
                bus. </para>
            <annotation>
                <para>There is a number of extra parameters that can be added to the
                        <code>@CommandHandler</code> methods:<itemizedlist>
                        <listitem>
                            <para><code>UnitOfWork</code>: parameters of this type will be given a
                                reference to the current Unit of Work</para>
                        </listitem>
                        <listitem>
                            <para><code>MetaData</code>: will be given a reference to the object
                                holding all Meta Data properties of the Command</para>
                        </listitem>
                        <listitem>
                            <para><code>@MetaData(propertyName)</code>: parameters annotated with
                                this annotation will be given the value of the Meta Data property
                                with the given property name. If no such property exists, it either
                                provides <code>null</code> (when <code>required = false</code>) or
                                doesn't match against the Command Handler, potentially refusing the
                                Command entirely.</para>
                        </listitem>
                        <listitem>
                            <para>Any custom parameter for which a <code>ParameterResolver</code>
                                has been configured. See the JavaDoc of
                                    <code>ParameterResolverFactory</code> for more
                                information.</para>
                        </listitem>
                    </itemizedlist><programlisting language="java">public class MyAnnotatedHandler {

    @CommandHandler
    public void handleSomeCommand(SomeCommand command, @MetaData("userId") String userId) {
        // whatever logic here
    }

    @CommandHandler(commandName = "myCustomCommand")
    public void handleCustomCommand(SomeCommand command) {
       // handling logic here
    }

}

// To register the annotated handlers to the command bus:
AnnotationCommandHandlerAdapter handler = AnnotationCommandHandlerAdapter.subscribe(new MyAnnotatedHandler(), commandBus);

// and to unsubscribe again:
handler.unsubscribe();</programlisting></para>
            </annotation>
            <para>You can use the <code>AnnotationCommandHandlerAdapter</code> to turn your
                annotated class into a <code>CommandHandler</code>. The adapter also takes a
                    <code>CommandBus</code> instance. Use the <code>subscribe()</code> method on the
                adapter to subscribe all the annotated handlers to the command bus using the correct
                command type. </para>
            <note>
                <para>If you use Spring, you can add the <code>&lt;axon:annotation-config/></code>
                    element to your application context. It will turn any bean with
                        <code>@CommandHandler</code> annotated methods into a command handler. They
                    will also be automatically subscribed to the <code>CommandBus</code>. In
                    combination with Spring's classpath scanning (<code>@Component</code>), this
                    will automatically subscribe any command handler in your application. </para>
            </note>
            <simplesect>
                <title><code>AggregateAnnotationCommandHandler</code>
                </title>
                <para>It is not unlikely that most command handler operations have an identical
                    structure: they load an Aggregate from a repository and call a method on the
                    returned aggregate using values from the command as parameter. If that is the
                    case, you might benefit from a generic command handler: the
                    <code>AggregateAnnotationCommandHandler</code>. This command handler uses
                    <code>@CommandHandler</code>
                    annotations on the aggregate's methods to
                    identify which methods need to be invoked for an incoming command. If the
                    <code>@CommandHandler</code>
                    annotation is placed on a constructor, that
                    command will cause a new Aggregate instance to be created.
                </para>
                <para>The
                    <code>AggregateAnnotationCommandHandler</code>
                    still needs to know which
                    aggregate instance (identified by it's unique Aggregate Identifier) to load and
                    which version to expect. By default, the
                    <code>AggregateAnnotationCommandHandler</code>
                    uses annotations on the
                    command object to find this information. The
                    <code>@TargetAggregateIdentifier</code>
                    annotation must be put on a field or
                    getter method to indicate where the identifier of the target Aggregate can be
                    found. Similarly, the
                    <code>@TargetAggregateVersion</code>
                    may be used to
                    indicate the expected version.
                </para>
                <para>The
                    <code>@TargetAggregateIdentifier</code>
                    annotation can be placed on a
                    field or a method. The latter case will use the return value of a method
                    invocation (without parameters) as the value to use.
                </para>
                <para>If you prefer not to use annotations, the behavior can be overridden by
                    supplying a custom <code>CommandTargetResolver</code>. This class should return
                    the Aggregate Identifier and expected version (if any) based on a given command. </para>
                <para>
                    <note>
                        <title>Creating new Aggregate Instances</title>
                        <para>When the
                            <code>@CommandHandler</code>
                            annotation is placed on an
                            Aggregate's constructor, the respective command will create a new
                            instance of that aggregte and add it to the repository. Those commands
                            do not require to target a specific aggregate instance. That wouldn't
                            make sense, since the instance is yet to be created. Therefore, those
                            commands do not require any
                            <code>@TargetAggregateIdentifier</code>
                            or
                            <code>@TargetAggregateVersion</code>
                            annotations, nor will a custom
                            <code>CommandTargetResolver</code>
                            be invoked for these
                            commands.
                        </para>
                    </note>
                </para>
                <programlisting language="java">public class MyAggregate extends AbstractAnnotatedAggregateRoot {
   
    @AggregateIdentifier
    private String id;

    @CommandHandler
    public MyAggregate(CreateMyAggregateCommand command) {
        apply(new MyAggregateCreatedEvent(IdentifierFactory.getInstance().generateIdentifier()));
    }

    // no-arg constructor for Axon
    MyAggregate() {
    }

    @CommandHandler
    public void doSomething(DoSomethingCommand command) {
        // do something...
    }

    // code omitted for brevity. The event handler for MyAggregateCreatedEvent must set the id field
}

public class DoSomethingCommand {

    @TargetAggregateIdentifier
    private String aggregateId;

    // code omitted for brevity

}

// to generate the command handlers for this aggregate:
AggregateAnnotationCommandHandler handler = AggregateAnnotationCommandHandler.subscribe(MyAggregate.class, repository, commandBus);
// or when using another type of CommandTargetResolver:
AggregateAnnotationCommandHandler handler = AggregateAnnotationCommandHandler.subscribe(MyAggregate.class, repository, commandBus, myOwnCommandTargetResolver);

// to unsubscribe:
handler.unsubscribe();</programlisting>
            </simplesect>
        </sect2>
    </sect1>
    <sect1 xml:id="unit-of-work">
        <title>Unit of Work</title>
        <para>The Unit of Work is an important concept in the Axon Framework. The processing of a
            command can be seen as a single unit. Each time a command handler performs an action, it
            is tracked in the current Unit of Work. When command handling is finished, the Unit of
            Work is committed and all actions are finalized. This means that any repositores are
            notified of state changes in their aggregates and events scheduled for publication are
            sent to the Event Bus. </para>
        <para>The Unit of Work serves two purposes. First, it makes the interface towards
            repositories a lot easier, since you do not have to explicitly save your changes.
            Secondly, it is an important hook-point for interceptors to find out what a command
            handler has done.
        </para>
        <para>In most cases, you are unlikely to need access to the Unit of Work. It is mainly used
            by the building blocks that Axon provides. If you do need access to it, for whatever
            reason, there are a few ways to obtain it. The Command Handler receives the Unit Of Work
            through a parameter in the handle method. If you use annotation support, you may add a
            parameter of type <code>UnitOfWork</code> to your annotated method. In other locations,
            you can retrieve the Unit of Work bound to the current thread by calling
                <code>CurrentUnitOfWork.get()</code>. Note that this method will throw an exception
            if there is no Unit of Work bound to the current thread. Use
                <code>CurrentUnitOfWork.isStarted()</code> to find out if one is available. </para>
        <para>One reason to require access to the current Unit of Work is to dispatch Events as part
            of a transaction, but those Events do not originate from an Aggregate. For example, you
            might want to publish an Event from a Command Handler, but don't require that Event to
            be stored as state in an Event Store. In such case, you can call
                <code>CurrentUnitOfWork.get().publishEvent(event, eventBus)</code>, where
                <code>event</code> is the Event (Message) to publish and <code>EventBus</code> the
            Bus to publish it on. The actual publication of the message is postponed unit the Unit
            of Work is committed, respecting the order in which Events have been registered.</para>
        <note>
            <para>Note that the Unit of Work is merely a buffer of changes, not a replacement for
                Transactions. Although all staged changes are only committed when the Unit of Work
                is committed, its commit is not atomic. That means that when a commit fails, some
                changes might have been persisted, while other are not. Best practices dictate that
                a Command should never contain more than one action. If you stick to that practice,
                a Unit of Work will contain a single action, making it safe to use as-is. If you
                have more actions in your Unit of Work, then you could consider attaching a
                transaction to the Unit of Work's commit. See <xref linkend="binding-uow-to-tx"/>. </para>
        </note>
        <simplesect>
            <title>UnitOfWork and Exceptions</title>
            <para>Your command handlers may throw an Exception as a result of command processing. By
                default, unchecked exceptions will cause the UnitOfWork to roll back all changes. As
                a result, no Events are stored or published. In some cases, however, you might want
                to commit the Unif of Work and still notify the dispatcher of the command of an
                exception through the callback. The <code>SimpleCommandBus</code> allows you to
                provide a <code>RollbackConfiguration</code>. The <code>RollbackConfiguration</code>
                instance indicates whether an exception should perform a rollback on the Unit of
                Work, or a commit. Axon provides two implementation, which should cover most of the
                cases. </para>
            <para>The <code>RollbackOnAllExceptionsConfiguration</code> will cause a rollback on any
                exception (or error). The default configuration, the
                    <code>RollbackOnUncheckedExceptionConfiguration</code>, will commit the Unit of
                Work on checked exceptions (those not extending <code>RuntimeException</code>) while
                still performing a rollback on Errors and Runtime Exceptions. </para>
        </simplesect>
        <simplesect>
            <title>Programatically managing a Unit of Work</title>
            <para>When using a Command Bus, the lifeycle of the Unit of Work will be automatically
                managed for you. If you choose not to use explicit command objects and a Command
                Bus, but a Service Layer instead, you will need to programatically start and commit
                (or roll back) a Unit of Work instead. </para>
            <para>In most cases, the DefaultUnitOfWork will provide you with the functionality you
                need. It expects Command processing to happen within a single thread. To start a new
                Unit Of Work, simply call <code>DefaultUnitOfWork.startAndGet();</code>. This will
                start a Unit of Work, bind it to the current thread (making it accessible via
                    <code>CurrentUnitOfWork.get()</code>), and return it. When processing is done,
                either invoke <code>unitOfWork.commit();</code> or
                    <code>unitOfWork.rollback(optionalException)</code>. </para>
            <para>Typical usage is as follows:
                <programlisting language="java">UnitOfWork uow = DefaultUnitOfWork.startAndGet();
try {
    // business logic comes here
    uow.commit();
} catch (Exception e) {
    uow.rollback(e);
    // maybe rethrow...
}</programlisting></para>
        </simplesect>
        <simplesect>
            <title>Unit of Work phases</title>
            <para>A Unit of Work knows several phases. Each time it progresses to another phase, the
                UnitOfWork Listeners are notified.</para>
            <itemizedlist>
                <listitem>
                    <para>Active phase: this is where the Unit of Work starts. Each time an event is
                        registered with the Unit of Work, the <code>onEventRegistered</code> method
                        is called. This method may alter the event message, for example to attach
                        meta data to it. The return value of the method is the new EventMessage
                        instance to use.</para>
                </listitem>
                <listitem>
                    <para>Commit phase: before a Unit of Work is committed, the listeners'
                            <code>onPrepareCommit</code> methods are invoked. This method is
                        provided with the set of aggregates and list of Event Messages being stored.
                        If a Unit of Work is bound to a transaction, the
                            <code>onPrepareTransactionCommit</code> method is invoked. When the
                        commit succeeded, the <code>afterCommit</code> method is invoked. If a
                        commit failed, the <code>onRollback</code> is used. This method has a
                        parameter which defines the cause of the failure, if available.</para>
                </listitem>
                <listitem>
                    <para>Cleanup phase: This is the phase where any of the resources held by this
                        Unit of Work (such as locks) are to be released. If multiple Units Of Work
                        are nested, the cleanup phase is postponed until the outer unit of work is
                        ready to clean up.</para>
                </listitem>
            </itemizedlist>
        </simplesect>
        <simplesect xml:id="binding-uow-to-tx">
            <title>Binding the Unit of Work to a Transaction</title>
            <para>The command handling process can be considered an atomic procedure; it should
                either be processed entirely, or not at all. Axon Framework uses the Unit Of Work to
                track actions performed by the command handlers. After the command handler
                completed, Axon will try to commit the actions registered with the Unit Of Work.
                This involves storing modified aggregates (see <xref linkend="domain-modeling"/>) in
                their respective repository (see <xref linkend="repositories-and-event-stores"/>)
                and publishing events on the Event Bus (see <xref linkend="event-processing"/>). </para>
            <para>The Unit Of Work, however, it is not a replacement for a transaction. The Unit Of
                Work only ensures that changes made to aggregates are stored upon successful
                execution of a command handler. If an error occurs while storing an aggregate, any
                aggregates already stored are not rolled back. </para>
            <para>It is posssible to bind a transaction to a Unit of Work. Many CommandBus
                implementations, like the SimpleCommandBus and DisruptorCommandBus, allow you to
                configure a Transaction Manager. This Transaction Manager will then be used to
                create the transactions to bind to the Unit of Work that is used to manage the
                process of a Command. When a Unit of Work is bound to a transaction, it will ensure
                the bound transaction is committed at the right point in time. It also allows you to
                perform actions just before the transaction is committed, through the
                    <code>UnitOfWorkListener</code>'s <code>onPrepareTransactionCommit</code>
                method.</para>
            <para>When creating Unit of Work programmatically, you can use the
                    <code>DefaultUnitOfWork.startAndGet(TransactionManager)</code> method to create
                a Unit of Work that is bound to a transaction. Alternatively, you can initialize the
                    <code>DefaultUnitOfWorkFactory</code> with a <code>TransactionManager</code> to
                allow it to create Transaction-bound Unit of Work.</para>
        </simplesect>
    </sect1>
    <sect1 xml:id="command-handler-interceptors">
        <title>Command Interceptors</title>
        <para>One of the advantages of using a command bus is the ability to undertake action based
            on all incoming commands. Examples are logging or authentication, which you might want
            to do regardless of the type of command. This is done using Interceptors. </para>
        <para>There are two types of interceptors: Command Dispatch Interceptors and Command Handler
            Interceptors. The former are invoked before a command is dispatched to a Command
            Handler. At that point, it may not even be sure that any handler exists for that
            command. The latter are invoked just before the Command Handler is invoked.</para>
        <sect2>
            <title>Command Dispatch Interceptors</title>
            <para>Command Dispatch Interceptors are invoked when a command is dispatched on a
                Command Bus. They have the ability to alter the Command Message, by adding Meta
                Data, for example, or block the command by throwing an Exception. These interceptors
                are always invoked on the thread that dispatches the Command.</para>
            <sect3>
                <title>Structural validation</title>
                <para>There is no point in processing a command if it does not contain all required
                    information in the correct format. In fact, a command that lacks information
                    should be blocked as early as possible, preferably even before any transaction
                    is started. Therefore, an interceptor should check all incoming commands for the
                    availability of such information. This is called structural validation. </para>
                <para>Axon Framework has support for JSR 303 Bean Validation based validation. This
                    allows you to annotate the fields on commands with annotations like
                        <code>@NotEmpty</code> and <code>@Pattern</code>. You need to include a JSR
                    303 implementation (such as Hibernate-Validator) on your classpath. Then,
                    configure a <code>BeanValidationInterceptor</code> on your Command Bus, and it
                    will automatically find and configure your validator implementation. While it
                    uses sensible defaults, you can fine-tune it to your specific needs. <tip>
                        <para>You want to spend as less resources on an invalid command as possible.
                            Therefore, this interceptor is generally placed in the very front of the
                            interceptor chain. In some cases, a Logging or Auditing interceptor
                            might need to be placed in front, with the validating interceptor
                            immediately following it. </para>
                    </tip></para>
                <para>The BeanValidationInterceptor also implements
                        <code>CommandHandlerInterceptor</code>, allowing you to configure it as a
                    Handler Interceptor as well.</para>
            </sect3>
        </sect2>
        <sect2>
            <title>Command Handler Interceptors</title>
            <para>Command Handler Interceptors can take action both before and after command
                processing. Interceptors can even block command processing altogether, for example
                for security reasons. </para>
            <para>Interceptors must implement the <code>CommandHandlerInterceptor</code> interface.
                This interface declares one method, <code>handle</code>, that takes three
                parameters: the command message, the current <code>UnitOfWork</code> and an
                    <code>InterceptorChain</code>. The <code>InterceptorChain</code> is used to
                continue the dispatching process. </para>
            <sect3 xml:id="auditing-interceptor">
                <title>Auditing</title>
                <para>Well designed events will give clear insight in what has happened, when and
                    why. To use the event store as an Audit Trail, which provides insight in the
                    exact history of changes in the system, this information might not be enough. In
                    some cases, you might want to know which user caused the change, using what
                    command, from which machine, etc. </para>
                <para>The <code>AuditingInterceptor</code> is an interceptor that allows you to
                    attach arbitrary information to events just before they are stored or published.
                    The <code>AuditingInterceptor</code> uses an <code>AuditingDataProvider</code>
                    to retrieve the information to attach to these events. You need to provide the
                    implementation of the <code>AuditingDataProvider</code> yourself. </para>
                <para>An Audit Logger may be configured to write to an audit log. To do so, you can
                    implement the <code>AuditLogger</code> interface and configure it in the
                        <code>AuditingInterceptor</code>. The audit logger is notified both on
                    succesful execution of the command, as well as when execution fails. If you use
                    event sourcing, you should be aware that the event log already contains the
                    exact details of each event. In that case, it could suffice to just log the
                    event identifier or aggregate identifier and sequence number combination. </para>
                <note>
                    <para>Note that the log method is called in the same thread as the command
                        processing. This means that logging to slow sources may result in higher
                        response times for the client. When important, make sure logging is done
                        asynchronously from the command handling thread. </para>
                </note>
            </sect3>
        </sect2>
    </sect1>
    <sect1>
        <title>Distributing the Command Bus</title>
        <para>The CommandBus implementations described in <xref
                xmlns:xlink="http://www.w3.org/1999/xlink" linkend="command-bus"/> only allow
            Command Messages to be dispatched within a single JVM. Sometimes, you want multiple
            instances of Command Buses in different JVM's to act as one. Commands dispatched on one
            JVM's Command Bus should be seamlessly transported to a Command Handler in another JVM
            while sending back any results.</para>
        <para>That's where the <code>DistributedCommandBus</code> comes in. Unlike the other
                <code>CommandBus</code> implementations, the <code>DistributedCommandBus</code> does
            not invoke any handlers at all. All it does is form a "bridge" between Command Bus
            implementations on different JVM's. Each instance of the
                <code>DistributedCommandBus</code> on each JVM is called a "Segment".</para>
        <figure>
            <title>Structure of the Distributed Command Bus</title>
            <mediaobject>
                <imageobject role="fo">
                    <imagedata align="center" format="svg"
                        fileref="distributed-command-bus.svg" width="10cm"/>
                </imageobject>
                <imageobject role="html">
                    <imagedata format="png" fileref="distributed-command-bus.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>
            <note>
                <title>Dependencies</title>
                <para>The distributed command bus is not part of the Axon Framework Core module, but
                    in the <emphasis>axon-distributed-commandbus</emphasis> module. If you use
                    Maven, make sure you have the appropriate dependencies set. The groupId and
                    version are identical to those of the Core module. </para>
            </note>
        </para>
        <para>The <code>DistributedCommandBus</code> relies on two components: a
                <code>CommandBusConnector</code>, which implements the communication protocol
            between the JVM's, and the <code>RoutingStrategy</code>, which provides a Routing Key
            for each incoming Command. This Routing Key defines which segment of the Distributed
            Command Bus should be given a Command. Two commands with the same routing key will
            always be routed to the same segment, as long as there is no change in the number and
            configuration of the segments. Generally, the identifier of the targeted aggregate is
            used as a routing key.</para>
        <para>Two implementations of the RoutingStrategy are provided: the
                <code>MetaDataRoutingStrategy</code>, which uses a Meta Data property in the Command
            Message to find the routing key, and the <code>AnnotationRoutingStrategy</code>, which
            uses the <code>@TargetAggregateIdentifier</code> annotation on the Command Messages
            payload to extract the Routing Key. Obviously, you can also provide your own
            implementation.</para>
        <para>By default, the RoutingStrategy implementations will throw an exception when no key
            can be resolved from a Command Message. This behavior can be altered by providing a
            UnresolvedRoutingKeyPolicy in the constructor of the MetaDataRoutingStrategy or
            AnnotationRoutingStrategy. There are three possible policies:<itemizedlist>
                <listitem>
                    <para>ERROR: This is the default, and will cause an exception to be thrown when
                        a Routing Key is not available</para>
                </listitem>
                <listitem>
                    <para>RANDOM_KEY: Will return a random value when a Routing Key cannot be
                        resolved from the Command Message. This effectively means that those
                        commands will be routed to a random segment of the Command Bus.</para>
                </listitem>
                <listitem>
                    <para>STATIC_KEY: Will return a static key (being "unresolved") for unresolved
                        Routing Keys. This effectively means that all those commands will be routed
                        to the same segment, as long as the configuration of segments does not
                        change.</para>
                </listitem>
            </itemizedlist></para>
        <sect2>
            <title>JGroupsConnector</title>
            <para>The <code>JGroupsConnector</code> uses (as the name already gives away) JGroups as
                the underlying discovery and dispatching mechanism. Describing the feature set of
                JGroups is a bit too much for this reference guide, so please refer to the <link
                    xmlns:ns1="http://www.w3.org/1999/xlink"
                    ns1:href="http://www.jgroups.org/ug.html">JGroups User Guide</link> for more
                details.</para>
            <para>The JGroupsConnector has four mandatory configuration elements: <itemizedlist>
                    <listitem>
                        <para>The first is a JChannel, which defines the JGroups protocol stack.
                            Generally, a JChannel is constructed with a reference to a JGroups
                            configuration file. JGroups comes with a number of default confgurations
                            which can be used as a basis for your own configuration. Do keep in mind
                            that IP Multicast generally doesn't work in Cloud Services, like Amazon.
                            TCP Gossip is generally a good start in such type of environment.</para>
                    </listitem>
                    <listitem>
                        <para>The Cluster Name defines the name of the Cluster that each segment
                            should register to. Segments with the same Cluster Name will eventually
                            detect eachother and dispatch Command among eachother.</para>
                    </listitem>
                    <listitem>
                        <para>A "local segment" is the Command Bus implementation that dispatches
                            Commands destined for the local JVM. These commands may have been
                            dispatched by instances on other JVM's or from the local one.</para>
                    </listitem>
                    <listitem>
                        <para>Finally, the Serializer is used to serialize command messages before
                            they are sent over the wire.</para>
                    </listitem>
                </itemizedlist></para>
            <para>Ultimately, the JGroupsConnector needs to actually connect, in order to dispatch
                Messages to other segments. To do so, call the <code>connect()</code> method. It
                takes a single parameter: the load factor. The load factor defines how much load,
                relative to the other segments this segment should receive. A segment with twice the
                load factor of another segment will be assigned (approximately) twice the amount of
                routing keys as the other segments. Note that when commands are unevenly distributed
                over the rouing keys, segments with lower load factors could still receive more
                command than a segment with a higher load factor.</para>
            <programlisting language="java">JChannel channel = new JChannel("path/to/channel/config.xml");
CommandBus localSegment = new SimpleCommandBus();
Serializer serializer = new XStreamSerializer();

JGroupsConnector connector = new JGroupsConnector(channel, "myCommandBus", localSegment, serializer);
DistributedCommandBus commandBus = new DistributedCommandBus(connector);

// on one node:
connector.connect(50);
commandBus.subscribe(CommandType.class.getName(), handler);

// on another node with more CPU:
connector.connect(150);
commandBus.subscribe(CommandType.class.getName(), handler);
commandBus.subscribe(AnotherCommandType.class.getName(), handler2);

// from now on, just deal with commandBus as if it is local...</programlisting>
            <note>
                <para>Note that it is not required that all segments have Command Handlers for the
                    same type of Comands. You may use different segments for different Command Types
                    altogether. The Distributed Command Bus will always choose a node to dispatch a
                    Command to that has support for that specific type of Command.</para>
            </note>
            <simplesect>
                <title>The <code>JGroupsConnector</code> and Spring Framework</title>
                <para>If you use Spring, you may want to consider using the
                        <code>JGroupsConnectorFactoryBean</code>. It automatically connects the
                    Connector when the ApplicationContext is started, and does a proper disconnect
                    when the <code>ApplicationContext</code> is shut down. Furthermore, it uses
                    sensible defaults for a testing environment (but should not be considered
                    production ready) and autowiring for the configuration.</para>
            </simplesect>
        </sect2>
    </sect1>
</chapter>
