= Command Dispatchers
:navtitle: Dispatching

The xref:command-handlers.adoc[Command Handlers] pages provide the background on how to handle command messages in your application.
The dispatching process is the starting point of such a command message.
Axon provides three interfaces you can use to send commands to your command handlers: the <<command-bus,CommandBus>>, the <<command-gateway,CommandGateway>>, and the <<command-dispatcher,CommandDispatcher>>.

This page will show how and when to use the command gateway and bus.
How to configure and specifics on the command gateway and bus implementations are discussed in the xref:infrastructure.adoc[infrastructure section].

[[command-bus]]
== The `CommandBus`

The `CommandBus` is the mechanism that dispatches commands to their respective command handlers.
As such, it is the infrastructure component that is aware of which component can handle which command.

Each command is always sent to exactly one command handler.
If no command handler is available for the dispatched command, a `NoHandlerForCommandException` exception is thrown.

The `CommandBus` dispatches commands using the `dispatch(CommandMessage, ProcessingContext)` method, which returns a `CompletableFuture`:

[source,java]
----
private CommandBus commandBus; // <1>

public void dispatchCommands() {
    String cardId = UUID.randomUUID().toString(); // <2>

    // <3>
    IssueCardCommand command = new IssueCardCommand(cardId, 100, "shopId");
    CommandMessage<IssueCardCommand> commandMessage = new GenericCommandMessage<>(
        MessageType.of("IssueCardCommand", "1.0"),
        command
    );

    // <4>
    CompletableFuture<CommandResultMessage<?>> result =
        commandBus.dispatch(commandMessage, ProcessingContext.empty());

    // <5>
    result.thenAccept(cmdResultMsg -> {
        if (cmdResultMsg.isExceptional()) {
            Throwable throwable = cmdResultMsg.exceptionResult();
            // Handle exception
        } else {
            Object commandResult = cmdResultMsg.payload();
            // Handle successful result
        }
    });
}
// omitted class and constructor

----

The example above exemplifies important aspects of dispatching commands:

<1> The `CommandBus` interface providing the functionality to dispatch command messages.

<2> The aggregate identifier is, per best practice, initialized as the String of a random unique identifier.
Typed identifier objects are also possible, as long as the object implements a sensible `toString()` function.

<3> To dispatch a command on the `CommandBus`, you must wrap your command object in a `CommandMessage` with a `MessageType`.
The `CommandMessage` also allows the addition of xref:messaging-concepts:anatomy-message.adoc#meta-data[Metadata] to the Command Message.

<4> The `CommandBus#dispatch(CommandMessage, ProcessingContext)` method dispatches the command and returns a `CompletableFuture<CommandResultMessage<?>>`.
The `ProcessingContext` parameter allows you to pass along the current processing context when dispatching from within another message handler.
Use `ProcessingContext.empty()` when dispatching from outside a message handling context (e.g., from a REST endpoint).

<5> Use the `CompletableFuture` API to handle command results asynchronously.
The `CommandResultMessage` provides the API to verify whether command execution was exceptional or successful.

[NOTE]
.Asynchronous command dispatching
====
The `CommandBus#dispatch` method is asynchronous and returns a `CompletableFuture`.
The calling component should not assume that command handling is completed before the `dispatch` method returns.
Use the returned `CompletableFuture` to handle results or chain follow-up operations.
====

[#command-gateway]
== The `CommandGateway`

The 'Command Gateway' is a convenience approach towards dispatching commands.
It does so by abstracting certain aspects for you when dispatching a command on the `CommandBus`.
It this uses the `CommandBus` underneath to perform the actual dispatching of the message. +
While you are not required to use a gateway to dispatch commands, it is generally the easiest option to do so.

The `CommandGateway` provides convenient methods for dispatching commands with automatic result conversion.
The interface provides both asynchronous (`send`) and synchronous (`sendAndWait`) approaches:

[source,java]
----
private CommandGateway commandGateway; // <1>

public void sendCommand() {
    String cardId = UUID.randomUUID().toString(); // <2>

    // <3>
    CompletableFuture<String> futureResult =
        commandGateway.send(new IssueCardCommand(cardId, 100, "shopId"), String.class);

    // <4>
    CommandResult commandResult = commandGateway.send(new IssueCardCommand(cardId, 100, "shopId"));
}
// omitted class, constructor and result usage
----

The `send` API shown above introduces a couple of concepts:

<1> The `CommandGateway` interface providing the functionality to dispatch command messages.
It internally leverages the `CommandBus` interface to <<command-bus,dispatch messages>>.

<2> The aggregate identifier is, per best practice, initialized as the String of a random unique identifier.
Typed identifier objects are also possible, as long as the object implements a sensible `toString()` function.

<3> The `send(Object, Class)` method requires the command object and the expected result type.
The `CommandGateway` will automatically convert the command result to the specified type.
The response is a `CompletableFuture`, allowing for chaining of follow-up operations.

<4> If you don't need result conversion, you can use `send(Object)` which returns a `CommandResult`.
The `CommandResult` provides access to the raw command result message.

A synchronous approach to sending commands can be achieved using the `sendAndWait` method:

[source,java]
----
private CommandGateway commandGateway;

public void sendCommandAndWaitOnResult() {
    IssueCardCommand commandPayload = new IssueCardCommand(UUID.randomUUID().toString(), 100, "shopId");
    // <1>
    String result = commandGateway.sendAndWait(commandPayload, String.class);
}
// omitted class, constructor and result usage
----

<1> The `CommandGateway#sendAndWait(Object, Class)` method takes the command object and the expected result type.
It will block until the command dispatching and handling process has been resolved.
The result is automatically converted to the specified type.

[#command-dispatcher]
== The `CommandDispatcher`

The `CommandDispatcher` is the recommended way to dispatch commands from within another message handling function.
It is a `ProcessingContext`-aware command dispatcher that automatically passes the active context when dispatching commands.

[source,java]
----
@EventHandler
public void on(MoneyTransferredEvent event, CommandDispatcher commandDispatcher) {
    // Validation logic...

    // <1>
    commandDispatcher.send(new IncreaseBalanceCommand(event.getTargetAccountId(), event.getAmount()));
}
----

<1> The `CommandDispatcher` automatically passes the active `ProcessingContext` to the command.
This ensures that correlation data (important for distributed tracing) is preserved from one message to another.

The `CommandDispatcher` uses a `CommandGateway` internally but removes the need to explicitly pass the `ProcessingContext`:

* *Use `CommandBus`* - When you need the lowest-level control over command dispatching
* *Use `CommandGateway`* - When dispatching commands from outside a message handling context (e.g., REST endpoints)
* *Use `CommandDispatcher`* - When dispatching commands from within message handlers (event handlers, command handlers, saga handlers)

[NOTE]
.CommandDispatcher availability
====
The `CommandDispatcher` is only available within an active `ProcessingContext`.
It cannot be used from REST endpoints or other locations where message processing is not active.
For those scenarios, use the `CommandGateway` instead.
====

== Command dispatching results

Dispatching commands will, generally speaking, have two possible outcomes:

. Command handled successfully, and
. command handled exceptionally

The outcome to some extent depends on the dispatching process, but more so on the implementation of the command handler.
Thus, if the `@CommandHandler` annotated function throws an exception due to some business logic, it will be that exception which will be the result of dispatching the command.

The successful resolution of command handling intentionally _should not_ provide any return objects.
Thus, if the `CommandBus`/`CommandGateway` provides a response (either directly or through the `CommandResultMessage)`, then you should assume the result of successful command handling to return `null`.

While it is possible to return results from command handlers, this should be used sparsely.
The intent of the Command should never be to retrieve a value, as that would be an indication that the message should be designed as a xref:queries:index.adoc[Query Message].
Exceptions to this would be the identifier of the Aggregate Root, or identifiers of entities the Aggregate Root has instantiated.
The framework has one such exception build in, on the `@CommandHandler` annotated constructor of an Aggregate.
In case the 'command handling constructor' has executed successfully, instead of the Aggregate itself, the value of the `@AggregateIdentifier` annotated field will be returned.

site:https://youtu.be/lxonQnu1txQ[Axon Coding Tutorial #5: - Connecting the UI]