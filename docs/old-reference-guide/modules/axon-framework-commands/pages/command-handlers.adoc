= Command Handlers
:navtitle: Handling

== Entity command handlers

Although Command Handlers can be placed in regular components, it is recommended to define the Command Handlers directly on the Entity that contains the state to process this command.

[NOTE]
====
In Axon Framework 5, the concept of "aggregates" has been replaced with "entities" to reflect the more flexible boundaries enabled by Dynamic Consistency Boundary (DCB).
The terminology has changed throughout the framework, but the core concepts remain similar.
====

To define a Command Handler in an Entity, simply annotate the method which should handle the command with `@CommandHandler`.
The `@CommandHandler` annotated method will become a Command Handler for Command Messages where the _command name_ matches fully qualified class name of the first parameter of that method.
Thus, a method signature of `void handle(RedeemCardCommand cmd, EventAppender appender)` annotated with `@CommandHandler`, will be the Command Handler of the `RedeemCardCommand` Command Messages.

Command Messages can also be xref:command-dispatchers.adoc[dispatched] with different _command names_.
To be able to handle those correctly, the `String commandName` value can be specified in the `@CommandHandler` annotation.

[NOTE]
.Routing in a distributed environment
====
Regardless of the type of command, as soon as you start distributing your application (through Axon Server, for example), it is recommended to specify a routing key on the command.
This can be done using the `@RoutingKey` annotation on the command field that should be used for routing.

If this annotation doesn't work for your use case, a different `RoutingStrategy` can be configured, as is explained in the xref:infrastructure.adoc#routing-strategy[Routing Strategy] section.
====

=== Creational vs instance command handlers

Axon Framework 5 distinguishes between two types of command handlers:

1. **Creational Command Handlers** - Static methods that create new entity instances
2. **Instance Command Handlers** - Instance methods that operate on existing entities

Taking the `GiftCard` entity as an example, we can identify both types of Command Handlers:

[source,java]
----
import org.axonframework.messaging.commandhandling.CommandHandler;
import org.axonframework.messaging.eventhandling.gateway.EventAppender;
import org.axonframework.eventsourcing.annotation.reflection.EntityCreator;
import org.axonframework.eventsourcing.annotation.EventSourcingHandler;

public class GiftCard {

    private final String id;
    private int remainingValue;

    // Constructor that receives the first event
    @EntityCreator
    public GiftCard(CardIssuedEvent event) {
        this.id = event.cardId();
        this.remainingValue = event.amount();
    }

    // Creational command handler (static method)
    @CommandHandler
    public static String handle(IssueCardCommand cmd, EventAppender appender) {
        if (cmd.amount() <= 0) {
            throw new IllegalArgumentException("amount must be positive");
        }
        appender.append(new CardIssuedEvent(cmd.cardId(), cmd.amount()));
        return cmd.cardId();
    }

    // Instance command handler
    @CommandHandler
    public void handle(RedeemCardCommand cmd, EventAppender appender) {
        if (cmd.amount() <= 0) {
            throw new IllegalArgumentException("amount <= 0");
        }
        if (cmd.amount() > remainingValue) {
            throw new IllegalStateException("amount > remaining value");
        }
        appender.append(new CardRedeemedEvent(id, cmd.transactionId(), cmd.amount()));
    }

    // Event sourcing handler to update state
    @EventSourcingHandler
    public void on(CardRedeemedEvent event) {
        this.remainingValue -= event.amount();
    }
}

----

The Command objects, `IssueCardCommand` and `RedeemCardCommand`, which `GiftCard` handles can be defined as simple records (Java 16+) or traditional classes:

[source,java]
----
// Using Java records (Java 16+)
public record IssueCardCommand(
    String cardId,
    int amount
) {}

public record RedeemCardCommand(
    String cardId,
    String transactionId,
    int amount
) {}

// Or using traditional classes
public class IssueCardCommand {

    private final String cardId;
    private final int amount;

    public IssueCardCommand(String cardId, int amount) {
        this.cardId = cardId;
        this.amount = amount;
    }

    public String cardId() { return cardId; }
    public int amount() { return amount; }
}
----

[NOTE]
====
The `cardId` present in both commands is the identifier that will be used to route the command to the correct entity instance.
For command routing in distributed environments, use the `@RoutingKey` annotation on the field that should be used for routing.
====

If you prefer to use another mechanism for routing commands, the behavior can be overridden by supplying a custom `CommandTargetResolver`.
This class should return the entity identifier based on a given command.

[TIP]
.Entity Creation Command Handlers
====
Creational command handlers are **static methods** on the entity class that create new entity instances.
These commands will invoke the static `@CommandHandler` method, which is responsible for publishing the first event.
The entity is then constructed using a constructor annotated with `@EntityCreator` that receives the first event.

This approach allows for final/immutable fields and better null-safety guarantees.
====

=== Business logic and state changes

Within an Entity there is a specific location to perform business logic validation and Entity state changes.
The Command Handlers should _decide_ whether the Entity is in the correct state.
If yes, an Event is published using the `EventAppender`.
If not, the Command might be ignored or an exception could be thrown, depending on the needs of the domain.

State changes should *not* occur in _any_ Command Handling function.
The Event Sourcing Handlers (methods annotated with `@EventSourcingHandler`) should be the only methods where the Entity's state is updated.
Failing to do so means the Entity would miss state changes when it is being sourced from its events.

The xref:testing:commands-events.adoc[Test Fixture] will guard against unintentional state changes in Command Handling functions.
It is thus advised to provide thorough test cases for _any_ Entity implementation.

[TIP]
.Only handle the necessary events
====
The only state an Entity requires is the state it needs to make a decision.
Handling an Event published by the Entity is thus only required if the state change is necessary for future validation of other commands.
====

=== Publishing events with `EventAppender`

In Axon Framework 5, events are published using the `EventAppender` parameter that can be injected into command handlers:

[source,java]
----
@CommandHandler
public void handle(UpdateCardCommand cmd, EventAppender appender) {
    // Validate business rules
    if (cmd.newAmount() > maximumAllowed) {
        throw new IllegalArgumentException("Amount exceeds maximum");
    }

    // Publish event
    appender.append(new CardUpdatedEvent(id, cmd.newAmount()));
}
----

The `EventAppender` provides a clean API for publishing events without relying on static methods or thread-local storage.

=== Entity member relationships

In some cases, especially when the entity structure grows beyond a single entity, it is useful to compose entities with child entities.
Child entities can handle commands and events just like root entities (multi-entity structures are explained in more detail xref:modeling/multi-entity-command-models.adoc[here]).

Child entities are annotated with `@EntityMember`:

[source,java]
----
import org.axonframework.modelling.entity.annotation.EntityMember;

public class Project {

    private final String projectId;

    @EntityMember
    private List<Developer> developers = new ArrayList<>();

    @EntityMember
    private List<Milestone> milestones = new ArrayList<>();

    // command handlers and event sourcing handlers
}
----

[NOTE]
.Event sourcing scope
====
An Entity processes events that belong to its consistency boundary.
With the introduction of Dynamic Consistency Boundary (DCB), this boundary can span multiple event streams.
Event sourcing handlers are used to recreate the state of the Entity from its events.
====

To make an Aggregate react to events from other Aggregate instances, xref:sagas:index.adoc[Sagas] or xref:events:event-handlers.adoc[Event Handling Components] should be leveraged
====

[#_aggregate_command_handler_creation_policy]
=== Aggregate command handler creation policy

Up until now, we have depicted the `GiftCard` aggregate with roughly two types of command handlers:

. `@CommandHandler` annotated constructors
. `@CommandHandler` annotated methods

Option 1 will always expect to be the instantiation of the `GiftCard` aggregate, whilst option 2 expects to be targeted towards an existing aggregate instance.
Although this may be the default, there is the option to define a _creation policy_ on a command handler.
This can be achieved by adding the `@CreationPolicy` annotation to a command handler annotated method, like so:

[source,java]
----
import org.axonframework.messaging.commandhandling.CommandHandler;
import org.axonframework.modelling.command.CreationPolicy;
import org.axonframework.modelling.command.AggregateCreationPolicy;

public class GiftCard {

    public GiftCard() {
        // Required no-op constructor
    }

    @CommandHandler
    @CreationPolicy(AggregateCreationPolicy.ALWAYS)
    public void handle(IssueCardCommand cmd) {
        // An `IssueCardCommand`-handler which will create a `GiftCard` aggregate
    }

    @CommandHandler
    @CreationPolicy(AggregateCreationPolicy.CREATE_IF_MISSING)
    public void handle(CreateOrRechargeCardCommand cmd) {
        // A 'CreateOrRechargeCardCommand'-handler which creates a `GiftCard` aggregate if it did not exist
        // Otherwise, it will update an existing `GiftCard` aggregate.
    }
    // omitted aggregate state, command handling logic and event sourcing handlers
}
----

As is shown above, the `@CreationPolicy` annotation requires stating the `AggregateCreationPolicy`.
This enumeration has the following options available:

* `ALWAYS`: Will expect to instantiate the aggregate.
This effectively works like a command handler annotated constructor.
Without defining a return type, the aggregate identifier used during the creation will be returned.
Through this approach, it is possible to return other results next to the aggregate identifier.

* `CREATE_IF_MISSING`: Can either create an aggregate or act on an existing instance.
This policy should be regarded as an upsert approach of an aggregate.

* `NEVER`: Will be handled on an existing aggregate instance.
This effectively works like any regular command handler annotated method.

[[external_command_handlers]]
== External command handlers

Command handling functions are most often directly placed on the Aggregate (as described in more detail <<Aggregate command handlers,here>>).
There are situations, however, where it is not possible nor desired to route a command directly to an Aggregate instance.
Message handling functions, like Command Handlers, can, however, be placed on any object.
It is thus possible to instantiate a 'Command Handling Object'.

A Command Handling Object is a simple (regular) object, which has `@CommandHandler` annotated methods.
Unlike with Aggregates, there is only a _single_ instance of a Command Handling Object, which handles *all* commands of the types it declares in its methods:

[source,java]
----
import org.axonframework.messaging.commandhandling.CommandHandler;
import org.axonframework.modelling.repository.Repository;

public class GiftCardCommandHandler {
    private final Repository<GiftCard> giftCardRepository; // <1>

    @CommandHandler
    public void handle(RedeemCardCommand cmd) {
        giftCardRepository.load(cmd.getCardId()) // <2>
                          .execute(giftCard -> giftCard.handle(cmd)); // <3>
    }

    // omitted constructor
}
----

In the above snippet we have decided that the `RedeemCardCommand` should no longer be directly handled on the `GiftCard`.
Instead, we load the `GiftCard` manually and execute the desired method on it:

<1> The `Repository` for the `GiftCard` Aggregate, used for retrieval and storage of an Aggregate.
If `@CommandHandler` methods are placed directly on the Aggregate, Axon will automatically know to call the `Repository` to load a given instance.
It is thus _not_ mandatory to directly access the `Repository`, but a design choice.

<2> To load the intended `GiftCard` Aggregate instance, the `Repository#load(String)` method is used.
The provided parameter should be the Aggregate identifier.

<3> After that Aggregate has been loaded, the `Aggregate#execute(Consumer)` function should be invoked to perform an operation on the Aggregate.
Using the `execute` function ensure that the Aggregate life cycle is correctly started.