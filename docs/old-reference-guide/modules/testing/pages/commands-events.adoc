= Commands / Events

One of the benefits of CQRS, and especially that of event sourcing, is that it is possible to express tests purely in terms of events and commands. Both being functional components, events and commands have clear meaning to the domain expert or business owner. Not only does this mean that tests expressed in terms of events and commands have a clear functional meaning, it also means that they hardly depend on any implementation choices.

The features described in this chapter require the `axon-test` module, which can be obtained by configuring a maven dependency (use `&lt;artifactId&gt;axon-test&lt;/artifactId&gt;` and `&lt;scope&gt;test&lt;/scope&gt;`) or from the full package download.

The fixtures described in this chapter work with any testing framework, such as JUnit and TestNG.

== Command model testing

The command handling component is typically the component in any CQRS based architecture that contains the most complexity. Being more complex than the others, this also means that there are extra test related requirements for this component.

Although being more complex, the API of a command handling component is fairly easy. It has a command coming in, and events going out. In some cases, there might be a query as part of command execution. Other than that, commands and events are the only part of the API. This means that it is possible to completely define a test scenario in terms of events and commands. Typically, in the shape of:

* Given certain events in the past,
* When executing this command,
* Expect these events to be published and/or stored

Axon Framework provides a test fixture that allows you to do exactly that. The `AxonTestFixture` uses your `ApplicationConfigurer` to ensure your tests use the same configuration as your production application. This eliminates the risk of configuration mismatches between your tests and production code.

The following example shows the usage of the "given-when-then" test fixture with JUnit 5:

[source,java]
----
import org.axonframework.test.fixture.AxonTestFixture;
import org.axonframework.messaging.core.configuration.MessagingConfigurer;

public class GiftCardTest {

    private AxonTestFixture fixture;

    @BeforeEach
    public void setUp() {
        // Create your configurer with all necessary components
        MessagingConfigurer configurer = MessagingConfigurer.create()
            .configureAggregate(GiftCard.class)
            // Add other configuration as needed
            ;

        // Create the fixture from the configurer
        fixture = AxonTestFixture.with(configurer);
    }

    @Test
    public void testRedeemCardCommand() {
        fixture.given()
               .event(new CardIssuedEvent("cardId", 100))
               .when()
               .command(new RedeemCardCommand("cardId", "transactionId", 20))
               .then()
               .events(new CardRedeemedEvent("cardId", "transactionId", 20));
        /*
        These lines define the actual scenario and its expected result.

        The given() phase defines events that happened in the past.
        These events define the state of the system before testing.

        The when() phase defines the action being tested -
        in this case, dispatching a command.

        The then() phase validates the results.
        The events() method verifies the expected events were published.
        */
    }
}

----

[NOTE]
====
The `AggregateTestFixture` from Axon Framework 4 has been replaced by the `AxonTestFixture` in Axon Framework 5.
The new fixture is based on your `ApplicationConfigurer`, ensuring that your tests use the same configuration as your production application.
====

____

*Aggregate Lifecycle Extension*

Alternatively, JUnit 5 users can use `StubAggregateLifecycleExtension` in order to directly attach to the aggregate lifecycle.
This might be useful if you prefer not to use the `AggregateTestFixture`

[source,java]
----

public class AggregateTest {

@RegisterExtension
static StubAggregateLifecycleExtension testSubject = new StubAggregateLifecycleExtension();

   @Test
   void test() {
       apply(new Event(...));

       assertEquals(1, testSubject.getAppliedEvents().size());
   }  
 
}
----

____

The "given-when-then" test fixture defines three stages: configuration, execution and validation.

____

*Fluent Interface*

To make optimal use of the migration between these stages, it is best to use the fluent interface provided by these methods, as shown in the example above.

____

[[test-setup]]
=== Test setup

The `AxonTestFixture` is created from your `ApplicationConfigurer` using the static `with()` method. This means the fixture automatically includes all the configuration you've defined for your production application:

* Aggregates and their command handlers
* Event handlers and projections
* Sagas
* Command bus, event bus, and event store configurations
* Any custom components you've registered

This approach ensures that your tests accurately reflect your production configuration, eliminating the common issue of forgetting to configure something in your tests that exists in production.

[source,java]
----
import org.axonframework.test.fixture.AxonTestFixture;
import org.axonframework.messaging.core.configuration.MessagingConfigurer;

// Create your configurer with all necessary components
MessagingConfigurer configurer = MessagingConfigurer.create()
    .configureAggregate(GiftCard.class)
    .configureEventHandler(configuration -> new GiftCardProjection())
    // Add other configuration as needed
    ;

// Create the fixture from the configurer
AxonTestFixture fixture = AxonTestFixture.with(configurer);
----

=== Customizing the Fixture

You can customize the fixture behavior using the customization parameter:

[source,java]
----
AxonTestFixture fixture = AxonTestFixture.with(
    configurer,
    customization -> customization
        .disableAxonServer()  // Disable Axon Server for testing
        .registerFieldFilter(myFieldFilter)  // Custom field filter for comparisons
        .registerIgnoredField(MyClass.class, "timestamp")  // Ignore specific fields
);
----

[NOTE]
====
Since the `AxonTestFixture` uses your `ApplicationConfigurer`, the individual registration methods from the old `AggregateTestFixture` (like `registerAnnotatedCommandHandler`, `registerRepository`, etc.) are no longer needed. All components are automatically configured through your `ApplicationConfigurer`.
====

The following components from Axon Framework 4's `AggregateTestFixture` are now configured through your `ApplicationConfigurer` instead:

* Repositories, aggregate factories, and repository providers
* Command handlers (both aggregate-based and external)
* Message interceptors (dispatch and handler interceptors)
* Parameter resolvers and handler definitions
* Injectable resources
* Custom command target resolvers

All these components are configured through your `ApplicationConfigurer` and automatically available in the test fixture.

[[given-phase]]
=== Given phase

Once you have configured the fixture, you can start the given phase by calling `given()`.
The given phase allows you to set up the initial state of your test scenario.

The given phase provides several methods to define the initial state:

* **`noPriorActivity()`** - Explicitly indicates no prior events or commands
* **`event(Object payload)`** - Publishes a single event with the given payload
* **`event(Object payload, Metadata metadata)`** - Publishes a single event with metadata
* **`events(Object... events)`** - Publishes multiple events (processed in single Unit of Work)
* **`events(EventMessage... messages)`** - Publishes multiple event messages
* **`command(Object payload)`** - Dispatches a single command
* **`command(Object payload, Metadata metadata)`** - Dispatches a command with metadata
* **`commands(Object... commands)`** - Dispatches multiple commands (each in separate Unit of Work)
* **`commands(CommandMessage... messages)`** - Dispatches multiple command messages
* **`execute(Function<Configuration, ?>)`** - Executes custom setup logic
* **`executeAsync(Function<Configuration, CompletableFuture<?>>)`** - Executes async custom setup logic

Example usage:

[source,java]
----
fixture.given()
       .event(new CardIssuedEvent("cardId", 100))
       .event(new MoneyAddedEvent("cardId", 50))
       .when()
       .command(new RedeemCardCommand("cardId", "txn1", 75))
       .then()
       .events(new CardRedeemedEvent("cardId", "txn1", 75));
----

Or using multiple events at once:

[source,java]
----
fixture.given()
       .events(
           new CardIssuedEvent("cardId", 100),
           new MoneyAddedEvent("cardId", 50)
       )
       .when()
       .command(new RedeemCardCommand("cardId", "txn1", 75))
       .then()
       .events(new CardRedeemedEvent("cardId", "txn1", 75));
----

[NOTE]
====
When using `events()`, all events are processed within a single Unit of Work, meaning event handlers won't see changes from earlier events in the same batch.
When using `commands()`, each command is processed in its own Unit of Work, so later commands can see the effects of earlier commands.
====

[[test-execution-phase]]
=== Test execution phase

The execution phase, or "when phase," specifies the action being tested.
Access the when phase by calling `when()` on either the fixture directly or on the given phase.

The when phase provides methods to execute different types of actions:

* **`command(Object payload)`** - Dispatches a command with the given payload
* **`command(Object payload, Metadata metadata)`** - Dispatches a command with metadata
* **`command(CommandMessage message)`** - Dispatches a command message
* **`event(Object payload)`** - Publishes an event with the given payload
* **`event(Object payload, Metadata metadata)`** - Publishes an event with metadata
* **`event(EventMessage message)`** - Publishes an event message
* **`execute(Function<Configuration, ?>)`** - Executes custom test logic

Example of executing a command:

[source,java]
----
fixture.given()
       .event(new CardIssuedEvent("cardId", 100))
       .when()
       .command(new RedeemCardCommand("cardId", "transactionId", 20))
       .then()
       .events(new CardRedeemedEvent("cardId", "transactionId", 20));
----

Example with metadata:

[source,java]
----
fixture.given()
       .event(new CardIssuedEvent("cardId", 100))
       .when()
       .command(
           new RedeemCardCommand("cardId", "transactionId", 20),
           Metadata.with("userId", "user-123")
       )
       .then()
       .events(new CardRedeemedEvent("cardId", "transactionId", 20));
----

You can also skip the given phase if there's no prior state:

[source,java]
----
fixture.when()
       .command(new CreateCardCommand("cardId", 100))
       .then()
       .events(new CardIssuedEvent("cardId", 100));
----

[NOTE]
====
In the `AxonTestFixture`, metadata is represented as `Metadata` (with string values only) instead of `Map<String, ?>`.
====

[[validation-phase]]
=== Validation phase

The last phase is the validation phase, which allows you to check on the activities of the test.
Access the then phase by calling `then()` on the when phase.

The validation phase provides methods to validate:

* **Published events** - `events(Object...)`, `events(EventMessage...)`, `noEvents()`
* **Dispatched commands** - `commands(Object...)`, `commands(CommandMessage...)`, `noCommands()`
* **Command results** (when command was executed) - `success()`, `resultMessagePayload(Object)`, `exception(Class<?>)`
* **Custom assertions** - `eventsSatisfy(Consumer)`, `eventsMatch(Predicate)`, `commandsSatisfy(Consumer)`, `commandsMatch(Predicate)`
* **Async operations** - `await(Consumer<T>)`, `await(Consumer<T>, Duration)`

==== Validating events

The most common validation is checking which events were published:

[source,java]
----
fixture.given()
       .event(new CardIssuedEvent("cardId", 100))
       .when()
       .command(new RedeemCardCommand("cardId", "txn1", 20))
       .then()
       .events(new CardRedeemedEvent("cardId", "txn1", 20));
----

Or verify no events were published:

[source,java]
----
fixture.given()
       .event(new CardIssuedEvent("cardId", 100))
       .when()
       .command(new RedeemCardCommand("cardId", "txn1", 0))
       .then()
       .noEvents();
----

Custom event assertions:

[source,java]
----
fixture.when()
       .command(new CreateCardCommand("cardId", 100))
       .then()
       .eventsSatisfy(events -> {
           assertEquals(1, events.size());
           CardIssuedEvent event = (CardIssuedEvent) events.get(0).payload();
           assertEquals("cardId", event.getCardId());
           assertEquals(100, event.getAmount());
       });
----

==== Validating command result

When testing commands, you can validate the command execution result. The following methods are available:

* **`success()`** - Validates successful command execution
* **`resultMessagePayload(Object)`** - Validates the command result payload equals the expected value
* **`resultMessagePayloadSatisfies(Consumer)`** - Custom assertions on the result payload
* **`resultMessageSatisfies(Consumer<CommandResultMessage>)`** - Custom assertions on the full result message
* **`exception(Class<?>)`** - Validates an exception of the specified type was thrown
* **`exception(Predicate<Throwable>)`** - Validates the exception matches a predicate

Examples:

[source,java]
----
// Validate successful command execution
fixture.when()
       .command(new CreateCardCommand("cardId", 100))
       .then()
       .success()
       .events(new CardIssuedEvent("cardId", 100));

// Validate command result payload
fixture.when()
       .command(new GetCardBalanceCommand("cardId"))
       .then()
       .resultMessagePayload(100)
       .success();

// Validate exception
fixture.when()
       .command(new RedeemCardCommand("cardId", "txn1", 200))
       .then()
       .exception(InsufficientBalanceException.class)
       .noEvents();

// Custom result assertions
fixture.when()
       .command(new CreateCardCommand("cardId", 100))
       .then()
       .resultMessageSatisfies(result -> {
           assertFalse(result.isExceptional());
           assertEquals("cardId", result.payload());
       });
----

==== Validating published events

The other component is validation of published events. There are two ways of matching expected events.

The first is to pass in event instances that need to be literally compared with the actual events. All properties of the expected events are compared (using `equals()`) with their counterparts in the actual Events. If one of the properties is not equal, the test fails and an extensive error report is generated.

The other way of expressing expectancies is using "Matchers" (provided by the Hamcrest library). `Matcher` is an interface prescribing two methods: `matches(Object)` and `describeTo(Description)`. The first returns a boolean to indicate whether the matcher matches or not. The second allows you to express your expectation. For example, a "GreaterThanTwoMatcher" could append "any event with value greater than two" to the description. Descriptions allow expressive error messages to be created about why a test case fails.

Creating matchers for a list of events can be tedious and error-prone work. To simplify things, Axon provides a set of matchers that allow you to provide a set of event specific matchers and tell Axon how they should match against the list. These matchers are statically available through the abstract `Matchers` utility class.

Below is an overview of the available event list matchers and their purpose:

* *List with all of*: `Matchers.listWithAllOf(event matchers...)`

This matcher will succeed if all of the provided event matchers match against at least one event in the list of actual events.

It does not matter whether multiple matchers match against the same event,

nor if an event in the list does not match against any of the matchers.

* *List with any of*: `Matchers.listWithAnyOf(event matchers...)`

This matcher will succeed if one or more of the provided event matchers matches against one or more

of the events in the actual list of events.

Some matchers may not even match at all, while another matches against multiple others.

* *Sequence of Events*: `Matchers.sequenceOf(event matchers...)` Use this matcher to verify that the actual events are matched in the same order as the provided event matchers. It will succeed if each matcher matches against an event that comes after the event that the previous matcher matched against. This means that "gaps" with unmatched events may appear.

If, after evaluating the events, more matchers are available, they are all matched against "`null`". It is up to the event matchers to decide whether they accept that or not.

* *Exact sequence of Events*: `Matchers.exactSequenceOf(event matchers...)`

Variation of the "Sequence of Events" matcher where gaps of unmatched events are not allowed.

This means each matcher must match against the event directly following the event the previous matcher matched against.

For convenience, a few commonly required event matchers are provided. They match against a single event instance:

* *Equal event*: `Matchers.equalTo(instance...)`

Verifies that the given object is semantically equal to the given event.

This matcher will compare all values in the fields of both actual and expected objects using a null-safe equals method.

This means that events can be compared, even if they do not implement the equals method.

The objects stored in fields of the given parameter _are_ compared using equals,

requiring them to implement one correctly.

* *No more events*: `Matchers.andNoMore()` or `Matchers.nothing()`

Only matches against a `null` value.

This matcher can be added as last matcher to the _exact_ sequence of events matchers to ensure that no unmatched events remain.

* *Predicate Matching*: `Matchers.matches(Predicate)` or `Matchers.predicate(Predicate)`

Creates a Matcher that matches with values defined by the specified `Predicate`.

Can be used in case the `Predicate` API provides a better means to validating the outcome.

Since the matchers are passed a list of event messages, you sometimes only want to verify the payload of the message. There are matchers to help you out:

* *Payload matching*: `Matchers.messageWithPayload(payload matcher)`

Verifies that the payload of a message matches the given payload matcher.

* *Payloads matching*: `Matchers.payloadsMatching(list matcher)`

Verifies that the payloads of the messages matches the given matcher.

The given matcher must match against a list containing each of the messages payload.

The payloads matching matcher is typically used as the outer matcher to prevent repetition of payload matchers.

Below is a small code sample displaying the usage of these matchers. In this example, we expect two events to be published. The first event must be a "ThirdEvent", and the second "aFourthEventWithSomeSpecialThings". There may be no third event, as that will fail against the "andNoMore" matcher.

[source,java]
----
import org.axonframework.test.aggregate.FixtureConfiguration;

import static org.axonframework.test.matchers.Matchers.andNoMore;
import static org.axonframework.test.matchers.Matchers.equalTo;
import static org.axonframework.test.matchers.Matchers.exactSequenceOf;
import static org.axonframework.test.matchers.Matchers.messageWithPayload;
import static org.axonframework.test.matchers.Matchers.payloadsMatching;

class MyCommandModelTest {

    private FixtureConfiguration<MyCommandModel> fixture;

    public void testWithMatchers() {
        fixture.given(new FirstEvent(), new SecondEvent())
               .when(new DoSomethingCommand("aggregateId"))
               .expectEventsMatching(exactSequenceOf(
                   // we can match against the payload only:
                   messageWithPayload(equalTo(new ThirdEvent())),
                   // this will match against a Message
                   aFourthEventWithSomeSpecialThings(),
                   // this will ensure that there are no more events
                   andNoMore()
               ));

               // or if we prefer to match on payloads only:
               .expectEventsMatching(payloadsMatching(
                   exactSequenceOf(
                       // we only have payloads, so we can equalTo directly
                       equalTo(new ThirdEvent()),
                       // now, this matcher matches against the payload too
                       aFourthEventWithSomeSpecialThings(),
                       // this still requires that there is no more events
                       andNoMore()
                   )
               ));
   }
}
----

==== Validating aggregate state

In certain circumstances, it may be desirable to validate the state in which an Aggregate was left after a test. This is especially the case in given-when-then scenario's where the _given_ represents an initial state as well, as is regular when using a xref:axon-framework-commands:modeling/state-stored-entities.adoc[State-Stored Aggregate].

The fixture provides a method that allows verification of the state of the aggregate, as it is left after the <<test-execution-phase,Execution Phase>> (for example, the _when_ state), to be validated.

[source,java]
----
fixture.givenState(() -> new GiftCard())
       .when(new RedeemCardCommand())
       .expectState(state -> {
           // perform assertions
       });
----

The `expectState` method takes a consumer of the Aggregate type. Use regular assertions provided by your test framework to assert the state of the given Aggregate. Any (Runtime) Exception or Error will fail the test case accordingly.

____

*Event-Sourced Aggregate State Validation*

State validation for testing Event Sourced Aggregates is considered bad practice. Ideally, the state of an Aggregate is completely opaque to the testing code, as only the behavior should be validated. Generally, the desire to validate state is an indication that a certain test scenario is missing from the test suite.

____

[[validating-deadlines]]
==== Validating deadlines

The validation phase also provides the option to verify scheduled and met xref:../deadlines/deadline-managers.adoc for a given Aggregate instance. You can expect scheduled deadlines both through a `Duration` or an `Instant`, using explicit equals, a `Matcher` or just a deadline type to verify the deadline message. +
The following methods are available for validating Deadlines:

* `expectScheduledDeadline(Duration, Object)`:

Explicitly expect a given `deadline` to be scheduled after the specified `Duration`.

* `expectScheduledDeadlineMatching(Duration, Matcher)`:

Expect a deadline matching the `Matcher` to be scheduled after the specified `Duration`.

* `expectScheduledDeadlineOfType(Duration, Class)`:

Expect a deadline matching the given type to be scheduled after the specified `Duration`.

* `expectScheduledDeadlineWithName(Duration, String)`:

Expect a deadline matching the given deadline name to be scheduled after the specified `Duration`.

* `expectScheduledDeadline(Instant, Object)`:

Explicitly expect a given `deadline` to be scheduled at the specified `Instant`.

* `expectScheduledDeadlineMatching(Instant, Matcher)`:

Expect a deadline matching the `Matcher` to be scheduled at the specified `Instant`.

* `expectScheduledDeadlineOfType(Instant, Class)`:

Expect a deadline matching the given type to be scheduled at the specified `Instant`.

* `expectScheduledDeadlineWithName(Instant, String)`:

Expect a deadline matching the given deadline name to be scheduled at the specified `Instant`.

* `expectNoScheduledDeadlines()`:

Expect that no deadlines are scheduled at all.

* `expectNoScheduledDeadlineMatching(Matcher)`:

Expect no deadline matching the `Matcher` to be scheduled.

* `expectNoScheduledDeadlineMatching(Duration, Matcher)`:

Expect no deadline matching the `Matcher` to be scheduled after the specified `Duration`.

* `expectNoScheduledDeadline(Duration, Object)`

Explicitly expect no given `deadline` to be scheduled after the specified `Duration`.`

* `expectNoScheduledDeadlineOfType(Duration, Class)`

Expect no deadline matching the given type to be scheduled after the specified `Duration`.`

* `expectNoScheduledDeadlineWithName(Duration, String)`

Expect no deadline matching the given deadline name to be scheduled after the specified `Duration`.`

* `expectNoScheduledDeadlineMatching(Instant, Matcher)`:

Expect no deadline matching the `Matcher` to be scheduled at the specified `Instant`.

* `expectNoScheduledDeadline(Instant, Object)`

Explicitly expect no given `deadline` to be scheduled at the specified `Instant`.`

* `expectNoScheduledDeadlineOfType(Instant, Class)`

Expect no deadline matching the given type to be scheduled at the specified `Instant`.`

* `expectNoScheduledDeadlineWithName(Instant, String)`

Expect no deadline matching the given deadline name to be scheduled at the specified `Instant`.`

* `expectDeadlinesMet(Object...)`:

Explicitly expect a `deadline` or several deadlines to have been met.

* `expectDeadlinesMetMatching(Matcher&lt;List&lt;DeadlineMessage&gt;&gt;)`:

Expect a matching deadline or several matching deadlines to have been met.