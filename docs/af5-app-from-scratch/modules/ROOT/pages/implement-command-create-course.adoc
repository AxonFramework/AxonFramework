:navtitle: Feature: Create Course
:reftext: Implementing the create new course feature

= Create course feature

When you implement a new feature the first step is to define the messages which will be the input and output of it.
In Axon Framework messages are the first-class citizen and everything is designed around them.
While designing the app and also during execution - you're always in the context of some command.

Let's focus on the first feature for this sample app.
We need to be able to create a new course.
Could you imagine a faculty without any courses, which students may subscribe to?
I can't either!

== Define messages

Messages are the contract between different parts of our system, so you need to pay attention to craft them correctly.
Event Modeling helps a lot, thanks to it completeness check you can be sure you don't forgot about anything.
So let's take the first Write Slice on the table.
We can name it shortly as `CreateCourse`->`CourseCreated`.
Now we're going to translate the sticky notes to the code.
The orange sticky is an event, and every event needs a cause, which is a command which may trigger the event.
In this case it's a `CreatCourse` on the blue sticky note.

In Axon Framework 5, we typically define commands and events as simple data structures - using Java `records`.
You can also use Java classes if you really want, but records fulfill nicely the characteristic of messages, because they are immutable by definition.
As you remember we follow the Vertical Slice Architecture so please create files with corresponding content:

* `CreateCourse` in the `io.axoniq.demo.university.faculty.write.createcourse` package (we place command inside the slice package, because the command has only one handler)
* `CourseCreated` in the `io.axoniq.demo.university.faculty.events` package (events are shared between slices, there may be 0 to many handlers for the same event)

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/write/createcourse/CreateCourse.java
----
package io.axoniq.demo.university.faculty.write.createcourse;

import io.axoniq.demo.university.faculty.write.CourseId;
import org.axonframework.modelling.command.annotation.TargetEntityId;

public record CreateCourse(
    CourseId courseId,
    String name,
    int capacity
) {}
----

[NOTE]
====
You may notice that for the `courseId` field we use `CourseId` value object.
It's not necessary, but it's a convention.
This class provides type safety and domain semantics for course identifiers.
Thanks to that you won't mix CourseId with other identifiers in the system like StudentId.
The class may be as simple as `public record CourseId(String raw) {}`.
In the sample we have also some additional helpful methods which you may find in the repository, but for now this is enough.
====

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/events/CourseCreated.java
----
package io.axoniq.demo.university.faculty.events;

import io.axoniq.demo.university.faculty.FacultyTags;
import org.axonframework.eventsourcing.annotations.EventTag;

public record CourseCreated(
    @EventTag String courseId, // <1>
    String name,
    int capacity
) {}
----

<1> The `courseId` is annotated with `@EventTag`, which allows Axon to tag the event as connected with the 'Course' business entity and then use it for efficiently retrieval of the events related to given 'Course'.
It's a simple String - for events we prefer to avoid Value Objects, because events need to be deserialized regardless of the current rules for Value Objects creations.

== Specification by example

We already have our first slice API defined.
Now we're going to specify the slice behaviour.
For that purpose we're going to follow Test-First approach and write test in Given-When-Then convention, perfectly supported by Axon Test Fixture.
Still, everything is around messages.
So keep focus on the current command - `CreateCourse` and create corresponding `CreateCourseTest` class in the `io.axoniq.demo.university.faculty.write.createcourse` package.

TIP: You can also use your IDE to create the unit test class.
Open the `CreateCourse` class and ask your IDE to generate the corresponding unit test.
Depending on your IDE, the shortcut or menu may vary, but it's a shortcut worth knowing for your IDE.

[source,java]
.src/test/java/io/axoniq/demo/university/faculty/write/createcourse/CreateCourse.java
----
package io.axoniq.demo.university.faculty.write.createcourse;

class CreateCourseTest {

}
----

=== Defining the Test Fixture

Axon Framework test fixture allows you to execute certain test cases against provided configuration.
It may be your module/component or event whole application.
Do you remember the configurer which we used while bootstrapping the application?
Now it's time to use it in order to initialize our TestFixture.
We need to have access to application components in tests to verify their behaviour.

[source,java]
.src/test/java/io/axoniq/demo/university/faculty/write/createcourse/CreateCourse.java
----
package io.axoniq.demo.university.faculty.write.createcourse;

class CreateCourseTest {

    private AxonTestFixture fixture;

    @BeforeEach // <1>
    void beforeEach() {
        fixture = AxonTestFixture.with(UniversityAxonApplication.configurer()); // <2>
    }

}
----

<.> The `@BeforeEach` marks this method to be called before any test is executed in our test class.
Adding the code to create the `AxonTestFixture` here will ensure that we have a fresh fixture for each test case, and thus we make our different tests independent.
<.> This line creates a new `AxonTestFixture` based on our configuration.

=== Testing the command

Thanks to the help of the `AxonTestFixture` we can now create a test with the following structure:

- *Given*: Set the initial state for our test.
Since we are designing our system to follow Event-Sourcing patterns, we need to set the list of events that have already happened before receiving the command.
- *When*: Specify the command whose execution we want to test.
In this case, we will test the processing of a `CreateCourse`.
- *Expect*: We can instruct the fixture on the expectations we have from our system after processing the command.
In an Event-Sourcing system, we will specify these expectations in the form of what events should have been produced by the command handler as a result of processing the command.

So, let's define a method in our unit test to check that our system can successfully process the request to create a course:

[source,java]
.src/test/java/io/axoniq/demo/university/faculty/write/createcourse/CreateCourse.java
----
package io.axoniq.demo.university.faculty.write.createcourse;

import java.util.UUID;class CreateCourseTest {

    private AxonTestFixture fixture;

    @BeforeEach // <1>
    void beforeEach() {
        fixture = AxonTestFixture.with(UniversityAxonApplication.configurer()); // <2>
    }

    @Test
    void givenNotExistingCourse_WhenCreateCourse_ThenSuccess() {
        var courseId = new CourseId(UUID.randomUUID().toString());
        var courseName = "Event Sourcing in Practice";
        var capacity = 3;

        fixture.given() // <1>
               .noPriorActivity()
               .when()
               .command(new CreateCourse(courseId, courseName, capacity)) // <2>
               .then()
               .events(new CourseCreated(courseId.raw(), courseName, capacity)); // <3>
    }

}
----

<.> In our case, when we receive the `CreateCourse` command, we expect that no previous events were received in the system.
We may even skip the whole `given` section if there is nothing to execute.
<.> We provide the `CreateCourse` command we want to dispatch against the system (scoped to the given configuration).
<.> After successfully processing the `CreateCourse`, we expect the publication of a new `CourseCreated` event with the details of the new course.

When we execute the test you will see in the stack trac a following error:

[,console]
----
org.axonframework.commandhandling.NoHandlerForCommandException: No handler was subscribed for command [io.axoniq.demo.university.faculty.write.createcourse.CreateCourse#0.0.1].
----

It means that we need to implement the handler for the `CreateCourse` command.
And this will be our next step!

=== Implementing the Command Handler

To process a `CreateCourse` command in our application, we must define a method that receives the command as an argument.
To indicate that the method should be invoked upon receiving a command, we will add the `@CommandHandler` annotation provided by AxonFramework.
Let's create a new class for that inside the slice package and name it `CreateCourseCommandHandler` and implement the minimum required to make the test pass.

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/write/createcourse/CreateCourseCommandHandler.java
----
package io.axoniq.demo.university.faculty.write.createcourse;

import org.axonframework.commandhandling.annotation.CommandHandler;
import org.axonframework.eventhandling.EventSink;
import org.axonframework.messaging.unitofwork.ProcessingContext;
import org.axonframework.modelling.command.annotation.InjectEntity;

class CreateCourseCommandHandler {

    @CommandHandler // <1>
    public void handle(
            CreateCourse command,  // <2>
            EventSink eventSink,  // <3>
            ProcessingContext processingContext  // <4>
    ) {
        var event = new CourseCreated(command.courseId().raw(), command.name(), command.capacity());  // <5>
        var message = toMessage(event); // <6>
        eventSink.publish(processingContext, message); // <7>
    }

    private static EventMessage<?> toMessage(Object payload) {
        return new GenericEventMessage<>(
                new MessageType(payload.getClass()),
                payload
        );
    }

}
----

<.> The `org.axonframework.commandhandling.annotation.CommandHandler` annotation instructs Axon Framework to call this method upon receiving commands.
<.> The type of the argument indicates to Axon Framework which type of commands should be linked to the invocation of this method.
<.> The `EventSink` is a component that allows us to publish the Event that notifies the change in the state of our system.
In this case, to notify that the *course has been created*.
<.> The `ProcessingContext` is a component that allows us to manage the lifecycle of the message processing.
Allows us to publish events in the context of the current command so the events will be published after successful command execution.
<.> The `EventSink` interface require implementation of the `EventMessage` as a second argument so we provide one.
<.> The invocation of `EventSink#publish` stage event to be published after the current `ProcessingContext` is completed.

Have you already tried to run the test?
Unfortunately it will fail again.
What we need to do now, we need to register the `CreateCourseCommandHandler` in the Axon Framework configuration.
We're going to do it in dedicated class `CreateCourseConfiguration` which will be responsible for spinning up the infrastructure for the whole slice.

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/write/createcourse/CreateCourseConfiguration.java
----
package io.axoniq.demo.university.faculty.write.createcourse;

public class CreateCourseConfiguration {

    public static EventSourcingConfigurer configure(EventSourcingConfigurer configurer) {
        var commandHandlingModule = StatefulCommandHandlingModule.named("CreateCourse") // <1>
                .commandHandlers()
                .annotatedCommandHandlingComponent(c -> new CreateCourseCommandHandler()); // <2>
        return configurer.registerStatefulCommandHandlingModule(commandHandlingModule); // <3>
    }

}
----

<.> The `StatefulCommandHandlingModule` is a component that allows us to register the command handler for the `CreateCourse` command.
For our current needs we skip `entities` configuration, because we don't need the state yet.
<.> The `annotatedCommandHandlingComponent` method allows us to register the `CreateCourseCommandHandler` as the command handler for the `CreateCourse` command.
<.> The `registerStatefulCommandHandlingModule` method registers the command handler module in the Axon Framework configuration.

When the slice configurer is ready we can register it to the main application configurer.
To do that let's introduce changes in our main `UniversityAxonApplication` class.

[source,java]
./src/main/java/io/axoniq/demo/university/UniversityAxonApplication.java
----
public class UniversityAxonApplication {

    public static ApplicationConfigurer<?> configurer() {
        var configurer = EventSourcingConfigurer.create();
        configurer = CreateCourseConfiguration.configure(configurer);
        return configurer;
    }

}
----

Let's check our test again, now everything is green!
Can we say that the work is done?
Not yet!
Because we have some business rules defined in the Given-When-Then specifications.
The course cannot be created if it already exists.
So let's add a test case for that to the `CreateCourseTest` class as below

[source,java]
.src/test/java/io/axoniq/demo/university/faculty/write/createcourse/CreateCourse.java
----
package io.axoniq.demo.university.faculty.write.createcourse;

import java.util.UUID;

class CreateCourseTest {

    // fixture creation skipped for brevity

    @Test
    void givenCourseCreated_WhenCreateCourse_ThenSuccess_NoEvents() {
        var courseId = new CourseId(UUID.randomUUID().toString());
        var courseName = "Event Sourcing in Practice";
        var capacity = 3;

        fixture.given()
               .event(new CourseCreated(courseId.raw(), courseName, capacity)) // <1>
               .when()
               .command(new CreateCourse(courseId, courseName, capacity)) // <2>
               .then()
               .success() // <3>
               .noEvents(); // <3>
    }

}
----

<1> In our case, when we receive the `CreateCourse` command, we expect that `CourseCreated` event happened in the past, so the Course already exists in the system.
<2> We provide the `CreateCourse` command we want to dispatch against the system (scoped to the given configuration), so will be handled by registered handler.
<3> After successfully processing the `CreateCourse`, we expect the command handler executed successfully, but no events were published.

If you ran this test you may notice that it fails, because of unexpected event was published!

[,console]
----
org.axonframework.test.AxonAssertionError: The published events do not match the expected events

Expected  |  Actual
----------|----------
         <|> io.axoniq.demo.university.faculty.events.CourseCreated
----

Do you remember that we haven't used any state inside the *Stateful* command handling component?
Now we definitiely do that, because the system decision what to do with the command will be based on the state derived from the historial events.

=== Validate the Command against the state

The only think we need to know about certain course for the `CreateCourse` command handling if it already exists or not.
So let's add the `State` class which will be responsible for providing that information.
I will use the term `State`, because it's not everything what we know about the `Course`, we don't need subscribed students etc. just for this command purposes.
But you can name it `Course` as well, but keep in mind it's just a part of information needed for the validation of this command.
I'm going to put it as internal class in the handler, because it will be used just there.

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/write/createcourse/CreateCourseCommandHandler.java
----
package io.axoniq.demo.university.faculty.write.createcourse;

class CreateCourseCommandHandler {

    @EventSourcedEntity(tagKey = "courseId") // <1>
    public static class State {

        private boolean created = false; // <2>

        @EventSourcingHandler // <3>
        public void apply(CourseCreated event) {
            this.created = true;
        }
    }

    @CommandHandler
    public void handle(
            CreateCourse command,
            @InjectEntity(idProperty = "courseId") State state, // <4>
            EventSink eventSink,
            ProcessingContext processingContext
    ) {
        if(state.created) { // <5>
            return;
        }
        var event = new CourseCreated(command.courseId().raw(), command.name(), command.capacity());
        eventSink.publish(processingContext, toMessage(event));
    }

}

----

<1> The `@EventSourcedEntity` annotation indicates that this class state is derived from the events published with the given tag key (`courseId` in this case).
We've already annotation `courseId` property in the `CourseCreated` event class with `@EventTag`, so the event will be applied while loading the entity.
<2> The properties needed to guard certain business rules.
In this case we need to know if the course was already created or not.
While executing the command we don't care about the name or other properties.
<3> The `@EventSourcingHandler` annotation indicates to Axon Framework to link this method to the reception of an event.
It will be called while the entity is being loaded.
Axon Framework will use the type of the annotated method argument to link this method to the specific type of event.
<4> The `@InjectEntity` annotation indicates to Axon Framework to inject the entity with the given identifier property which needs to be present in the processed command.
In this case, we want to inject the `State` entity with the `courseId` property.
<5> The `if` statement checks if the course was already created.
If it was, we don't need to do anything, so we just return from the method.

As before, the last step to fulfill the next test case are changes in our configuration.
Come back to the `CreateCourseConfiguration` class and add the `State` class to the configuration.

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/write/createcourse/CreateCourseConfiguration.java
----
package io.axoniq.demo.university.faculty.write.createcourse;

public class CreateCourseConfiguration {

    public static EventSourcingConfigurer configure(EventSourcingConfigurer configurer) {
        var stateEntity = EventSourcedEntityBuilder
                .annotatedEntity(CourseId.class, CreateCourseCommandHandler.State.class);  // <1>

        var commandHandlingModule = StatefulCommandHandlingModule.named("CreateCourse")
                .entities()
                .entity(stateEntity)  // <2>
                .commandHandlers()
                .annotatedCommandHandlingComponent(c -> new CreateCourseCommandHandler());
        return configurer.registerStatefulCommandHandlingModule(commandHandlingModule);
    }

}
----

== First in, first out.

Do you like green tests?
Me too!
But what I like even more are green slices on Event Modeling.
So if you use this approach now you can mark your first slice as implemented!
Congratulations!
No let's move to more complex examples or read about alternative approach - how you can do the same without annotations.

= Implement feature: `CreateCourse` -> `CourseCreated`

Axon Framework jest zaprojektowany wokół Messages.
To je traktujemy jako first-class citizen i to one są obserwowalnym zachowaniem.
Nie musisz na początek martwić się o strukturę bazy danych, rysować wielkich diagramów i craftować modeli.
Większość pracy wykonaliśmy już w czasie Event Modelingu, teraz przełożymy to tylko na działający kod!

Let's start by implementing the "Create Course" feature, which allows faculty staff to create new courses with a specified name and capacity.
For that you need to create a Java package that fits in the project architecture, for this example we use *Vertical Slice Architecture* approach, but framework is flexible enough to allow you to use any architecture you prefer.

== Define Messages

First, let's define the necessary messages that will be used for this feature.
In Axon Framework 5, we typically define commands and events as simple data structures - using Java `records`.

==== Command: CreateCourse

Create a new CreateCourse command in the `io.axoniq.demo.university.faculty.write.createcourse` package:

[source,java]
----
package io.axoniq.demo.university.faculty.write.createcourse;

import io.axoniq.demo.university.faculty.write.CourseId;
import org.axonframework.modelling.command.annotation.TargetEntityId;

public record CreateCourse(
    @TargetEntityId CourseId courseId,
    String name,
    int capacity
) {}
----

The `@TargetEntityId` annotation on the courseId field tells Axon which field contains the identifier for the target entity.
In this domain we have two business entities: `Course` and `Student`.

==== Event: CourseCreated

The result of the successful processing of the `CreateCourse` command will be the creation of a new course.
So let's define the `CourseCreated` event in the `io.axoniq.demo.university.faculty.events` package:

[source,java]
----
package io.axoniq.demo.university.faculty.events;

import io.axoniq.demo.university.faculty.FacultyTags;
import org.axonframework.eventsourcing.annotations.EventTag;

public record CourseCreated(
    @EventTag(key = FacultyTags.COURSE_ID) String courseId, //<1>
    String name,
    int capacity
) {}
----

<1> The `@EventTag` annotation allows Axon to tag the event as connected with the 'Course' business entity and then use it for efficiently retrieval of the events related to given 'Course'.
It's a simple String - or events we prefer to avoid Value Objects, because events need to be deserialized regardless of the current rules for Value Objects creations.

=== Define Identifier Type

Let's create a `CourseId` value object in the `io.axoniq.demo.university.faculty.write` package.
This class provides type safety and domain semantics for course identifiers.
Thanks to that you won't mix CourseId with other identifiers in the system like StudentId.
We use them in commands, but for events we prefer to avoid Value Objects, because events need to be deserialized regardless of the current rules for Value Objects creations.

[source,java]
----
package io.axoniq.demo.university.faculty.write;

import java.util.UUID;

public record CourseId(String raw) {
    private final static String ENTITY_TYPE = "Course";

    public CourseId {
        if (raw == null || raw.isBlank()) {
            throw new IllegalArgumentException("Course ID cannot be null or empty");
        }
        raw = withType(raw);
    }

    public static CourseId of(String raw) {
        return new CourseId(raw);
    }

    public static CourseId random() {
        return new CourseId(UUID.randomUUID().toString());
    }

    @Override
    public String toString() {
        return raw;
    }

    private static String withType(String id) {
        return id.startsWith(ENTITY_TYPE + ":") ? id : ENTITY_TYPE + ":" + id;
    }
}
----

----

// = Implement Create New Course feture
//
// In this step of the tutorial, we will implement the support for our first feature: create a new course in our system.
//
// == Design considerations
//
// Before jumping over the keyboard to start writing code, let's first introduce the big picture of the design of our system so that we are prepared to split and scale it out later.
//
// Although we will work on our rental module, we want to follow *vertical slice architecture* and make our features (slices if you like Event Modeling nomencalture)
// decoupled from each other. We start with feature which are part of the Command Model.
//
// ** *Command Model*: These are the components that receive all the requests that, as a result of processing them, imply a change in the state of our system.
// Requests like "Register a new bike", "Rent a bike" or "Return a bike" are a few examples of Commands
//
// == Implementing the process to register a new bike in the system
//
// :needs-improvement: Add a reference to the types of messages and what a command message is.
//
// When the application receives a request to create a course, that implies that the state of our application will change because, after successfully processing it, we will have a new bike in our system (so, the list of available bikes -our application's state- will have changed).
// So, we will model our request as a `Command`; in our case, we will call it `CreateCourse`.
//
// So, the `CreateCourse` command will be routed to the `Command Model`, where we will implement a handler method to process it.
// That method must create the new `Course` in our system and notify that "a new course has been created" to other components interested in this change.
//
// The type of this message, a *notification that something has happened*, corresponds to what we define as an `Event`.
// Thus, the command handler will trigger a `CourseCreated`.
//
// One last but important thing to remember in our design is the order in which we will implement the code that creates the new course in our system and the code that fires the event that notifies the change.
//
// anchor:design-command-handler[]In our application, we want to follow the design goals of Event Sourcing, and that implies that the changes in our command model will be done as a result of processing the same `CourseCreated` just as any other component in our application will do.
// That means that, among other good reasons, the list of Events will become our system's *single source of truth*.
//
// :needs-improvement: Add a reference to a section with a more in depth review of what Event Sourcing implies and what are the benefits of Event Sourcing.
//
// First of all, let's specify our application behaviour for this feature using Axon Test Fixture.
//
//
// The steps for implementing the command handling for the `CreateCourse` command will be:
//
// 1. Receive and validate the command in the `@CommandHandler`.
// 2. If valid, send a `BikeRegisteredEvent` from the `@CommandHandler`.
// 3. Register and receive the `BikeRegisteredEvent` using an `@EventSourcingHandler` in our Command model.
// 4. Create the bike and assign the details for the bike created in the `@EventSourcingHandler` of our command model.
//
// In the following sections, let's see how to implement each of these steps in detail.
//
// === Defining the command
//
// As we aim to keep the modules loosely coupled so that we can easily split the modular monolith into different projects if we reach in the future the point in which the application has grown too complex that it needs to scale to multiple simpler modules, it's a good idea to keep the definition of the messages that we are going to use to communicate those logical modules in the `core-api` module we created earlier.
//
// So, we will create a new `CreateBikeCommand` in the `core-api` module.
// Create a new package `io.axoniq.demo.bikerental.coreapi.rental` and, inside that package, create the following `RegisterBikeCommand`:
//
// [source,java]
// .core-api/src/main/java/io/axoniq/demo/bikerental/coreapi/retnal/RegisterBikeCommand.java
// ----
// include::example$core-api/src/main/java/io/axoniq/demo/bikerental/coreapi/rental/RegisterBikeCommand.java[]
// ----
//
// <1> The `@TargetAggregateIdentifier` indicates to AxonFramework to use the `bikeId` attribute as the unique identifier to load the Bike with id `{bikeId}` before handling the command.
//
// We have defined the command as a Java record that contains the minimum amount of information necessary to process the command.
//
// TIP: Using a Java record structure also brings the benefit of immutability to our command.
// You can also use a data class in Kotlin to define the commands.
//
// == Implementing the command model
// :needs-improvement: "Add a link to an explanation of what an Aggregate is and how it links with DDD".
//
// The next step to process the `RegisterBikeCommand` is to define the component responsible for processing that request.
// In our example, we are following the DDD design model, which relies on the concept of the *Aggregate* to model the state of our system.
// And, with the Axon Framework, we will use the Aggregate to "designate" (via annotations) the methods the framework should invoke upon receiving a specific message.
//
// === Creating the aggregate class (the Bike)
//
// Thus, we will start by creating the Aggregate (or Entity) that will represent the state of our application related to the feature of processing requests to register, rent or return a bike.
//
// NOTE: In more complex systems, there are some techniques to design your command and query models based on a previous analysis of the interactions and features that the system will support. *Event Storming* and *Event Modeling* are valuable techniques to analyze your system and extract the different Commands, Events, Queries and Aggregates.
//
// :needs-improvement: "Add links to blog posts from the developer portal once they are moved to the new location in the axoniq.io corporate site."
//
// We can start by creating a `Bike` class to model our Aggregate.
//
// [source,java]
// .rental/src/main/java/io/axoniq/demo/bikerental/rental/command/Bike.java
// ----
// @Aggregate <.>
// include::example$rental/src/main/java/io/axoniq/demo/bikerental/rental/command/Bike.java[tags=BikeAggregateClass;BikeAggregateFields;!*]
// ----
//
// <.> We will mark the class with `org.axonframework.spring.stereotype.Aggregate` annotation.
// This way Axon Framework will handle the lifecycle of the instances of our Bikes based on the Commands and Events received by our command model component.
// <.> We will design the attribute that will hold the unique identifier of our bike instance using the `org.axonframework.modeling.command.AggregateIdentifier` annotation.
// <.> We also need a default Java constructor that Axon Framework needs to create the new instance of a bike before populating its fields with the state and invoking the method to handle the Command or Event received.
//
// === Defining the command handler method.
//
// To process a `RegisterBikeCommand` in our application, we must define a method in our `Bike` class that receives the command as an argument.
// To indicate that the method should be invoked upon receiving a command, we will add the `@CommandHandler` annotation provided by AxonFramework.
//
// In this case, as the `RegisterBikeCommand` is the request to create a new instance of a Bike, we must define the command handler using a constructor.
//
// [source,java]
// ----
// @Aggregate
// include::example$rental/src/main/java/io/axoniq/demo/bikerental/rental/command/Bike.java[tags=BikeAggregateClass;RegisterBikeCommandHandler;!*]
//
// ----
//
// <.> The `org.axonframework.commandhandling.CommandHandler` annotation instructs Axon Framework to call this method upon receiving commands.
// <.> The type of the argument indicates to Axon Framework which type of commands should be linked to the invocation of this method.
// <.> The static method `AggregateLifecycle.apply()` is invoked to send the Event that notifies the change in the state of our system.
// In this case, to notify that the *bike has been registered*.
//
// [NOTE]
// ====
// In the command handler, we have not changed the internal properties of the `Bike` instance.
//
// As a general rule and as we discussed in the xref:design-command-handler[Command Handler design considerations], we will simply:
//
// 1. Validate, if necessary, that the command we received is valid and can be processed.
// 2. Send a message notifying that, as the command is valid, the bike was registered.
//
// We will leave the task of setting the properties of our newly registered `Bike` instance for a later step, when the command model reacts to the reception of the `BikeRegisteredEvent`.
// ====
//
// === Handling the BikeRegisteredEvent in the aggregate
// :needs-improvement: A more in deepth reference to Event-Sourcing and ES benefits is required here.
//
// We want to design our system following the principles of *Event Sourcing*, which implies we will use the set of Events as the *single source of truth* for building or refreshing the state of any component in our system.
//
// That means that we will also use the `BikeRegisteredEvent` as the source to trigger the state change in our command model, or, more specifically, in this case, in our `Bike` aggregate.
//
// To be able to react to the event in our `Bike` aggregate, we need to add a method that receives the `BikeRegisteredEvent` event as an argument and annotate that method with `@EventSourcingHandler`:
//
// [source,java]
// .rental/src/main/java/io/axoniq/demo/bikerental/rental/command/Bike.java
// ----
// @Aggregate
// include::example$rental/src/main/java/io/axoniq/demo/bikerental/rental/command/Bike.java[tags=BikeAggregateClass;BikeRegisteredEventSourcingHandler;!*]
// ----
//
// <.> The `EventSourcingHandler` annotation indicates to Axon Framework to link this method to the reception of an event.
// <.> Axon Framework will use the type of the argument to link this method to the specific type of event.
//
// In the implementation of the method, we will finally set the bike properties (the state of our model) with the information provided by the event.
//
// NOTE: The `EventSourcingHandler` will be called right after the event publication by the `CommandHandler`.
// But it also will be invoked in the future, for the same event, when the system receives another command for the same `bikeId` (identified because the command has the same  `@AggregateIdentifier`) and Axon Framework needs to regenerate the current state of the `Bike` instance, by replaying all previous events with the same `bikeId`.
//
// CAUTION: In the `EventSourcingHandler` method, we should never validate or ignore the changes represented by the event received.
// The reception of the event and the invocation of the method imply that the command has already been processed previously.
// So we can't ignore or reject those changes *because they already happened*
//
// With this step, we have completed the code to process a Command that represents the request to register a new bike in our system.
//
// == Implementing the HTTP REST controller
//
// In this section, we will implement the UI layer for our system.
// The UI layer represents the interface our system offers to the outside world to interact with our application.
//
// In our example, we will start with a REST service interface that offers some endpoints so that a third-party application can invoke our system.
// This REST interface is convenient for our example because we can show you how to accept requests from the user or another system and create and send the corresponding Command internally.
//
// === Create the SpringBoot controller.
//
// For the controller, we are going to create a simple Spring `@RestController,` and we will configure a couple of components provided by AxonFramework:
//
// - *`CommandGateway`*: is the abstraction mechanism provided by AxonFramework to send commands to the handler and removes from the controller any need to know all the specifics about the number and location of command handlers registered in our system or how to reach them.
// - *`QueryGateway`*: is a similar abstraction to the `CommandGateway` provided by Axon Framework, but in this case, it is intended to deliver query requests and wait for the query response.
//
// [NOTE]
// ====
// Although we will only use the `CommandGateway` for now, we are also going to add the `QueryGateway` to our `@RestController` as we will need it later to implement the handling of requests to gather information from our system.
//
// If you prefer to implement your code more progressively, just add the `CommandGateway` as this is the only component we will use now.
// You can add the `QueryGateway` field and its initialization later when implementing the code to handle the first query.
// ====
//
// The abstraction these two components provide helps keep our `@RestController` decoupled from the different query and command handlers in our system.
// Axon Framework will inject the proper implementation to handle the routing and communication patterns required both for queries and commands.
//
// Thus, our controller does not need to keep track of any detail about any of the handlers.
// This property is known as *Location Transparency* and it's one of the features that enable our application to scale out later easily because we can move the command handler implementation to a different module and deploy it in a different machine without the need to touch the code that sends the commands.
//
// We will place our controller in the `io.axoniq.demo.bikerental.rental.ui` package.
// Create a `RentalController` java class with the following contents:
//
// [source,java]
// .rental/src/main/java/io/axoniq/demo/bikerental/rental/ui/RentalController.java
// ----
// include::example$rental/src/main/java/io/axoniq/demo/bikerental/rental/ui/RentalController.java[tags=RentalControllerClassDefinition;BusGateways;ControllerInitialization;!*]
// }
// ----
//
// <.> The `@RestController` SpringBoot annotation indicates that this component will define the REST endpoints.
// <.> The `@RequestMapping` SpringBoot annotation indicates the root path for all the endpoints that this controller handles.
// <.> The `CommandGateway` that we will use to send the commands.
// <.> The `QueryGateway` that we will use later to send query requests and wait for the response.
// <.> We will define a constructor that receives both the `CommandGateway` and `QueryGateway` as an argument.
// Spring will provide the right implementation based on the components defined by Axon Framework.
//
// === Implement the endpoint to register a bike
//
// We must add a method in our controller to handle the HTTP Request to register a new bike.
// In our system, to create a new bike, we require the request to provide the type of the bike and the location where the bike is registered.
//
// For this endpoint, we will consider the following request format:
//
//     POST /bikes?bikeType={bikeType}&location={city}
//
// NOTE: When designing a REST endpoint that registers a new element in our system, it is usual to model the API to use a POST request, which contains the information of the entity to create in the body.
// In this first example, for the sake of simplicity, we will receive the bike details as parameters on the request.
//
// To implement the endpoint that handles these requests, add the following method to the `RentalController`:
//
// [source,java]
// .rental/src/main/java/io/axoniq/demo/bikerental/rental/ui/RentalController.java
// ----
// include::example$rental/src/main/java/io/axoniq/demo/bikerental/rental/ui/RentalController.java[tags=registerBike;!*,indent=0]
// ----
//
// <.> The `@PostMapping` links the execution of this method to the reception of `POST /bike` requests.
// <.> The `bikeType` argument is extracted from the parameter with the same name on the request.
// <.> The `location` argument is filled with the value of the parameter with the same name from the request's URL.
// <.> We must create the `RegisterBikeCommand` that represents the command we will send to the command handler in the command model.
// <.> The command requires a unique ID for the bike.
// As this request represents the creation of the new bike, we have chosen to create a unique ID on the controller.
// <.> We send the command through the `CommandGateway` abstraction provided by Axon Framework.
// <.> The command will be dispatched to the command handler.
// It will return a `CompletableFuture` with the result of executing the command.
//
// NOTE: By default, Axon Framework returns the ID of the bike that has been created.
// If there is any error in delivering the command to a command handler (for example, because there is no command handler registered for `RegisterBikeCommand`s), the CompletableFuture will contain the error.
//
// :needs-improvement: "Add a link to explain the routing pattern and communication semantics of a command, and how AxonFramework returns an error or a successful value depending on the command handler."
//
// == Conclusion
//
// In this section, we have implemented the code necessary to handle requests to register a new bike in our system.
//
// The following image represents the design of what we have implemented.
//
// .Diagram with the flow of messages to register a new bike
// image::image$RegisterBikeCommand.png[A diagram that shows the flow to process a Register bike request: First,we receive a POST HTTP request in the RentalController. Then,the RentalController sends a RegisterBikeCommand through the CommandGateway. The RegisterBikeCommand is delivered to the @CommandHandler method of the Bike Aggregate. The Command Handler validates the command and sends a BikeRegisteredEvent that will be sent to every other external module that is "interested" in this type of event. The @EventSourcingHandler also handles the event in the Bike aggregate,which finally updates the internal state by assigning the values from the command to private fields in the bike aggregate.]
//
// We can execute our application and see it in action.
// In our next section, we will go through the steps to run our AxonFramework application together using docker from your development environment.
//



