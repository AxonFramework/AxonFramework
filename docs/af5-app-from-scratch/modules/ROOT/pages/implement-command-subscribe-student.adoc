:navtitle: Feature: Subscribe Student
:reftext: Implementing the subscribe student feature

One of the major benefits of Axon Framework 5's Vertical Slice Architecture is the ability to implement features independently.
Now we'll implement the `SubscribeStudent` feature without needing to implement every feature in between.
As long as we keep the `State` needed for command validation private to each slice, the only shared code between slices are the events, which serve as the backbone contract of our system.

You even don't need to stick to certain order. How many times have you heard in the development team: "I'm waiting till the feature X is implemented, so I can implement my feature Y"?


== Define messages

As before, let's look at the Event Modeling diagram.
Which events do we need for this slice to fulfill the following Given-When-Then specification?

image::EventModeling_GWT_SubscribeStudent.png[]

In previous section we've defined the `CourseCreated` events, so there are two left from the specification.
Let's define them as Java records, as before.

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/events/StudentSubscribed.java
----
package io.axoniq.demo.university.faculty.events;

import org.axonframework.eventsourcing.annotations.EventTag;

public record StudentEnrolledFaculty(
        @EventTag // <1>
        String studentId,
        String firstName,
        String lastName
) {

}
----

<.> Always remember about marking which properties are event tags.

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/events/StudentSubscribed.java
----
package io.axoniq.demo.university.faculty.events;

import org.axonframework.eventsourcing.annotations.EventTag;

public record StudentSubscribed(
        @EventTag // <1>
        String studentId,
        @EventTag // <1>
        String courseId
) {
}
----

<.> Thanks to those annotations the event will be tagged with `studentId` and `courseId`.
It's a good example that StudentSubscribed event is connected to two business entitiesâ€”Student and the Course.
When domain experts say that "student subscribed", they know that means the course free spots decreased and also student subscription limit may be reached.
In the case of one event type per entity/tag/aggregateId we would need to duplicate those events artificially to have two in two different streams.

Last, but not least, we define the `SubscribeStudent` command.

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/write/subscribestudent/SubscribeStudent.java
----
package io.axoniq.demo.university.faculty.write.createcourse;

import io.axoniq.demo.university.faculty.write.StudentId;
import io.axoniq.demo.university.faculty.write.CourseId;

public record SubscribeStudent(StudentId studentId, CourseId courseId) {
}
----

== Specification by example

As you remember from the previous section we do not focus on entities, but on behavior.
So we're going to describe our feature in Given-When-Then manner based on commands and events.
Let's create the first test case using Axon Test Fixture.
We're going to translate the Event Modeling specification, which you've seen on the top of the page + other test cases for this slice, to the code.
We call it Test First, we don't use TDD to design our application, but we do the design on the whiteboard using Event Modeling, which is faster and much heaper than in the code.
From Event Modeling we can dervie the test cases for specific slice (functionality) and translate them directly to the code.
The Axon Framework supports the Given-When-Then convention pretty well.

NOTE: Translating Event Modeling specification to tests it's a repeatable tasks so can be even done easily with the help of AI.

[source,java]
.src/test/java/io/axoniq/demo/university/faculty/write/subscribestudent/SubscribeStudentTest.java
----
package io.axoniq.demo.university.faculty.write.createcourse;

import java.util.UUID;

class SubscribeStudentTest {

    private AxonTestFixture fixture;

    @BeforeEach
    void beforeEach() {
        fixture = AxonTestFixture.with(UniversityAxonApplication.configurer());
    }

    @Test
    void successfulSubscription() {
        var courseId = CourseId.random();
        var studentId = StudentId.random();

        fixture.given()
               .event(new CourseCreated(courseId.raw(), "Event Sourcing in Practice", 2))
               .event(new StudentEnrolledFaculty(studentId.raw(), "Mateusz", "Nowak"))
               .when()
               .command(new SubscribeStudent(studentId, courseId))
               .then()
               .events(new StudentSubscribed(studentId.raw(), courseId.raw()));
    }

    @Test
    void studentAlreadySubscribed() {
        var courseId = CourseId.random();
        var studentId = StudentId.random();

        fixture.given()
               .event(new StudentEnrolledFaculty(studentId.raw(), "Allard", "Buijze"))
               .event(new CourseCreated(courseId.raw(), "Axon Framework 5: Be a PRO", 2))
               .event(new StudentSubscribed(studentId.raw(), courseId.raw()))
               .when()
               .command(new SubscribeStudent(studentId, courseId))
               .then()
               .exception(RuntimeException.class, "Student already subscribed to this course");
    }

    @Test
    void courseFullyBooked() {
        var courseId = CourseId.random();
        var student1Id = StudentId.random();
        var student2Id = StudentId.random();
        var student3Id = StudentId.random();

        fixture.given()
               .event(new StudentEnrolledFaculty(student1Id.raw(), "Mateusz", "Nowak"))
               .event(new StudentEnrolledFaculty(student2Id.raw(), "Steven", "van Beelen"))
               .event(new StudentEnrolledFaculty(student3Id.raw(), "Mitchell", "Herrijgers"))
               .event(new CourseCreated(courseId.raw(), "Event Sourcing Masterclass", 2))
               .event(new StudentSubscribed(student1Id.raw(), courseId.raw()))
               .event(new StudentSubscribed(student2Id.raw(), courseId.raw()))
               .when()
               .command(new SubscribeStudent(student3Id, courseId))
               .then()
               .exception(RuntimeException.class, "Course is fully booked");
    }

    @Test
    void studentSubscribedToTooManyCourses() {
        var studentId = StudentId.random();
        var course1Id = CourseId.random();
        var course2Id = CourseId.random();
        var course3Id = CourseId.random();
        var targetCourseId = CourseId.random();

        fixture.given()
                .event(new StudentEnrolledFaculty(studentId.raw(), "Milan", "Savic"))
                .event(new CourseCreated(targetCourseId.raw(), "Programming", 10))
                .event(new CourseCreated(course1Id.raw(), "Course 1", 10))
                .event(new CourseCreated(course2Id.raw(), "Course 2", 10))
                .event(new CourseCreated(course3Id.raw(), "Course 3", 10))
                .event(new StudentSubscribed(studentId.raw(), course1Id.raw()))
                .event(new StudentSubscribed(studentId.raw(), course2Id.raw()))
                .event(new StudentSubscribed(studentId.raw(), course3Id.raw()))
                .when()
                .command(new io.axoniq.demo.university.faculty.write.subscribestudentmulti.SubscribeStudent(studentId, targetCourseId))
                .then()
                .noEvents()
                .exceptionSatisfies(thrown -> assertThat(thrown)
                        .isInstanceOf(RuntimeException.class)
                        .hasMessage("Student subscribed to too many courses")
                );
    }

}
----

To those tests we need to implement the command handler for `SubscribeStudent` command.
As you've seen for the behaviour which is based on some state (so we have something in Given section of the test) we need to have State for our command handler to validate commands against it.
Let's make it right away!

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/write/subscribestudent/SubscribeStudent.java
----
package io.axoniq.demo.university.faculty.write.subscribestudent;

import java.util.UUID;

class SubscribeStudentCommandHandler {

    private static final int MAX_COURSES_PER_STUDENT = 3; // <1>

    @CommandHandler
    void handle(
            SubscribeStudent command,
            @InjectEntity State state, // <2>
            EventSink eventSink,
            ProcessingContext processingContext
    ) {
        var events = decide(command, state); // <3>
        var messages = toMessages(events); // <4>
        eventSink.publish(processingContext, messages); // <5>
    }

    private List<StudentSubscribed> decide(SubscribeStudent command, State state) {
        // todo: check business rules
        return List.of(new StudentSubscribed(command.studentId().raw(), command.courseId().raw()));
    }

    private static List<EventMessage<?>> toMessages(List<StudentSubscribed> events) {
        return events.stream()
                     .map(SubscribeStudentCommandHandler::toMessage)
                     .collect(Collectors.toList());
    }

    private static EventMessage<?> toMessage(Object payload) {
        return new GenericEventMessage<>(
                new MessageType(payload.getClass()),
                payload
        );
    }

    @EventSourcedEntity // <6>
    static class State {
        // todo: define state necessary to accept or reject `SubscribeStudent` command
    }

}
----

<1> For the example simplicity we hardcoded the maximum number of courses per student.
Each student can subscribe up to 3 courses in the same time.
<2> We use `@InjectEntity` to inject the state object.
<3> This is your domain model invocation.
You may keep it in the command handler as on the example or make the function unaware of the infrastructure like Axon Framework.
This functional resembles the `Decider pattern.
<4> As before we translate events (which are a result of our domain function) to messages to be able to publish them.
<5> We use `EventSink` to publish events.
<6> Before we defined `tagKey` in `@EventSourcedEntity` annotation, now we cannot do that, because we require events about subscriptions for student and the course, so we have multiple business concepts related to business process. In a few sections you will see how to do that with the `EventCriteria` API.

We always need one identifier to load the state, because the `@InjectEntity` annotation needs to know how to identify the entity to load.
In this case it's more difficult, because the `SubscribeStudent` business process is identifier by the command type and also the `courseId` and `studentId`.
So similar as in databases we need some composite key to identify the entity.
To do that we're going to use the `SubscriptionId` class and define it as an `TargetEntityId` in the `SubscribeStudent` command.

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/write/subscribestudent/SubscriptionId.java
----
package io.axoniq.demo.university.faculty.write.subscribestudent;

import io.axoniq.demo.university.faculty.write.CourseId;
import io.axoniq.demo.university.faculty.write.StudentId;

record SubscriptionId(CourseId courseId, StudentId studentId) {

}

----

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/write/subscribestudent/SubscribeStudent.java
----
package io.axoniq.demo.university.faculty.write.createcourse;

import io.axoniq.demo.university.faculty.write.StudentId;
import io.axoniq.demo.university.faculty.write.CourseId;

public record SubscribeStudent(StudentId studentId, CourseId courseId) {

    @TargetEntityId
    private SubscriptionId subscriptionId() { // <1>
        return new SubscriptionId(courseId, studentId);
    }

}
----
<1> The `@TargetEntityId` annotated method/property can be even private, because it's just for internal usage for the Axon Framework.


As you see there are two TODOs left in the `SubscribeStudentCommandHandler` code.
Now we need to validate business rules, there are a few of them.
The student can subscribe to course only if adhere to the domain invariants of this operation.
I will list them one by one with assertion function, and we will also see what you need in the State object to validate them.

**Rule #1: The student is enrolled in the faculty **

When student is enrolled it has assigned it, so we add it to the State:

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/write/subscribestudent/SubscribeStudent.java
----
class SubscribeStudentCommandHandler {

    // rest omitted for brevity

    @EventSourcedEntity
    static class State {

        private StudentId studentId;

        @EventSourcingHandler
        void evolve(StudentEnrolledFaculty event) {
            this.studentId = new StudentId(event.studentId());
        }
    }

}
----

Business rule assertion function.
We throw an exception if the rule is not satisfied.

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/write/subscribestudent/SubscribeStudent.java
----
class SubscribeStudentCommandHandler {

    // rest omitted for brevity

    private void assertStudentEnrolledFaculty(State state) {
        var studentId = state.studentId;
        if (studentId == null) {
            throw new RuntimeException("Student with given id never enrolled the faculty");
        }
    }

}
----

**Rule #2: The course is created **
**Rule #3: The student is not already subscribed to the course **
**Rule #4: The student is not subscribed to too many courses **
**Rule #5: The course is not fully booked (based on course capacity) **

We're going to implement all the remaining rules and once.
What else do we need in the State object? Definitely not the course name, because it has nothing to do with the business rules.
What we need it's the minimal set of data we needed to be able to accept or reject the command. It's the same rule you use while designing DDD Aggregates.
So we are going to derive `alreadySubscribed` and `noOfCoursesStudentSubscribed` from `StudentSubscribed` and ``StudentUnsubscribed` events.

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/write/subscribestudent/SubscribeStudent.java
----
class SubscribeStudentCommandHandler {

    // rest omitted for brevity

    @EventSourcedEntity
    static class State {

        private CourseId courseId;
        private int courseCapacity = 0;
        private int noOfStudentsSubscribedToCourse = 0;

        private StudentId studentId;
        private int noOfCoursesStudentSubscribed = 0;
        private boolean alreadySubscribed = false;

        // other handlers added previously omitted for brevity

        @EventSourcingHandler
        void evolve(CourseCreated event) { // <1>
            this.courseId = new CourseId(event.courseId());
            this.courseCapacity = event.capacity();
        }

        @EventSourcingHandler
        void evolve(CourseCapacityChanged event) { // <2>
            this.courseCapacity = event.capacity();
        }

        @EventSourcingHandler
        void evolve(StudentSubscribed event) { // <3>
            var subscribingStudentId = new StudentId(event.studentId());
            var subscribedCourseId = new CourseId(event.courseId());
            if(subscribedCourseId.equals(courseId)) { // <4>
                noOfStudentsSubscribedToCourse++;
            }
            if (subscribingStudentId.equals(studentId)) { // <5>
                noOfCoursesStudentSubscribed++;
            }
            if (subscribingStudentId.equals(studentId) && subscribedCourseId.equals(courseId)) { // <6>
                alreadySubscribed = true;
            }
        }

        @EventSourcingHandler
        void evolve(StudentUnsubscribed event) { // <7>
            var subscribingStudentId = new StudentId(event.studentId());
            var subscribedCourseId = new CourseId(event.courseId());
            if(subscribedCourseId.equals(courseId)) {
                noOfStudentsSubscribedToCourse--;
            }
            if (subscribingStudentId.equals(studentId)) {
                noOfCoursesStudentSubscribed--;
            }
            if (subscribingStudentId.equals(studentId) && subscribedCourseId.equals(courseId)) {
                alreadySubscribed = false;
            }
        }
    }

}
----
<1> Same as with student, we store the `courseId` if was created along with the `capacity` from the same `CourseCreated` event.
<2> We update the `capacity` on `CourseCapacityChanged` event.
<3> In this case we're going to evolve the State on every `StudentSubscribed` event related to the course or the student which ids are in the command. How we instruct the store to load those events we will discuss in the next paragraph. For now you need to be aware of you may receive events about different student and different course as well.
<4> If the `StudentSubscribed` event is related to the course, we increase the number of students subscribed to the course.
<5> If the `StudentSubscribed` event is related to the student, we increase the number of courses the student is subscribed to.
<6> If the `StudentSubscribed` event is related to the course and the student, we set the `alreadySubscribed` flag to true.
<7> This handler for `StudentUnsubscribed` is an exact opposite of the `evolve` method for `StudentSubscribed` event. We decrease the numbers which we increased in the previous one.

But how do we limit that we won't receive events for every student and every course? It's where the `EventCriteria` comes into play.

== Event Criteria

While implementing the `CreateCourse` feature we defined that we want to build our state based on event's that are tagged with `courseId` by using this `@EventSourcedEntity(tagKey = "courseId")`.
For the `SubscribeStudent` handling, it's not enough, because as you already know we need to build our state based on `studentId` and `courseId` tagged events.
We need all `StudentSubscribed` events for the given `courseId` and also all `StudentSubscribed` events for the given `studentId`.
As well as `StudentUnsubscribed` events.
Whereas for example `StudentEnrolledFaculty` - we care about just one event for the given `studentId`, other students are not interested while processing this command and there are no business rules between them. With the subscription story is different, because of that we have a limit of students per course and also the limit of courses per student.

Thanks to the Axon Framework `EventCriteria` concept we're able to define the events we'd like to load dynamically.
It's where the Dynamic Consistency Boundary shines.

[NOTE]
====
For Axon Framework 4 users:
Before we had to load all events for the given aggregate (from the event stream). We were defining the "tag" of events by using the `@TargetAggregateIdentifier` annotation.
Since Axon Framework 5 we can load events that are relevant for the given command using custom criteria (you choose event types and tags).
You may think about that before event could have just one tag - the aggregateId, but now we can have multiple tags for the same event.
====

Here the situation is a bit more complicated, because we need to load events for two different entities - `Student` and `Course`.
In the system based on Aggregates you may load both and limit your accessibility - the risk of optimistic concurrency is higher, or do complex saga between those two entities - then you also need to duplicate the events.
But in domain experts language it's just one fact, which influences rules around Student and Course.
As far as we're in the single bounded context, and we have all events in one storage, we good to go and define our custom Event Criteria!

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/write/subscribestudent/SubscribeStudent.java
----
class SubscribeStudentCommandHandler {

    // rest omitted for brevity

    @EventSourcedEntity
    static class State {

        // rest omitted for brevity

        @EventCriteriaBuilder // <1>
        private static EventCriteria resolveCriteria(SubscriptionId id) { // <2>
            var courseId = id.courseId().raw();
            var studentId = id.studentId().raw();
            return EventCriteria.either(
                    EventCriteria.match()
                                 .eventsOfTypes(
                                         CourseCreated.class.getName(),
                                         CourseCapacityChanged.class.getName()
                                 ).withTags(Tag.of("courseId", courseId)),
                    EventCriteria.match()
                                 .eventsOfTypes(StudentEnrolledFaculty.class.getName())
                                 .withTags(Tag.of("studentId", studentId)),
                    EventCriteria.match()
                                 .eventsOfTypes(
                                         StudentSubscribed.class.getName(),
                                         StudentUnsubscribed.class.getName()
                                 ).withTags(Tag.of("courseId", courseId)), // <3>
                    EventCriteria.match()
                                 .eventsOfTypes(
                                         StudentSubscribed.class.getName(),
                                         StudentUnsubscribed.class.getName()
                                 ).withTags(Tag.of("studentId", studentId))
            );
        }
    }

}
----
<1> The `@EventCriteriaBuilder` annotation marks the method as a criteria builder for the given entity. It gives you more flexibility than just using `tagKey` property on the `@EventSourcedEntity` annotation.
<2> Thanks to the `SubscriptionId` which is composed of `courseId` and `studentId` we know the values of those tags we needed.
<3> As you may see at the highest level those `EventCriteria` are combined with `either` method, but when we define tags in `withTags` it means that the certain type of event requires all of them. So, we split `StudentSubscribed` and `StudentUnsubscribed` events into two separate criteria, because we need to load all events of those type for the given `courseId` and `studentId`.

It gives us better accessibility of our system - thanks to that, as you see there is no `CourseRenamed` event in our criteria, so the Faculty administrator is still able to rename the course in the same time while processing the `SubscribeStudent` command.
In case of Aggregates those operation may clash, or you need to introduce separated entity for the name if you want to avoid concurrency access issues.
Our colleague Milan from AxonIQ (with our ex-colleague Sara) discuss those scenarios in the talk - we really encourage you to watch it

[NOTE]
====
Keep in mind it's beneficial to define events types in the criteria.
Technically you can just use `EventCriteria.match().eventsOfTypes(...)` and load all events for the given tag.
But in this case you load more than needed, and it's more possible to clash with other changes, which cause events that do not influence this certain business rules.
====

== Summing up

Let's summarize what we have done so far.
You've implemented the whole `SubscribeStudent` command handler using the DCB concept in practice. It was easier than you expected, right?
If you're not sure if you followed the tutorial correctly, you can always check the code in the repository. The command handler code is here link:https://github.com/AxonIQ/university-demo/blob/master/src/main/java/io/axoniq/demo/university/faculty/write/subscribestudent/SubscribeStudentCommandHandler.java[SubscribeStudentCommandHandler].
If you prefer to use different style (with multiple state classes - like `Course` and `Student` instead of just one) you may also compare the solution we have done with the code in the package link:https://github.com/AxonIQ/university-demo/tree/master/src/main/java/io/axoniq/demo/university/faculty/write/subscribestudentmulti[subscribestudentmulti].

== Configuration
Same as before to make our tests green the last thing to co it to configure the require infrastructure for the command handler.
To do so let's create a new class `SubscribeStudentConfiguration` with following content.

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/write/createcourse/CreateCourseConfiguration.java
----
package io.axoniq.demo.university.faculty.write.subscribestudent;

import org.axonframework.configuration.NewConfiguration;
import org.axonframework.eventsourcing.configuration.EventSourcedEntityBuilder;
import org.axonframework.eventsourcing.configuration.EventSourcingConfigurer;
import org.axonframework.modelling.StateManager;
import org.axonframework.modelling.configuration.StatefulCommandHandlingModule;

import java.util.List;

public class SubscribeStudentConfiguration {

    public static EventSourcingConfigurer configure(EventSourcingConfigurer configurer) {
        var stateEntity = EventSourcedEntityBuilder
                .annotatedEntity(SubscriptionId.class, SubscribeStudentCommandHandler.State.class);
        var commandHandlingModule = StatefulCommandHandlingModule
                .named("SubscribeStudent")
                .entities()
                .entity(stateEntity)
                .commandHandlers()
                .annotatedCommandHandlingComponent(c -> new SubscribeStudentCommandHandler());
        return configurer.registerStatefulCommandHandlingModule(commandHandlingModule);
    }

}
----

Now we need to register the configuration in the `UniversityAxonApplication` class as follows.

[source,java]
./src/main/java/io/axoniq/demo/university/UniversityAxonApplication.java
----
public class UniversityAxonApplication {

    public static ApplicationConfigurer<?> configurer() {
        var configurer = EventSourcingConfigurer.create();
        configurer = CreateCourseConfiguration.configure(configurer);
        configurer = SubscribeStudentConfiguration.configure(configurer); // <1>
        return configurer;
    }

    // rest omitted for brevity

}
----
<1> We register the `StatefulCommandHandlingModule` as a child of the `EventSourcingConfigurer`.

Now what is better to developer that beeing flashed by the green bar in your IDE after running the tests?
Let's do it! Don't forget to mark the slice as completed in the Event Modeling diagram if you use this approach.


== Your opinion matters!
Thank you for reading this tutorial!
We hope you enjoyed the new APIs, and you're looking forward for the Axon Framework 5 release.
You have also an opportunity to influence the future of the framework and help revolutionize the way people build applications.
If you'd like to do so please share your feedback with us. You can do it on Discuss [TBD FORM LINK] or reach out to our Framework team directly on LinkedIn.
We are looking forward to your opinion, and we will be happy to discuss your ideas with you.