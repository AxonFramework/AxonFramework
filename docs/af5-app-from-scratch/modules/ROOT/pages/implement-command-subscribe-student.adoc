:navtitle: Feature: Subscribe Student
:reftext: Implementing the subscribe student feature

One of the major benefits of Axon Framework 5's Vertical Slice Architecture is the ability to implement features independently.
Now we'll implement the `SubscribeStudent` feature without needing to implement every feature in between.
As long as we keep the `State` needed for command validation private to each slice, the only shared code between slices are the events, which serve as the backbone contract of our system.

You even don't need to stick to certain order. How many times have you heard in the development team: "I'm waiting till the feature X is implemented, so I can implement my feature Y"?


== Define messages

As before, let's look at the Event Modeling diagram.
Which events do we need for this slice to fulfill the following Given-When-Then specification?

image::EventModeling_GWT_SubscribeStudent.png[]

In previous section we've defined the `CourseCreated` events, so there are two left from the specification.
Let's define them as Java records, as before.

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/events/StudentSubscribed.java
----
package io.axoniq.demo.university.faculty.events;

import org.axonframework.eventsourcing.annotations.EventTag;

public record StudentEnrolledFaculty(
        @EventTag // <1>
        String studentId,
        String firstName,
        String lastName
) {

}
----

<.> Always remember about marking which properties are event tags.

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/events/StudentSubscribed.java
----
package io.axoniq.demo.university.faculty.events;

import org.axonframework.eventsourcing.annotations.EventTag;

public record StudentSubscribed(
        @EventTag // <1>
        String studentId,
        @EventTag // <1>
        String courseId
) {
}
----

<.> Thanks to those annotations the event will be tagged with `studentId` and `courseId`.
It's a good example that StudentSubscribed event is connected to two business entitiesâ€”Student and the Course.
When domain experts say that "student subscribed", they know that means the course free spots decreased and also student subscription limit may be reached.
In the case of one event type per entity/tag/aggregateId we would need to duplicate those events artificially to have two in two different streams.

Last, but not least, we define the `SubscribeStudent` command.

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/write/subscribestudent/SubscribeStudent.java
----
package io.axoniq.demo.university.faculty.write.createcourse;

import io.axoniq.demo.university.faculty.write.StudentId;
import io.axoniq.demo.university.faculty.write.CourseId;

public record SubscribeStudent(StudentId studentId, CourseId courseId) {
}
----

== Specification by example

As you remember from the previous section, we do not focus on entities but on behavior.
So we're going to describe our feature in a Given-When-Then manner based on commands and events.
Let's create the first test case using Axon Test Fixture.

We're going to translate the Event Modeling specification, which you've seen on the top of the page + other test cases for this slice, to the code.
We call it Test First, we don't use TDD to design our application, but we do the design on the whiteboard using Event Modeling, which is faster and much less expensive than in the code.
From Event Modeling we can derive the test cases for specific slice (functionality) and translate them directly to the code.
The Axon Framework supports the Given-When-Then convention pretty well.

NOTE: Translating Event Modeling specification to test is a repeatable task, so it can be even done automatically with the help of AI.

 The Subscribe Student feature has several business rules which you may derive from the Event Modeling GWTs:

1. The student must be enrolled in the faculty
2. The course must exist
3. The student should not yet be subscribed to the course
4. The student must not be subscribed to too many courses (limit: 3)
5. The course must not be at full capacity

Let's create tests for these scenarios.

[source,java]
.src/test/java/io/axoniq/demo/university/faculty/write/subscribestudent/SubscribeStudentTest.java
----
package io.axoniq.demo.university.faculty.write.createcourse;

import java.util.UUID;

class SubscribeStudentTest {

    private AxonTestFixture fixture;

    @BeforeEach
    void beforeEach() {
        fixture = AxonTestFixture.with(UniversityAxonApplication.configurer());
    }

    @Test
    void successfulSubscription() {
        var courseId = CourseId.random();
        var studentId = StudentId.random();

        fixture.given()
               .event(new CourseCreated(courseId.raw(), "Event Sourcing in Practice", 2))
               .event(new StudentEnrolledFaculty(studentId.raw(), "Mateusz", "Nowak"))
               .when()
               .command(new SubscribeStudent(studentId, courseId))
               .then()
               .events(new StudentSubscribed(studentId.raw(), courseId.raw()));
    }

    @Test
    void studentAlreadySubscribed() {
        var courseId = CourseId.random();
        var studentId = StudentId.random();

        fixture.given()
               .event(new StudentEnrolledFaculty(studentId.raw(), "Allard", "Buijze"))
               .event(new CourseCreated(courseId.raw(), "Axon Framework 5: Be a PRO", 2))
               .event(new StudentSubscribed(studentId.raw(), courseId.raw()))
               .when()
               .command(new SubscribeStudent(studentId, courseId))
               .then()
               .exception(RuntimeException.class, "Student already subscribed to this course");
    }

    @Test
    void courseFullyBooked() {
        var courseId = CourseId.random();
        var student1Id = StudentId.random();
        var student2Id = StudentId.random();
        var student3Id = StudentId.random();

        fixture.given()
               .event(new StudentEnrolledFaculty(student1Id.raw(), "Mateusz", "Nowak"))
               .event(new StudentEnrolledFaculty(student2Id.raw(), "Steven", "van Beelen"))
               .event(new StudentEnrolledFaculty(student3Id.raw(), "Mitchell", "Herrijgers"))
               .event(new CourseCreated(courseId.raw(), "Event Sourcing Masterclass", 2))
               .event(new StudentSubscribed(student1Id.raw(), courseId.raw()))
               .event(new StudentSubscribed(student2Id.raw(), courseId.raw()))
               .when()
               .command(new SubscribeStudent(student3Id, courseId))
               .then()
               .exception(RuntimeException.class, "Course is fully booked");
    }

    @Test
    void studentSubscribedToTooManyCourses() {
        var studentId = StudentId.random();
        var course1Id = CourseId.random();
        var course2Id = CourseId.random();
        var course3Id = CourseId.random();
        var targetCourseId = CourseId.random();

        fixture.given()
                .event(new StudentEnrolledFaculty(studentId.raw(), "Milan", "Savic"))
                .event(new CourseCreated(targetCourseId.raw(), "Programming", 10))
                .event(new CourseCreated(course1Id.raw(), "Course 1", 10))
                .event(new CourseCreated(course2Id.raw(), "Course 2", 10))
                .event(new CourseCreated(course3Id.raw(), "Course 3", 10))
                .event(new StudentSubscribed(studentId.raw(), course1Id.raw()))
                .event(new StudentSubscribed(studentId.raw(), course2Id.raw()))
                .event(new StudentSubscribed(studentId.raw(), course3Id.raw()))
                .when()
                .command(new io.axoniq.demo.university.faculty.write.subscribestudentmulti.SubscribeStudent(studentId, targetCourseId))
                .then()
                .noEvents()
                .exceptionSatisfies(thrown -> assertThat(thrown)
                        .isInstanceOf(RuntimeException.class)
                        .hasMessage("Student subscribed to too many courses")
                );
    }

}
----

These tests demonstrate the behavior we want to implement, checking both successful and error cases.
To those tests we need to implement the command handler for `SubscribeStudent` command.
As you've seen before, for the behavior which is based on some state (so we have something in a Given phase of the test), we need to have State for our command handler to validate commands against it.
Let's make it right away!

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/write/subscribestudent/SubscribeStudent.java
----
package io.axoniq.demo.university.faculty.write.subscribestudent;

class SubscribeStudentCommandHandler {

    private static final int MAX_COURSES_PER_STUDENT = 3; // <1>

    @CommandHandler
    void handle(
            SubscribeStudent command,
            @InjectEntity State state, // <2>
            EventSink eventSink,
            ProcessingContext processingContext
    ) {
        var events = decide(command, state); // <3>
        var messages = toMessages(events); // <4>
        eventSink.publish(processingContext, messages); // <5>
    }

    private List<StudentSubscribed> decide(SubscribeStudent command, State state) {
        // todo: check business rules
        return List.of(new StudentSubscribed(command.studentId().raw(), command.courseId().raw()));
    }

    private static List<EventMessage<?>> toMessages(List<StudentSubscribed> events) {
        return events.stream()
                     .map(SubscribeStudentCommandHandler::toMessage)
                     .collect(Collectors.toList());
    }

    private static EventMessage<?> toMessage(Object payload) {
        return new GenericEventMessage<>(
                new MessageType(payload.getClass()),
                payload
        );
    }

    @EventSourcedEntity // <6>
    static class State {
        // todo: define state necessary to accept or reject `SubscribeStudent` command
    }

}
----

<1> For the sample simplicity, we hardcoded the maximum number of courses per student.
Each student can subscribe up to 3 courses at the same time.
<2> We use `@InjectEntity` to inject the state object.
<3> This is your domain model invocation.
You may keep it in the command handler as on the example or make the function unaware of the infrastructure like Axon Framework.
This functional resembles the `Decider` pattern.
<4> As before, we translate events (which are a result of our domain function) to messages to be able to publish them.
<5> We use `EventSink` to publish events.
<6> Before we defined `tagKey` in `@EventSourcedEntity` annotation, now we cannot do that, because we require events about every subscription of a student and every subscription to the course, so we have multiple business concepts related to a business process.
In a few paragraphs you will see how to do that with the `EventCriteria` API.


We always need single, unique identifier to load the state, because the `@InjectEntity` annotation needs to know how to identify the entity to load.
In this case it's more difficult, because the `SubscribeStudent` business process is identified by the command type and also the `courseId` and `studentId`.
When you subscribe to the course to valid business rules you need to be aware of all the subscriptions for the given course and all subscriptions for the given student.
So similar like in the traditional databases, we need to introduce a type for composite key to identify the entity.
We're going to use the `SubscriptionId` class and define it as an `TargetEntityId` in the `SubscribeStudent` command.

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/write/subscribestudent/SubscriptionId.java
----
package io.axoniq.demo.university.faculty.write.subscribestudent;

import io.axoniq.demo.university.faculty.write.CourseId;
import io.axoniq.demo.university.faculty.write.StudentId;

record SubscriptionId(CourseId courseId, StudentId studentId) {

}

----

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/write/subscribestudent/SubscribeStudent.java
----
package io.axoniq.demo.university.faculty.write.createcourse;

import io.axoniq.demo.university.faculty.write.StudentId;
import io.axoniq.demo.university.faculty.write.CourseId;

public record SubscribeStudent(StudentId studentId, CourseId courseId) {

    @TargetEntityId
    private SubscriptionId subscriptionId() { // <1>
        return new SubscriptionId(courseId, studentId);
    }

}
----
<1> The `@TargetEntityId` annotated method/property can be even private, because it's just for internal usage for the Axon Framework.
Based on the `SubscriptionId` we can load the events to build the `State` object, we will use the value to define the `EventCriteria` later in this section.

As you see there are two TODOs left in the `SubscribeStudentCommandHandler` code.
Now we need to validate business rules, there are a few of them.
The student can subscribe to course only if adhere to the domain invariants of this operation.
I will list them belong along with assertion function, and we will also see what you need in the State object to validate them.

**Rule #1: The student is enrolled in the faculty **

When student is enrolled the faculty it has assigned `StudentId`, so we add it to the State:

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/write/subscribestudent/SubscribeStudent.java
----
class SubscribeStudentCommandHandler {

    // rest omitted for brevity

    @EventSourcedEntity
    static class State {

        private StudentId studentId;

        @EventSourcingHandler
        void evolve(StudentEnrolledFaculty event) {
            this.studentId = new StudentId(event.studentId());
        }
    }

}
----

In the business rule assertion function, we throw an exception if the rule is not satisfied.
It's another approach than presented before.
This error will buble up as a result of the command to the client.

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/write/subscribestudent/SubscribeStudent.java
----
class SubscribeStudentCommandHandler {

    // rest omitted for brevity

    private void assertStudentEnrolledFaculty(State state) {
        var studentId = state.studentId;
        if (studentId == null) {
            throw new RuntimeException("Student with given id never enrolled the faculty");
        }
    }

}
----

**Rule #2: The course is created **
**Rule #3: The student is not already subscribed to the course **
**Rule #4: The student is not subscribed to too many courses (max 3) **
**Rule #5: The course is not fully booked (based on course capacity) **

We're going to implement all the remaining rules at once.
What else do we need in the `State` object to validate them?
Definitely not the course name, because it has nothing to do with the business rules.
What we'd like to introduce it's the minimal set of data we needed to be able to accept or reject the command.
It's the same rule of thumb, that you use while designing DDD Aggregates.

So we are going to derive:
- for Student: `alreadySubscribed` and `noOfCoursesStudentSubscribed` from `StudentSubscribed` and ``StudentUnsubscribed` events.
- for Course: `courseCapacity` and `noOfStudentsSubscribedToCourse` from `CourseCreated`, `CourseCapacityChanged`, `StudentSubscribed` and `StudentUnsubscribed` events.

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/write/subscribestudent/SubscribeStudent.java
----
class SubscribeStudentCommandHandler {

    // rest omitted for brevity

    @EventSourcedEntity
    static class State {

        private CourseId courseId;
        private int courseCapacity = 0;
        private int noOfStudentsSubscribedToCourse = 0;

        private StudentId studentId;
        private int noOfCoursesStudentSubscribed = 0;
        private boolean alreadySubscribed = false;

        // other handlers added previously omitted for brevity

        @EventSourcingHandler
        void evolve(CourseCreated event) { // <1>
            this.courseId = new CourseId(event.courseId());
            this.courseCapacity = event.capacity();
        }

        @EventSourcingHandler
        void evolve(CourseCapacityChanged event) { // <2>
            this.courseCapacity = event.capacity();
        }

        @EventSourcingHandler
        void evolve(StudentSubscribed event) { // <3>
            var subscribingStudentId = new StudentId(event.studentId());
            var subscribedCourseId = new CourseId(event.courseId());
            if(subscribedCourseId.equals(courseId)) { // <4>
                noOfStudentsSubscribedToCourse++;
            }
            if (subscribingStudentId.equals(studentId)) { // <5>
                noOfCoursesStudentSubscribed++;
            }
            if (subscribingStudentId.equals(studentId) && subscribedCourseId.equals(courseId)) { // <6>
                alreadySubscribed = true;
            }
        }

        @EventSourcingHandler
        void evolve(StudentUnsubscribed event) { // <7>
            var subscribingStudentId = new StudentId(event.studentId());
            var subscribedCourseId = new CourseId(event.courseId());
            if(subscribedCourseId.equals(courseId)) {
                noOfStudentsSubscribedToCourse--;
            }
            if (subscribingStudentId.equals(studentId)) {
                noOfCoursesStudentSubscribed--;
            }
            if (subscribingStudentId.equals(studentId) && subscribedCourseId.equals(courseId)) {
                alreadySubscribed = false;
            }
        }
    }

}
----
<1> Same as with student, we store the `courseId` if was created along with the `capacity` from the same `CourseCreated` event.
<2> We update the `capacity` on `CourseCapacityChanged` event.
<3> In this case we're going to evolve the State on every `StudentSubscribed` event related to the course or the student which ids are in the command.
How we instruct the store to load those events we will discuss in the next paragraph.
For now you need to be aware of that you may receive events about different student and different course as well, because we have one event handler per event type -> we handle there all `StudentSubscribed/Unsubscribed` for given course (different students) to know how much capacity left and all for given student (different courses) to know how many courses the student is subscribed to.
<4> If the `StudentSubscribed` event is related to the course, we increase the number of students subscribed to the course.
<5> If the `StudentSubscribed` event is related to the student, we increase the number of courses the student is subscribed to.
<6> If the `StudentSubscribed` event is related to the course and the student, we set the `alreadySubscribed` flag to true.
<7> This handler for `StudentUnsubscribed` is an exact opposite of the `evolve` method for `StudentSubscribed` event. We decrease the numbers which we increased in the previous one.

But how do we limit that we won't receive events for every student and every course?
How do we limit our Consistency Boundary to only what is really needed to valite business rules.
It's where the `EventCriteria` comes into play.

== Event Criteria

While implementing the `CreateCourse` feature, we defined that we want to build our state based on events that are tagged with `courseId` by using `@EventSourcedEntity(tagKey = "courseId")`.
For the `SubscribeStudent` handling, this is not enough, because as you already know, we need to build our state based on both `studentId` and `courseId` tagged events.
We need all `StudentSubscribed` events for the given `courseId` and also all `StudentSubscribed` events for the given `studentId`.
The same applies to `StudentUnsubscribed` events.

Whereas, for example with `StudentEnrolledFaculty` - we care about just one event for the given `studentId`; other students are not involved while processing this command, and there are no business rules between them.
The subscription story is different, because we have a limit of students per course and also a limit of courses per student.

Thanks to the Axon Framework's `EventCriteria` concept, we're able to define the events we'd like to load dynamically.
This is where the Dynamic Consistency Boundary shines.

[NOTE]
====
For Axon Framework 4 users:
Before we had to load all events for the given aggregate (from the event stream). We were defining the "tag" of events by using the `@TargetAggregateIdentifier` annotation.
Since Axon Framework 5 we can load events that are relevant for the given command using custom criteria (you choose event types and tags).
You may think about that in such way: before event could have just one tag - the aggregateId, but now we can have multiple tags for the same event.
====

Here the situation is a bit more complicated, because we need to load events for two different entities - `Student` and `Course`.
In a system based on Aggregates, you may load both and limit your accessibility - the risk of optimistic concurrency is higher, or implement a complex saga between those two entities - then you also need to duplicate the events and deal with eventual consistency.
But in domain experts' language, `StudentSubscribed` is just one fact, which influences rules around both `Student` and `Course`.

As long as we're in a single bounded context and have all events in one storage, we can define our custom `EventCriteria` to shape our `State` which mixes properties for `Student` and `Course`!
The operation will be also immediate consistent and transactional.
If while executing the operation any event matching the same `EventCriteria` is stored, the operation will fail with an optimistic concurrency exception.
The single responsibility of the State is just to give us enough information to determine if the command satisfies business rules.

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/write/subscribestudent/SubscribeStudent.java
----
class SubscribeStudentCommandHandler {

    // rest omitted for brevity

    @EventSourcedEntity
    static class State {

        // rest omitted for brevity

        @EventCriteriaBuilder // <1>
        private static EventCriteria resolveCriteria(SubscriptionId id) { // <2>
            var courseId = id.courseId().raw();
            var studentId = id.studentId().raw();

            return EventCriteria.either(
                    EventCriteria.match()
                            .eventsOfTypes(
                                    CourseCreated.class.getName(),
                                    CourseCapacityChanged.class.getName(),
                                    StudentSubscribed.class.getName(),
                                    StudentUnsubscribed.class.getName()
                            ).withTags(Tag.of("courseId", courseId)), // <3>
                    EventCriteria.match()
                            .eventsOfTypes(
                                    StudentEnrolledFaculty.class.getName(),
                                    StudentSubscribed.class.getName(),
                                    StudentUnsubscribed.class.getName()
                            ).withTags(Tag.of("studentId", studentId))
            );
        }
    }

}
----
<1> The `@EventCriteriaBuilder` annotation marks the method as a criteria builder for the given entity. It gives you more flexibility than just using `tagKey` property on the `@EventSourcedEntity` annotation.
<2> Thanks to the `SubscriptionId` which is composed of `courseId` and `studentId` we know the values of those tags we needed.
<3> As you may see at the highest level those `EventCriteria` are combined with `either` method, but when we define tags in `withTags` it means that the certain type of event requires all of them (there is an OR relation between event types, an AND relation between tags and OR between criteria).
If we do `.withTags(Tag.of("courseId", courseId), Tag.of("studentId", studentId))` we will receive just subscription event of the given student for just one given course.
It's not what we wanted here.
So, we split `StudentSubscribed` and `StudentUnsubscribed` events into two separate criteria (one for student and one for course), because we need to load all events of those types for either `courseId` or `studentId`.

It gives us better accessibility of our system - thanks to that, as you see there is no `CourseRenamed` event in our criteria, so the Faculty administrator is still able to rename the course in the same time while processing the `SubscribeStudent` command, because the `CourseRenamed` event doesn't match the criteria - it's not in our operation consistency boundary.
In case of Aggregates those operation may clash, or you need to introduce separated entity for the name if you want to avoid concurrency access issues.
Our colleague Milan from AxonIQ (with our ex-colleague Sara) discuss those scenarios in the talk - we really encourage you to watch it link:https://www.youtube.com/watch?v=IgigmuHHchI[The Aggregate is dead. Long live the Aggregate! by Sara Pellegrini & Milan Savic @ Spring I/O 2023].

[NOTE]
====
Keep in mind it's beneficial to define events types in the criteria.
Technically you can just use `EventCriteria.match().eventsOfTypes(...)` and load all events for the given tag.
But in this case you load more than needed, and it's more possible to clash with other changes, which cause events that do not influence this certain business rules.
====

== Summing up

Let's summarize what we have done so far.
You've implemented the whole `SubscribeStudent` command handler using the DCB concept in practice. It was easier than you expected, right?
If you're not sure if you followed the tutorial correctly, you can always check the code in the repository. The command handler code is here link:https://github.com/AxonIQ/university-demo/blob/master/src/main/java/io/axoniq/demo/university/faculty/write/subscribestudent/SubscribeStudentCommandHandler.java[SubscribeStudentCommandHandler].
If you prefer to use different style (with multiple state classes - like `Course` and `Student` instead of just one) you may also compare the solution we have done with the code in the package link:https://github.com/AxonIQ/university-demo/tree/master/src/main/java/io/axoniq/demo/university/faculty/write/subscribestudentmulti[subscribestudentmulti].

== Configuration
Same as before to make our tests green the last thing to co it to configure the require infrastructure for the command handler.
To do so let's create a new class `SubscribeStudentConfiguration` with following content.

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/write/createcourse/CreateCourseConfiguration.java
----
package io.axoniq.demo.university.faculty.write.subscribestudent;

import org.axonframework.configuration.NewConfiguration;
import org.axonframework.eventsourcing.configuration.EventSourcedEntityBuilder;
import org.axonframework.eventsourcing.configuration.EventSourcingConfigurer;
import org.axonframework.modelling.StateManager;
import org.axonframework.modelling.configuration.StatefulCommandHandlingModule;

import java.util.List;

public class SubscribeStudentConfiguration {

    public static EventSourcingConfigurer configure(EventSourcingConfigurer configurer) {
        var stateEntity = EventSourcedEntityBuilder
                .annotatedEntity(SubscriptionId.class, SubscribeStudentCommandHandler.State.class);
        var commandHandlingModule = StatefulCommandHandlingModule
                .named("SubscribeStudent")
                .entities()
                .entity(stateEntity)
                .commandHandlers()
                .annotatedCommandHandlingComponent(c -> new SubscribeStudentCommandHandler());
        return configurer.registerStatefulCommandHandlingModule(commandHandlingModule);
    }

}
----

Now we need to register the configuration in the `UniversityAxonApplication` class as follows.

[source,java]
./src/main/java/io/axoniq/demo/university/UniversityAxonApplication.java
----
public class UniversityAxonApplication {

    public static ApplicationConfigurer<?> configurer() {
        var configurer = EventSourcingConfigurer.create();
        configurer = CreateCourseConfiguration.configure(configurer);
        configurer = SubscribeStudentConfiguration.configure(configurer); // <1>
        return configurer;
    }

    // rest omitted for brevity

}
----
<1> We register the `StatefulCommandHandlingModule` as a child of the `EventSourcingConfigurer`.

Now what is better to developer that beeing flashed by the green bar in your IDE after running the tests?
Let's do it! Don't forget to mark the slice as completed in the Event Modeling diagram if you use this approach.


== Your opinion matters!
Thank you for reading this tutorial!
We hope you enjoyed the new APIs, and you're looking forward for the Axon Framework 5 release.
You have also an opportunity to influence the future of the framework and help revolutionize the way people build applications.
If you'd like to do so please share your feedback with us. You can do it on Discuss [TBD FORM LINK] or reach out to our Framework team directly on LinkedIn.
We are looking forward to your opinion, and we will be happy to discuss your ideas with you.