= Subscribing Event Processor

The `SubscribingEventProcessor`, or Subscribing Processor for short, is a type of xref:event-processors/index.adoc[Event Processor].
As any Event Processor, it serves as the technical aspect to handle events by invoking the event handlers written in an Axon application.

The Subscribing Processor defines itself by receiving the events from a `SubscribableMessageSource`.
The `SubscribableMessageSource` is an infrastructure component to register a Subscribing Processor too.

After registration to the `SubscribableMessageSource`, the message source gives the events to the `SubscribingEventProcessor` in the order they are received.
Examples of a `SubscribableMessageSource` are the `EventBus` or the xref:amqp-extension-reference::index.adoc[AMQP Extension].
Both the `EventBus` and the AMQP Extension are simple message bus solutions for events.

The simple bus solution makes the `SubscribableMessageSource` and thus the Subscribing Processor an approach to only receive _current_ events.
Operations like xref:event-processors/streaming.adoc#replaying-events[replaying] are, therefore, not an option for any Subscribing Processor as long as the `SubscribableMessageSource` follows this paradigm.

== Event handling with `ProcessingContext`

Like all event processors, the Subscribing Event Processor provides a xref:messaging-concepts:processing-context.adoc[ProcessingContext] to event handlers.
The `ProcessingContext` is created automatically by the framework and provides:

* Storage of xref:messaging-concepts:message-correlation.adoc[correlation data] for use by dispatch interceptors
* Lifecycle callbacks for cleanup actions
* Resource management for the current processing cycle

Event handlers can inject the `ProcessingContext` as a parameter for lifecycle management and to ensure proper correlation when dispatching commands:

[source,java]
----
@EventHandler
public void on(OrderPlacedEvent event,
               ProcessingContext context,
               CommandDispatcher<Object> commandDispatcher) {
    // Register cleanup actions
    context.onComplete(() -> {
        // Cleanup after successful processing
    });

    // CommandDispatcher automatically uses the ProcessingContext
    // to propagate correlation data to dispatched commands
    commandDispatcher.dispatch(new ShipOrderCommand(event.getOrderId()));
}
----

When using a `CommandGateway` instead of a `CommandDispatcher`, you must explicitly pass the `ProcessingContext` to ensure correlation data is propagated:

[source,java]
----
@EventHandler
public void on(OrderPlacedEvent event,
               ProcessingContext context,
               CommandGateway commandGateway) {
    // Must pass ProcessingContext explicitly when using CommandGateway
    commandGateway.send(new ShipOrderCommand(event.getOrderId()), context);
}
----

The Subscribing Event Processor processes events sequentially in the order they are received from the message source.
Since the processor handles events as they are pushed by the source, it does not support parallel processing within a single processor instance.

Most scenarios require higher throughput and parallelization capabilities, which is why the `SubscribingEventProcessor` is not the default in Axon Framework.

Instead, the "Pooled Streaming Event Processor" (a xref:event-processors/streaming.adoc[Streaming Processor] implementation) takes up that role.
The pull-based model allows it to use dedicated worker thread pools for parallel processing and provides event replay capabilities.

____

*Subscribing Processor Use Cases*

Although the `SubscribingEventProcessor` does not support easy parallelization or replays, there are still scenarios when it is beneficial:

* **Low-latency requirements**: The push model can reduce latency when immediate event processing is needed
* **Simple event flows**: When event processing is straightforward and doesn't require high throughput
* **External message sources**: In combination with Axon's xref:amqp-extension-reference::index.adoc[AMQP] or xref:kafka-extension-reference::index.adoc[Kafka] extensions, which provide their own threading and distribution mechanisms

____

[[configuring]]
== Configuring

The Subscribing Event Processor is used when no `StreamableEventSource` (Event Store) is available.
When you register event handlers and only an Event Bus is configured, they automatically use a Subscribing Event Processor.

To explicitly configure a specific Event Processor as a Subscribing instance, use the `subscribing` configurer:

[tabs]
====
Configuration API::
+
--
[source,java]
----
public class AxonConfig {
    // omitting other configuration methods...
    public void configureSubscribingProcessors(EventProcessingConfigurer processingConfigurer) {
        processingConfigurer
            .subscribing(subscribing ->
                subscribing
                    // Configure a specific processor with event handlers
                    .processor("my-processor", processor -> processor
                        .eventHandlingComponents(components -> components
                            .autodetected(cfg -> myEventHandler)
                        )
                        .notCustomized()
                    )
            );
    }
}
----
--

Spring Boot properties::
+
--
Spring Boot uses properties for event processor configuration.

[source,properties]
----
axon.eventhandling.processors.my-processor.mode=subscribing
axon.eventhandling.processors.my-processor.source=eventBus
----

If the name of an event processor contains periods `.`, use the map notation:

[source,properties]
----
axon.eventhandling.processors[my.processor].mode=subscribing
axon.eventhandling.processors[my.processor].source=eventBus
----
--
====

[[error-mode]]
== Error mode

Whenever the xref:event-processors/index.adoc#event-processor-error-handler[error handler] rethrows an exception, the `SubscribingEventProcessor` will have it bubble up to the publishing component of the event.
Providing the exception to the event publisher allows the publishing component to deal with it accordingly.

== Persistent streams

----

Persistent streams require Axon Server version 2024.1 or higher.

----

A Subscribing Processor can use a Persistent Stream as its message source.
By using a persistent stream we allow a Subscribing Processor to process events in parallel and to replay events.

When a processor uses a persistent stream, it receives events from Axon Server.
After processing (a batch of) events, it sends an acknowledgment back to Axon Server.

The persistent stream can be split in segments to allow for parallel processing within a single client or across multiple instances of the client.
The number of segments can be changed dynamically.
Axon Server distributes the segments across the subscribers to ensure that all segments are connected.

Events are assigned to a specific segment based on the sequencing policy for the persistent stream.
Persistent streams support all the standard sequencing policies that also can be used for xref:event-processors/streaming.adoc#sequencing-policies[streaming processors].

Clients can provide a filter in the persistent stream definition.
This reduces the number of events that the client receives from Axon Server.
The expression used to filter events are the same as expressions used in the ad-hoc query option in Axon Server.

Persistent streams do not require a token store in the client.
The state of the stream is maintained in Axon Server.

=== Configuration

For a specific Event Processor to use a persistent stream, configure it through the `subscribing` configurer with a `PersistentStreamMessageSource`.

Each persistent stream must be identified by a unique name within your Axon Server environment.
This name serves as the stream's identifier, and creating a new stream with an existing name will overwrite the previous stream connection.

The `PersistentStreamMessageSource` requires `PersistentStreamProperties` to set the initial properties:

* `streamName`: The unique name identifier of the persistent stream connection with Axon Server
* `segments`: The initial number of segments
* `sequencingPolicyName`: The sequencing policy name
* `sequencingPolicyParameters`: List of parameters for the sequencing policy
* `initialPosition`: First token to read
* `filter`: Filter for events on Axon Server side (use `null` to receive all events)

The `sequencingPolicyParameters` must be set if the sequencing policy is `PropertySequencingPolicy` or `MetadataSequencingPolicy`.

For `MetadataSequencingPolicy`, the `sequencingPolicyParameters` must contain the name of one or more event metadata fields.
Events with the same value for these fields are passed in the same segment.

For `PropertySequencingPolicy`, provide 4 values in `sequencingPolicyParameters`:

1. Serialization type: `JSON` or `XML`
2. Payload type to apply the policy on
3. Expression to extract the property value (`JsonPath` for JSON, `XPath` for XML)
4. Fallback policy name for when the payload type doesn't match

[tabs]
====
Configuration API::
+
--
[source,java]
----
public class AxonConfig {
    // omitting other configuration methods...
    public void configureSubscribingProcessors(EventProcessingConfigurer processingConfigurer) {
        String streamName = "my-persistent-stream-name";
        int segmentCount = 4;
        List<String> sequencingPolicyParameters = new ArrayList<>();
        String filter = null;
        int batchsize = 1024;

        PersistentStreamProperties persistentStreamProperties = new PersistentStreamProperties(
                streamName,
                segmentCount,
                PersistentStreamSequencingPolicyProvider.SEQUENTIAL_PER_AGGREGATE_POLICY,
                sequencingPolicyParameters,
                PersistentStreamProperties.HEAD_POSITION,
                filter
        );

        processingConfigurer
            .subscribing(subscribing ->
                subscribing.processor("my-processor", processor -> processor
                    .eventHandlingComponents(components -> components
                        .autodetected(cfg -> myEventHandler)
                    )
                    .customized((config, processorConfig) -> processorConfig
                        .eventSource(new PersistentStreamMessageSource(
                            streamName,
                            config,
                            persistentStreamProperties,
                            Executors.newScheduledThreadPool(4),
                            batchsize
                        ))
                    )
                )
            );
    }
}
----
--
====

==== Spring Boot - properties

Spring Boot uses properties for event processor configuration.

The source property for the processor must point to a Spring Bean which is a PersistentStreamMessageSource or a PersistentStreamMessageSourceDefinition.
This bean can also be defined in the properties file.

[source,text]
----
axon.eventhandling.processors.my-processor.mode=subscribing
axon.eventhandling.processors.my-processor.source=my-persistent-stream

axon.axonserver.persistent-streams.my-persistent-stream.name=My Persistent Stream
axon.axonserver.persistent-streams.my-persistent-stream.batch-size=100
axon.axonserver.persistent-streams.my-persistent-stream.initial-segment-count=4
----

To simplify configuration, if you want to apply persistent streams to all processing groups all you have to do is set property:

[source,text]
----
axon.axonserver.auto-persistent-streams-enable=true
----

This will configure persistent streams automatically for all processing groups with default settings.
Each persistent stream will be named according to the following pattern:

[source,text]
----
processingGroupName + "-stream"
----

You can also override default persistent stream settings

[source,text]
----
axon.axonserver.auto-persistent-streams-settings.batch-size=5
axon.axonserver.auto-persistent-streams-settings.thread-count=10
axon.axonserver.auto-persistent-streams-settings.initial-segment-count=10
----