= Dead-Letter Queue

[WARNING]
.Dead-Letter Queue support in Axon Framework 5.0 is under development
====
The documentation below describes the Dead-Letter Queue concepts for reference and future use.
The API may change before the Axon Framework 5.1 release.
====

When configuring xref:axon-framework-reference:events:event-processors/index.adoc#error-handling[error handling] for your event processors, you might want to consider a Dead-Letter Queue to park events that you were unable to handle.

Instead of either logging the error and continuing, or infinitely retrying the current event, a Dead-Letter Queue will park the event in the queue so you can decide to try and handle it again later. In addition, it will prevent handling of later events in the same sequence until the failed event is successfully processed.

[TIP]
.Insight and Management
xref:axoniq-platform-reference:ROOT:index.adoc[Axoniq Platform] provides insight into the Dead-Letter Queue and tools for its management.
It's straightforward to see the dead letters in the queue and decide to retry them or remove them from the queue.
You can find more information on the xref:axoniq-platform-reference:ROOT:features/dlq.adoc[Dead-Letter Queue page of Axoniq Platform].

Note that you _cannot_ share a dead-letter queue between different processors.
Hence, each processor you want to enable this behavior for should receive a unique dead-letter queue instance.

[NOTE]
.Dead-Letter Queues do not support Sagas
====
Currently, there is _no_ support for using a dead-letter queue for xref:sagas:index.adoc[sagas].
We've taken this decision as we cannot support a sequenced dead lettering approach as we do for regular event handling.

Furthermore, we cannot do this, as a saga's associations can vary widely between events.
Due to this, the sequence of events may change, breaking this level of support.
Hence, there's no way of knowing whether a next event in the stream does or does not belong to a saga.
====

== Event ordering

Axon Framework's event processors maintain the ordering of events within the same sequence, even when you configure xref:event-processors/streaming.adoc#parallel_processing[parallel processing].
A perfect example when this is a requirement is the need to handle events of the same aggregate in their publishing order.
Simply dead lettering one failed event would cause later events in the sequence to be applied to inconsistent state.

So it's important that a dead-letter queue for events enqueues an event and any following events in the sequence. To that end, the supported dead-letter queue is a so-called `SequencedDeadLetterQueue`.

Integral to its design is to allow for queueing failed events and events that belong to a faulty sequence.
It does so by maintaining a sequence identifier for each event, determined by the xref:event-processors/streaming.adoc#sequential-processing[sequencing policy].


== Implementations

We currently provide the following dead-letter queue implementations:

* `InMemorySequencedDeadLetterQueue` - In-memory variant of the dead-letter queue.
Useful for testing purposes, but as it does not persist dead letters, it is unsuited for production environments.

* `JpaSequencedDeadLetterQueue` - JPA variant of the dead-letter queue.
It constructs a `dead_letter_entry` table where it persists failed-events in.
The JPA dead-letter queue is a suitable option for production environments by persisting the dead letters.

* `JdbcSequencedDeadLetterQueue` - JDBC variant of the dead-letter queue.
It constructs a `dead_letter_entry` table where it persists failed-events in.
The JDBC dead-letter queue is a suitable option for production environments by persisting the dead letters.

* `MongoSequencedDeadLetterQueue` - Mongo variant of the dead-letter queue, available via the xref:mongodb-extension-reference::index.adoc[Mongo Extension].

It constructs a `deadletters` collection where it persists failed-events in.
The MongoDB dead-letter queue is a suitable option for production environments by persisting the dead letters.

== Idempotency

Before configuring a `SequencedDeadLetterQueue` it is vital to validate whether your event handling functions are idempotent.
As a processor consists of several Event Handling Components (as explained in the intro of this chapter), some handlers may succeed in event handling while others will not.
As a configured dead-letter queue does not stall event handling, a failure in one Event Handling Component does not cause a rollback for other event handlers.
Furthermore, as the dead-letter support is on the processor level, <<Processing sequences,dead-letter processing>> will invoke _all_ event handlers for that event within the processor.

Thus, if your event handlers are not idempotent, processing letters may result in undesired side effects.

Hence, we strongly recommend making your event handlers idempotent when using the dead-letter queue.

The principle of **exactly once** delivery is no longer guaranteed; at-least-once delivery is the reality to cope with.

== Configuration

Dead-letter queue configuration is done through the `deadLetterQueue(...)` method on the processor configuration.
The `DeadLetterQueueConfiguration` class provides a fluent API to configure the DLQ behavior:

[tabs]
====
Configuration API::
+
--
[source,java]
----
import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.messaging.eventhandling.configuration.EventHandlingComponentsConfigurer;
import org.axonframework.messaging.eventhandling.processing.streaming.pooled.PooledStreamingEventProcessorsConfigurer;

public class AxonConfig {

    public void configureEventProcessing(MessagingConfigurer configurer) {
        configurer.eventProcessing(eventConfigurer -> eventConfigurer.pooledStreaming(
                this::configurePooledStreamingProcessor
        ));
    }

    private PooledStreamingEventProcessorsConfigurer configurePooledStreamingProcessor(
            PooledStreamingEventProcessorsConfigurer pooledStreamingConfigurer
    ) {
        return pooledStreamingConfigurer.processor(
                "my-processor",
                config -> config.eventHandlingComponents(this::configureHandlingComponent)
                                .customize((cfg, processorConfig) -> processorConfig
                                        .deadLetterQueue(dlq -> dlq
                                                .enabled()
                                                .clearOnReset(true)
                                                .cacheMaxSize(1024)
                                        )
                                )
        );
    }

    private EventHandlingComponentsConfigurer.AdditionalComponentPhase configureHandlingComponent(
            EventHandlingComponentsConfigurer.RequiredComponentPhase componentConfigurer
    ) {
        return componentConfigurer.autodetected(c -> new MyEventHandler());
    }
}
----
--

Spring Boot::
+
--
[source,text]
----
axon.eventhandling.processors.my-processor.dlq.enabled=true
----
--
====

You can set the maximum number of saved sequences (defaults to 1024) and the maximum number of dead letters in a sequence (also defaults to 1024).
If either of these thresholds is exceeded, the queue will throw a `DeadLetterQueueOverflowException`.
This exception means the processor will stop processing new events altogether.
Thus, the processor moves back to the behavior described at the start of the xref:index.adoc#error-handling[Error Handling] section.

== Configuration through a factory

To use a custom dead-letter queue implementation (for example, JPA or JDBC-backed), you can configure a factory function.
The factory receives the component name and should return a new `SequencedDeadLetterQueue` instance:

[tabs]
====
Configuration API::
+
--
[source,java]
----
import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.messaging.eventhandling.configuration.EventHandlingComponentsConfigurer;
import org.axonframework.messaging.eventhandling.processing.streaming.pooled.PooledStreamingEventProcessorsConfigurer;
import org.axonframework.messaging.eventhandling.deadletter.jpa.JpaSequencedDeadLetterQueue;

public class AxonConfig {

    public void configureEventProcessing(MessagingConfigurer configurer) {
        configurer.eventProcessing(eventConfigurer -> eventConfigurer.pooledStreaming(
                this::configurePooledStreamingProcessor
        ));
    }

    private PooledStreamingEventProcessorsConfigurer configurePooledStreamingProcessor(
            PooledStreamingEventProcessorsConfigurer pooledStreamingConfigurer
    ) {
        return pooledStreamingConfigurer.processor(
                "my-processor",
                config -> config.eventHandlingComponents(this::configureHandlingComponent)
                                .customize((cfg, processorConfig) -> processorConfig
                                        .deadLetterQueue(dlq -> dlq
                                                .enabled()
                                                .factory(componentName -> JpaSequencedDeadLetterQueue.builder()
                                                        .processingGroup(componentName)
                                                        .entityManagerProvider(entityManagerProvider)
                                                        .transactionManager(transactionManager)
                                                        .serializer(serializer)
                                                        .build()
                                                )
                                        )
                                )
        );
    }

    private EventHandlingComponentsConfigurer.AdditionalComponentPhase configureHandlingComponent(
            EventHandlingComponentsConfigurer.RequiredComponentPhase componentConfigurer
    ) {
        return componentConfigurer.autodetected(c -> new MyEventHandler());
    }
}
----
--

Spring Boot::
+
--
When using Spring Boot with JPA, JDBC, or Mongo, a default dead-letter queue factory is configured automatically.
To enable the dead-letter queue for a specific processor, set the property:

[source,text]
----
axon.eventhandling.processors.my-processor.dlq.enabled=true
----
--
====

=== Defaults for all processors

If you want to enable the dead-letter queue for all processors by default, you can use the `defaults(...)` method:

[source,java]
----
import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.messaging.eventhandling.processing.streaming.pooled.PooledStreamingEventProcessorsConfigurer;

public class AxonConfig {

    public void configureEventProcessing(MessagingConfigurer configurer) {
        configurer.eventProcessing(eventConfigurer -> eventConfigurer.pooledStreaming(
                pooledStreamingConfigurer -> pooledStreamingConfigurer
                        // Enable DLQ for all processors by default
                        .defaults((cfg, processorConfig) -> processorConfig
                                .deadLetterQueue(dlq -> dlq.enabled())
                        )
                        // Override for a specific processor if needed
                        .processor(
                                "no-dlq-processor",
                                config -> config.eventHandlingComponents(this::configureHandlingComponent)
                                                .customize((cfg, processorCfg) -> processorCfg
                                                        .deadLetterQueue(dlq -> dlq.disabled())
                                                )
                        )
        ));
    }
}
----

== Processing sequences

Once you resolve the problem that led to dead lettering events, we can start processing the dead letters.
We recommend using the `SequencedDeadLetterProcessor` interface for this, as it processes an entire dead-letter _sequence_ instead of single dead-letter entries.
It will thus ensure the event order is maintained during the retry.

The `SequencedDeadLetterProcessor` provides two operations to process dead letters:

. `CompletableFuture<Boolean> processAny(ProcessingContext)` - Process the oldest dead-letter sequence.
Returns a future completing with `true` if it processes a sequence successfully.
. `CompletableFuture<Boolean> process(Predicate<DeadLetter<? extends EventMessage<?>>>, ProcessingContext)` - Process the oldest dead-letter sequence matching the predicate.
Note that the predicate only filters based on a sequence's _first_ entry.
Returns a future completing with `true` if it processes a sequence successfully.

If the processing of a dead letter fails, the event will be offered to the dead-letter queue again.
How the dead-lettering process reacts to this depends on the <<Enqueue policy,enqueue policy>>.

The `DeadLetteringEventHandlingComponent` implements `SequencedDeadLetterProcessor`, so you can use it to process dead letters.
Below are a couple of examples of how to process dead-letter sequences:

[tabs]
====
Process the oldest dead-letter sequence matching `ErrorEvent`::
+
--
[source,java]
----
import org.axonframework.messaging.deadletter.SequencedDeadLetterProcessor;
import org.axonframework.messaging.eventhandling.EventMessage;
import org.axonframework.messaging.core.unitofwork.ProcessingContext;

public class DeadletterProcessor {

    private final SequencedDeadLetterProcessor<EventMessage> processor;
    private final ProcessingContext processingContext;

    public void retryErrorEventSequence() {
        processor.process(
                deadLetter -> deadLetter.message().getPayload() instanceof ErrorEvent,
                processingContext
        ).join();
    }
}
----
--
Process the oldest dead-letter sequence in the queue::
+
--
[source,java]
----
import org.axonframework.messaging.deadletter.SequencedDeadLetterProcessor;
import org.axonframework.messaging.eventhandling.EventMessage;
import org.axonframework.messaging.core.unitofwork.ProcessingContext;

public class DeadletterProcessor {

    private final SequencedDeadLetterProcessor<EventMessage> processor;
    private final ProcessingContext processingContext;

    public void retryAnySequence() {
        processor.processAny(processingContext).join();
    }
}
----
--
Process all dead-letter sequences in the queue::
+
--
[source,java]
----
import org.axonframework.messaging.deadletter.DeadLetter;
import org.axonframework.messaging.deadletter.SequencedDeadLetterProcessor;
import org.axonframework.messaging.deadletter.SequencedDeadLetterQueue;
import org.axonframework.messaging.eventhandling.EventMessage;
import org.axonframework.messaging.core.unitofwork.ProcessingContext;

import java.util.Iterator;
import java.util.concurrent.CompletableFuture;

public class DeadletterProcessor {

    private final SequencedDeadLetterProcessor<EventMessage> processor;
    private final SequencedDeadLetterQueue<EventMessage> queue;
    private final ProcessingContext processingContext;

    public CompletableFuture<Void> retryAllSequences() {
        // Retrieve all the dead lettered event sequences
        return queue.deadLetters()
                    .thenCompose(deadLetterSequences -> {
                        CompletableFuture<Void> result = CompletableFuture.completedFuture(null);

                        // Iterate over all sequences
                        for (Iterable<DeadLetter<? extends EventMessage>> sequence : deadLetterSequences) {
                            Iterator<DeadLetter<? extends EventMessage>> sequenceIterator = sequence.iterator();
                            if (!sequenceIterator.hasNext()) {
                                continue;
                            }

                            String firstLetterId = sequenceIterator.next()
                                                                   .message()
                                                                   .identifier();

                            // SequencedDeadLetterProcessor#process automatically retries an entire sequence.
                            // Hence, we only need to filter on the first entry of the sequence:
                            result = result.thenCompose(v -> processor.process(
                                    deadLetter -> deadLetter.message().identifier().equals(firstLetterId),
                                    processingContext
                            ).thenApply(ignored -> null));
                        }

                        return result;
                    });
    }
}
----
--
====

For some event handlers, it is beneficial to know if the event it is processing is dead-lettered.
To that end, the `ProcessingContext` will contain the `DeadLetter` as a resource when processing dead letters.
You can retrieve it using the `DeadLetter.RESOURCE_KEY` constant:

[source,java]
----
import org.axonframework.messaging.deadletter.DeadLetter;
import org.axonframework.messaging.eventhandling.EventMessage;
import org.axonframework.messaging.core.unitofwork.ProcessingContext;

public class MyEventHandler {

    public void handle(SomeEvent event, ProcessingContext context) {
        DeadLetter<EventMessage> deadLetter = context.getResource(DeadLetter.RESOURCE_KEY);
        if (deadLetter != null) {
            // dead-letter processing - can access cause() and diagnostics()
            Throwable cause = deadLetter.cause().orElse(null);
        } else {
            // regular event handling
        }
    }
}
----

== Attributes

A dead letter contains the following attributes:

|===
|attribute |type |description

|`message` |`EventMessage` |The `EventMessage` for which handling failed. The message contains your event, among other `Message` properties.
|`cause` |`Optional<Cause>` |The cause for the message to be dead lettered. Empty if the letter is enqueued because it is part of a sequence.
|`enqueuedAt` |`Instant` |The moment in time when the event was enqueued in a dead-letter queue.
|`lastTouched` |`Instant` |The moment in time when this letter was last touched. Will equal the `enqueuedAt` value if this letter is enqueued for the first time.
|`diagnostics` |`MetaData` |The diagnostic `MetaData` concerning this letter. Filled through the <<Enqueue policy,enqueue policy>>.
|===

== Enqueue policy

By default, when you configure a dead-letter queue and event handling fails, the event is dead-lettered.
However, you might not want all event failures to result in dead-lettered entries.
Similarly, when <<Processing sequences,letter processing>> fails, you might want to reconsider whether you want to enqueue the letter again.

To that end, you can configure a so-called `EnqueuePolicy`.
The enqueue policy ingests a `DeadLetter` and a cause (`Throwable`) and returns an `EnqueueDecision`.
The `EnqueueDecision`, in turn, describes if the framework should or should not enqueue the dead letter.
It's also possible to change the exception, for example to be sure that it will fit in the database, as the cause will be stored.

You can customize the dead-letter policy to exclude some events when handling fails.
As a consequence, these events will be skipped.
Note that Axon Framework invokes the policy on initial event handling _and_ on <<Processing dead-letter sequences,dead-letter processing>>.

Reevaluating the policy after processing failed may be essential to ensure a dead letter isn't stuck in the queue forever.
To deal with this scenario, you can attach additional diagnostic information to the dead letter through the policy.
For example to add a number of retries to the dead letter to base your decision on.
See the sample `EnqueuePolicy` below for this:

[source,java]
----
import org.axonframework.messaging.deadletter.DeadLetter;
import org.axonframework.messaging.deadletter.Decisions;
import org.axonframework.messaging.deadletter.EnqueueDecision;
import org.axonframework.messaging.deadletter.EnqueuePolicy;
import org.axonframework.messaging.eventhandling.EventMessage;

public class CustomEnqueuePolicy implements EnqueuePolicy<EventMessage> {

    @Override
    public EnqueueDecision<EventMessage> decide(DeadLetter<? extends EventMessage> letter, Throwable cause) {
        if (cause instanceof NullPointerException) {
            // It's pointless to retry:
            return Decisions.doNotEnqueue();
        }

        final int retries = (int) letter.diagnostics().getOrDefault("retries", -1);
        if (letter.message().getPayload() instanceof ErrorEvent) {
            // Important and new entry:
            return Decisions.enqueue(cause);
        }
        if (retries < 10) {
            // Let's continue and increase retries:
            return Decisions.requeue(cause, l -> l.diagnostics().and("retries", retries + 1));
        }

        // Exhausted all retries:
        return Decisions.evict();
    }
}
----

The `Decisions` utility class provides the most reasonable decisions, but you are free to construct your own `EnqueueDecision` when necessary.
See the following example for configuring our custom policy:

[tabs]
====
Configuration API::
+
--

[source,java]
----
import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.messaging.eventhandling.configuration.EventHandlingComponentsConfigurer;
import org.axonframework.messaging.eventhandling.processing.streaming.pooled.PooledStreamingEventProcessorsConfigurer;

public class AxonConfig {

    public void configureEventProcessing(MessagingConfigurer configurer) {
        configurer.eventProcessing(eventConfigurer -> eventConfigurer.pooledStreaming(
                this::configurePooledStreamingProcessor
        ));
    }

    private PooledStreamingEventProcessorsConfigurer configurePooledStreamingProcessor(
            PooledStreamingEventProcessorsConfigurer pooledStreamingConfigurer
    ) {
        return pooledStreamingConfigurer.processor(
                "my-processor",
                config -> config.eventHandlingComponents(this::configureHandlingComponent)
                                .customize((cfg, processorConfig) -> processorConfig
                                        .deadLetterQueue(dlq -> dlq
                                                .enabled()
                                                .enqueuePolicy(new CustomEnqueuePolicy())
                                        )
                                )
        );
    }

    private EventHandlingComponentsConfigurer.AdditionalComponentPhase configureHandlingComponent(
            EventHandlingComponentsConfigurer.RequiredComponentPhase componentConfigurer
    ) {
        return componentConfigurer.autodetected(c -> new MyEventHandler());
    }
}
----
--
Spring Boot::
+
--
When using Spring Boot, define your `EnqueuePolicy` as a bean and configure the processor via properties:

[source,java]
----
import org.axonframework.messaging.deadletter.EnqueuePolicy;
import org.axonframework.messaging.eventhandling.EventMessage;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AxonConfig {

    @Bean
    public EnqueuePolicy<EventMessage> customEnqueuePolicy() {
        return new CustomEnqueuePolicy();
    }
}
----

[source,text]
----
axon.eventhandling.processors.my-processor.dlq.enabled=true
----
--
====
