= Event Bus & Event Store
:navtitle: Infrastructure
:page-aliases: event-bus-and-event-store.adoc

[#_event_bus]
== Event bus

The `EventBus` is the mechanism that dispatches events to the subscribed event handlers.
Axon provides three implementations of the Event Bus: `AxonServerEventStore`, `EmbeddedEventStore` and `SimpleEventBus`.
All three implementations support subscribing and tracking processors (see xref:event-processors/index.adoc[]).
However, the `AxonServerEventStore` and `EmbeddedEventStore` persist events (see <<event-store,Event Store>>), which allows you to replay them at a later stage.
The `SimpleEventBus` has a volatile storage and 'forgets' events as soon as they have been published to subscribed components.

An `AxonServerEventStore` event bus/store is configured by default.

[[event-store]]
== Event store

Event sourcing repositories need an event store to store and load events from entities.
An event store offers the functionality of an event bus.
Additionally, it persists published events and is able to retrieve previous events based on given criteria.

=== Dynamic Consistency Boundaries (DCB)

Axon Framework 5 introduces **Dynamic Consistency Boundaries** (DCB) as a flexible approach to organizing and querying events.
DCB allows you to tag events with arbitrary key-value pairs and query events using those tags, rather than being limited to querying by aggregate identifier alone.

==== Event tags

When appending events, you can attach tags to provide additional metadata for querying and filtering:

[source,java]
----
// Tag events during append
eventStore.append(
    events,
    tags -> tags.with("customerId", customerId)
                .with("region", "EU")
                .with("orderType", "subscription")
);
----

Tags are particularly useful for:

* **Cross-entity queries** - Find events across multiple entity instances based on business criteria
* **Filtering event streams** - Create focused event processors that only handle relevant events
* **Business-level organization** - Group events by business concepts rather than technical entity boundaries

==== EventCriteria

Use `EventCriteria` to query events based on tags when reading from the event store:

[source,java]
----
import org.axonframework.messaging.eventhandling.EventCriteria;

// Query events by tag
EventCriteria criteria = EventCriteria.builder()
    .tag("customerId", customerId)
    .tag("region", "EU")
    .build();

MessageStream<EventMessage<?>> eventStream = eventStore.readEvents(criteria);
----

==== Consistency markers

DCB uses **ConsistencyMarker** to track the logical grouping of events and prevent write conflicts.
When appending events with tags, the framework automatically manages consistency markers to ensure that concurrent writes to the same logical boundary are detected and handled appropriately.

This approach provides flexibility while maintaining consistency guarantees similar to traditional aggregate-based event sourcing.

[NOTE]
.DCB vs Traditional Aggregate-Based Storage
====
Traditional aggregate-based event sourcing queries events by aggregate identifier.
DCB extends this by allowing arbitrary tag-based queries, making it easier to model complex business scenarios where events need to be grouped and queried in multiple ways.

Event processors reading from the store typically use simple criteria.
The main impact of DCB is on the write side (command handling) where events are appended with tags.

**Availability**: DCB is currently supported by Axon Server as the event store.
JPA-based event storage does not yet support DCB and uses traditional aggregate-based storage.
====

=== Axon Server as an event store

Axon provides an event store out of the box, the `AxonServerEventStore`.
It connects to the link:https://www.axoniq.io/products/axon-server[AxonIQ AxonServer Server,window=_blank,role=external] to store and retrieve Events.

[tabs]
======
Configuration API::
+
--

Declare dependencies:

[source,xml]
----
<!--somewhere in the POM file-->
<dependency>
    <groupId>org.axonframework</groupId>
    <artifactId>axon-server-connector</artifactId>
    <version>${axon.version}</version>
</dependency>
<dependency>
    <groupId>org.axonframework</groupId>
    <artifactId>axon-modelling</artifactId>
    <version>${axon.version}</version>
</dependency>

----

Configure your application:

[source,java]
----
import org.axonframework.messaging.core.configuration.MessagingConfigurer;

// Returns a MessagingConfigurer instance with default components configured.
// `AxonServerEventStore` is configured as Event Store by default.
MessagingConfigurer configurer = MessagingConfigurer.create();

----
--

Spring Boot::
+
--

By simply declaring a dependency on `axon-spring-boot-starter`, Axon will automatically configure the event bus/event store:

[source,xml]
----
<!--somewhere in the POM file-->
<dependency>
    <groupId>org.axonframework</groupId>
    <artifactId>axon-spring-boot-starter</artifactId>
    <version>${axon.version}</version>
</dependency>
----

[NOTE]
.Excluding the Axon Server Connector
====

If you exclude the `axon-server-connector` dependency from `axon-spring-boot-starter` the `EmbeddedEventStore` will be auto-configured for you, if a concrete implementation of `EventStorageEngine` is available.
If JPA is detected on the classpath, an `AggregateBasedJpaEventStorageEngine` will be auto-configured as the `EventStorageEngine`.
In absence of JPA, the auto configuration falls back to the `SimpleEventBus`.
====
--
======

[[embedded-event-store]]
=== Embedded event store

Alternatively, Axon provides a non-axon-server option, the `EmbeddedEventStore`.
It delegates the actual storage and retrieval of events to an `EventStorageEngine`.

There are multiple `EventStorageEngine` implementations available:

[[JpaEventStorageEngine]]
==== `AggregateBasedJpaEventStorageEngine`

The `AggregateBasedJpaEventStorageEngine` stores events in a JPA-compatible data source.
The JPA event store stores events in entries.
These entries contain the converted form of an event, as well as metadata fields for fast lookup and querying.

To use the `AggregateBasedJpaEventStorageEngine`, you must have the JPA (`jakarta.persistence`) annotations on your classpath.

By default, the event store needs you to configure your persistence context (for example, as defined in the `META-INF/persistence.xml` file) to contain the entity class `AggregateEventEntry`.

Below is an example configuration of a persistence context:

[source,xml]
----
<persistence xmlns="http://java.sun.com/xml/ns/persistence" version="1.0">
    <persistence-unit name="eventStore" transaction-type="RESOURCE_LOCAL"> <1>
        <class>org.axonframework.eventsourcing.eventstore.jpa.AggregateEventEntry</class> <2>
    </persistence-unit>
</persistence>
----

<1> In this example, there is a specific persistence unit for the event store.
You may, however, choose to add this class to any other persistence unit configuration.

<2> This line registers the `AggregateEventEntry` (the class used by the `AggregateBasedJpaEventStorageEngine`) with the persistence context.

[NOTE]
====
The JPA event storage engine currently stores events by aggregate identifier and sequence number.
Dynamic Consistency Boundaries (DCB) are not yet supported for JPA-based storage.
For DCB support, use Axon Server as your event store.
====

[NOTE]
.Concurrency and Unique Key Constraints
====
Axon uses locking to prevent two threads from accessing the same aggregate.
However, if you have multiple JVMs using the same database, this won't help you.
In that case, you must rely on the database to detect conflicts.

Concurrent access to the event store will result in a Key Constraint Violation, as the table only allows a single event for a given aggregate identifier and sequence number.
Therefore, inserting a second event for an existing aggregate with an existing sequence number will result in an error.

The `AggregateBasedJpaEventStorageEngine` can detect this error and translate it to a `ConcurrencyException`.
However, each database system reports this violation differently.
If you register your `DataSource` with the `AggregateBasedJpaEventStorageEngine`, it will try to detect the type of database and figure out which error codes represent a Key Constraint Violation.
Alternatively, you may provide a `PersistenceExceptionResolver` instance, which can tell if a given exception represents a key constraint violation.

If no `DataSource` or `PersistenceExceptionResolver` is provided, exceptions from the database driver are thrown as-is.
====


By default, the `AggregateBasedJpaEventStorageEngine` requires an `EntityManagerProvider` implementation that returns the `EntityManager` instance for the `EventStorageEngine` to use.
This also allows application managed persistence contexts to be used.
It is the `EntityManagerProvider`'s responsibility to provide a correct instance of the `EntityManager`.

There are a few implementations of the `EntityManagerProvider` available, each for different needs.
The `SimpleEntityManagerProvider` simply returns the `EntityManager` instance which is given to it at construction time.
This makes the implementation a simple option for container managed contexts.
Alternatively, there is the `ContainerManagedEntityManagerProvider`, which returns the default persistence context, and is used by default by the JPA event store.

If you have a persistence unit called `"myPersistenceUnit"` which you wish to use in the `AggregateBasedJpaEventStorageEngine`, the `EntityManagerProvider` implementation could look like this:

[source,java]
----
public class MyEntityManagerProvider implements EntityManagerProvider {

    private EntityManager entityManager;

    @Override
    public EntityManager getEntityManager() {
        return entityManager;
    }

    @PersistenceContext(unitName = "myPersistenceUnit")
    public void setEntityManager(EntityManager entityManager) {
        this.entityManager = entityManager;
    }
----

By default, the JPA event store stores entries in `AggregateEventEntry` entities.
While this will suffice in many cases, you might encounter a situation where the metadata provided by this entity is not enough.
It is also possible that you might want to store events for different aggregate types in different tables.

If that is the case, you can extend the `AggregateBasedJpaEventStorageEngine`.
It contains a number of protected methods that you can override to tweak its behavior.

[WARNING]
====
Note that persistence providers, such as Hibernate, use a first-level cache in their `EntityManager` implementation.
Typically, this means that all entities used or returned in queries are attached to the `EntityManager`.
They are only cleared when the surrounding transaction is committed or an explicit "clear" is performed inside the transaction.
This is especially the case when the queries are executed in the context of a transaction.

To work around this issue, make sure to exclusively query for non-entity objects.
You can use JPA's `SELECT new SomeClass(parameters) FROM ...` style queries to work around this issue.
Alternatively, call `EntityManager.flush()` and `EntityManager.clear()` after fetching a batch of events.
Failure to do so might result in `OutOfMemoryException`s when loading large streams of events.
====

[tabs]
======
Configuration API::
+
--

[source,java]
----
import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.messaging.eventhandling.EventStore;
import org.axonframework.messaging.eventhandling.eventstore.EmbeddedEventStore;
import org.axonframework.eventsourcing.eventstore.jpa.AggregateBasedJpaEventStorageEngine;
import org.axonframework.messaging.eventhandling.conversion.EventConverter;

public class AxonConfig {
    // omitting other configuration methods...
    public void configureJpaEventStore(
            MessagingConfigurer configurer,
            EntityManagerProvider entityManagerProvider,
            TransactionManager transactionManager,
            EventConverter eventConverter
    ) {
        configurer.registerEventSink(config ->
            new EmbeddedEventStore(
                new AggregateBasedJpaEventStorageEngine(
                    entityManagerProvider,
                    transactionManager,
                    eventConverter,
                    engineConfig -> engineConfig // Use default configuration
                )
            )
        );
    }
}
----
--

Spring Boot::
+
--

[source,java]
----
@Configuration
public class AxonConfig {
    // omitting other configuration methods...

    // The EmbeddedEventStore delegates actual storage and retrieval of events to an EventStorageEngine.
    @Bean
    public EventStore eventStore(
        EventStorageEngine storageEngine,
        GlobalMetricRegistry metricRegistry
    ) {
        return EmbeddedEventStore.builder()
                                 .storageEngine(storageEngine)
                                 .messageMonitor(metricRegistry.registerEventBus("eventStore"))
                                 .spanFactory(spanFactory)
                                 // ...
                                 .build();
    }

    // The AggregateBasedJpaEventStorageEngine stores events in a JPA-compatible data source.
    @Bean
    public EventStorageEngine eventStorageEngine(
            EntityManagerProvider entityManagerProvider,
            TransactionManager transactionManager,
            EventConverter eventConverter
    ) {
         return new AggregateBasedJpaEventStorageEngine(
             entityManagerProvider,
             transactionManager,
             eventConverter,
             engineConfig -> engineConfig
                 .withPersistenceExceptionResolver(customResolver())
             // Customize other settings as needed through the configuration operator
         );
    }
}
----
--
======

[NOTE]
.JDBC Event Storage Engine
====
The `JdbcEventStorageEngine` has been moved to an external extension.
If you need JDBC-based event storage, please refer to the JDBC extension documentation.

For most use cases, we recommend using either Axon Server or the JPA Event Storage Engine.
====

[[MongoEventStorageEngine]]
==== `MongoEventStorageEngine`

https://www.mongodb.com/[MongoDB] is a document based NoSQL store.
Its scalability characteristics make it suitable for use as an event store.
Axon provides the `MongoEventStorageEngine`, which uses MongoDB as a backing database.
It is contained in the Axon Mongo module (Maven artifactId `axon-mongo`).

Events are stored in two separate collections: one for the event streams and one for snapshots.

By default, the `MongoEventStorageEngine` stores each event in a separate document.
It is, however, possible to change the `StorageStrategy` used.
The alternative provided by Axon is the `DocumentPerCommitStorageStrategy`, which creates a single document for all events that have been stored in a single commit (that is, in the same transaction).

The advantage of storing an entire commit in a single document is that commit is stored atomically.
Furthermore, it requires only a single roundtrip for any number of events.
The disadvantage is that it becomes harder to query events directly in the database.
For example, when refactoring the domain model it is harder to "transfer" events from one aggregate to another if they are included in a "commit document".

The `MongoEventStorageEngine` does not require a lot of configuration.
All it needs is a reference to the collections to store the events in, and you're set to go.
For production environments, you may want to double check the indexes on your collections.
If you want transactions to be handled correctly, it's important to set a `TransactionManager`.
Please note that there are several other optional configuration properties, like the serializers and an (optional) upcaster chain.

[tabs]
====
Configuration API::
+
--

[source,java]
----
import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.messaging.eventhandling.eventstore.EmbeddedEventStore;
import org.axonframework.extensions.mongo.eventhandling.eventstore.MongoEventStorageEngine;

public class AxonConfig {
    // omitting other configuration methods...
    public void configureMongoEventStorage(MessagingConfigurer configurer, MongoTemplate mongoTemplate) {
        configurer.registerEventSink(config ->
            new EmbeddedEventStore(
                MongoEventStorageEngine.builder()
                    .mongoTemplate(mongoTemplate)
                    .build()
            )
        );
    }
}
----
--
Spring Boot::
+
--

[source,java]
----
@Configuration
public class AxonConfig {
    // omitting other configuration methods...

    // The EmbeddedEventStore delegates actual storage and retrieval of events to an EventStorageEngine.
    @Bean
    public EventStore eventStore(EventStorageEngine storageEngine,
                                 GlobalMetricRegistry metricRegistry) {
       return EmbeddedEventStore
           .builder()
           .storageEngine(storageEngine)
           .messageMonitor(metricRegistry.registerEventBus("eventStore"))
           .spanFactory(spanFactory)
           // ...
           .build();
    }

    // The MongoEventStorageEngine stores each event in a separate MongoDB document.
    @Bean
    public EventStorageEngine storageEngine(MongoClient client) {
        return MongoEventStorageEngine
            .builder()
            .mongoTemplate(DefaultMongoTemplate.builder()
                                               .mongoDatabase(client)
                                               .build())
            // ...
            .build();
    }
}
----
--
====

=== Event store utilities

Axon provides a number of Event Storage Engines that may be useful in certain circumstances.

==== In-Memory event storage

The `InMemoryEventStorageEngine` keeps stored events in memory.
While it probably outperforms any other event store out there, it is not really meant for long-term production use.
However, it is useful in short-lived tools or tests that require an event store.

[tabs]
====
Configuration API::
+
--

[source,java]
----
import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.messaging.eventhandling.eventstore.EmbeddedEventStore;
import org.axonframework.messaging.eventhandling.eventstore.inmemory.InMemoryEventStorageEngine;

public class AxonConfig {
    // omitting other configuration methods...
    public void configureInMemoryEventStorage(MessagingConfigurer configurer) {
        configurer.registerEventSink(config ->
            new EmbeddedEventStore(new InMemoryEventStorageEngine())
        );
    }
}
----
--

Spring Boot::
+
--
[source,java]
----
@Configuration
public class AxonConfig {
    // omitting other configuration methods...

    // The EmbeddedEventStore delegates actual storage and retrieval of events to an EventStorageEngine.
    @Bean
    public EventStore eventStore(EventStorageEngine storageEngine,
                                 GlobalMetricRegistry metricRegistry) {
        return EmbeddedEventStore.builder()
                                 .storageEngine(storageEngine)
                                 .messageMonitor(metricRegistry.registerEventBus("eventStore"))
                                 .spanFactory(spanFactory)
                                 // ...
                                 .build();
    }

    // The InMemoryEventStorageEngine stores each event in memory.
    @Bean
    public EventStorageEngine storageEngine() {
        return new InMemoryEventStorageEngine();
    }
}
----
--
====

==== Combining multiple event stores into one

The `SequenceEventStorageEngine` is a wrapper around two other event storage engines.
When reading, it returns the events from both event storage engines.
Appended events are only appended to the second event storage engine.
This is useful in cases where two different implementations of event storage are used for performance reasons, for example.
The first would be a larger, but slower event store, while the second is optimized for quick reading and writing.

==== Filtering stored events

The `FilteringEventStorageEngine` allows events to be filtered based on a predicate.
Only events that match the given predicate will be stored.
Note that event processors that use the event store as a source of events may not receive these events because they are not being stored.

=== Configuring event conversion

Event stores need a way to convert events to a serialized form for storage.
By default, Axon uses the `JacksonConverter`, which uses https://github.com/FasterXML/jackson[Jackson] to convert events to and from JSON format.

The `JacksonConverter` produces a compact serialized form and is widely supported across different platforms and languages.
This makes it ideal for:

* Storing events in an event store
* Long-term storage with good human readability
* Integration with external systems
* Efficient network transmission

You can customize the converter by providing a custom `ObjectMapper`:

[source,java]
----
ObjectMapper customMapper = new ObjectMapper()
    .findAndRegisterModules()
    .configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);

JacksonConverter converter = new JacksonConverter(customMapper);
----

You may also implement your own converter by creating a class that implements `EventConverter`, and configuring the event store to use that implementation instead of the default.

For complete details on converters and conversion, see xref:ROOT:conversion.adoc[Conversion].

[tabs]
====
Configuration API::
+
--

[source,java]
----
import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.conversion.json.JacksonConverter;
import org.axonframework.messaging.eventhandling.conversion.EventConverter;
import org.axonframework.messaging.eventhandling.conversion.DelegatingEventConverter;

MessagingConfigurer configurer = MessagingConfigurer.create()
    .componentRegistry(cr -> cr.registerComponent(
        EventConverter.class,
        config -> new DelegatingEventConverter(new JacksonConverter())
    ));
----
--

Spring Boot::
+
--
You can specify a converter in your `application.properties`:

[source,properties]
----
# somewhere in your `application.properties`

axon.converter.events=jackson
# possible values: default, java, jackson
----

Alternatively, you can explicitly define your `EventConverter` in the Spring context:

[source,java]
----
import org.axonframework.messaging.eventhandling.conversion.EventConverter;
import org.axonframework.messaging.eventhandling.conversion.DelegatingEventConverter;
import org.axonframework.conversion.json.JacksonConverter;

@Configuration
public class ConverterConfiguration {

    @Bean
    public EventConverter eventConverter() {
        return new DelegatingEventConverter(new JacksonConverter());
    }
}
----
--
====

==== Converting events vs other messages

It is possible to use a different converter for the storage of events than for other objects that Axon needs to convert (such as commands and queries).
The `JacksonConverter` creates compact JSON output that is suitable for long-term event storage and cross-platform compatibility.

If no explicit `EventConverter` is configured, events are converted using the message converter that has been configured (which defaults to the `JacksonConverter`).

== Distributing events

To distribute events between applications, it is important to know whether the applications belong to the same bounded context. If you don't recognize this concept, we recommend reading the link:https://www.axoniq.io/concepts/domain-driven-design[Bounded Context] section first.
Applications within the same context "speak the same language." In other words, they communicate using the same set of messages and thus events.

As such, we can share the `EventStore's` data source between these applications.
We may thus achieve distribution by utilizing the source itself.
You can use both the <<Embedded event store,`EmbeddedEventStore`>> and link:https://www.axoniq.io/products/axon-server[Axon Server,window=_blank,role=external] for this.
The former would require the applications to point to the same data source, whereas the latter would require the applications to partake in the same context.

However, sharing the entire event API is not recommended whenever the applications do not belong to the same context.
Instead, we should protect the boundary of the contexts, except for some clearly defined cross-boundary messages.
Since accessing the same source isn't an option, we require a different solution to share events.

To distribute events between bounded contexts, you can use Axon Server's xref:axon-server-reference:ROOT:axon-server/administration/multi-context.adoc[] solution, for example.
The multi-context support requires application registration to specific contexts.
Then, you can open a stream to another context through the `AxonServerEventStore#createStreamableMessageSourceForContext(String)` operation.
With this source in hand, you can configure a xref:event-processors/streaming.adoc[Streaming Processor] to start reading from it.

Alternatively, you can use a message broker to distribute events between contexts.
Axon provides a good bunch of these as extension modules, for example xref:amqp-extension-reference::index.adoc[Spring AMQP] or  xref:kafka-extension-reference::index.adoc[Kafka].

Although this allows further event distribution, we still recommend consciously sharing _the correct_ events.
Ideally, we add a form of context mapping, like an anti-corruption layer, between the contexts.
In other words, we recommend using a separate component that maps the events from the local context to a shared language right before distribution.

For example, this mapper would publish the messages on the AMQP queue or Kafka topic.
When it comes to Axon Server, we could, for example, use a distinct shared/global context to contain the shared language.