= Event Dispatchers
:navtitle: Dispatching

Event publication can originate from a couple of locations within your Axon Framework application.
In general, these can be grouped in two major areas:

. Dispatching events from an entity, and
. Dispatching events from regular components

This page will describe how to get an event message on the event bus from both locations.
For more specifics regarding event publication and storage implementations in Axon Framework, read xref:event-buses-and-event-stores.adoc[this] section.

[TIP]
.Tagging Events for DCB
====
With Axon Framework 5 support for xref:event-store-internals.adoc#dynamic_consistency_boundaries_dcb[Dynamic Consistency Boundaries (DCB)], it is possible to tag events when modeling them.
Tags can be used to group events into consistency boundaries, see xref:event-store-internals.adoc#tags[@EventTag] for more information.
====

[#dispatching_events_from_an_entity]
== Dispatching events from an entity

The xref:commands:modeling/aggregate.adoc[Entity] or its xref:commands:modeling/multi-entity-aggregates.adoc[child entities] are typically the starting point of all event messages.
The Event Message simply is the notification that a decision has been made; a successful resolution of handling a command message.

To publish an event from an entity, it is required to do this from the lifecycle of the entity instance.
This is mandatory as we want the entity identifier to be tied to the Event message.
It is also of the essence that the events originate in order.
This is achieved by adding a sequence number to every event from an entity.

The `EventAppender` provides a simple means to achieve the above:

[source,java]
----
import org.axonframework.messaging.eventhandling.gateway.EventAppender;

public class GiftCard {

    @CommandHandler
    public static GiftCard create(IssueCardCommand cmd, EventAppender appender) {
        appender.append(new CardIssuedEvent(cmd.getCardId(), cmd.getAmount()));
        return new GiftCard();
    }
    // omitted state, command and event sourcing handlers
}

----

The `EventAppender` is automatically injected by Axon Framework when declared as a parameter in a command handler.
It is the recommended way to append events from within an entity's command handling methods, as it automatically:

. Uses the current `ProcessingContext`
. Attaches the entity identifier to the event
. Assigns the correct sequence number
. Publishes the event to registered event handlers within the entity (necessary for event sourcing)
. Publishes the event to the `EventSink`

[TIP]
.The `EventAppender` can append multiple events at once
====
[source,java]
----
appender.append(
    new CardIssuedEvent(cmd.getCardId(), cmd.getAmount()),
    new CardActivatedEvent(cmd.getCardId())
);
----
====

[#dispatching_events_from_a_non_entity]
== Dispatching events from a non-entity

In the vast majority of cases, xref:commands:modeling/aggregate.adoc[entities] will publish events by appending them.
However, occasionally, it is necessary to publish an event directly to the `EventSink`, possibly from within another component such as an event handler or a regular service.

=== Using `EventGateway`

The `EventGateway` provides a convenient API for publishing events from components that are not entities:

[source,java]
----
private EventGateway eventGateway;

public void dispatchEvent() {
    eventGateway.publish(new CardIssuedEvent("cardId", 100, "shopId"));
}
// omitted class and constructor
----

The `EventGateway` automatically wraps your event objects into `EventMessage` instances before sending them to the `EventSink`.
It provides two main approaches for publishing events:

==== Publishing without `ProcessingContext`

When publishing events from outside a message handler (for example, from an HTTP endpoint or scheduled task), you can use the simple `publish` method without providing a `ProcessingContext`:

[source,java]
----
@RestController
public class CardController {

    private final EventGateway eventGateway;

    public CardController(EventGateway eventGateway) {
        this.eventGateway = eventGateway;
    }

    @PostMapping("/cards/{cardId}/issue")
    public CompletableFuture<Void> issueCard(@PathVariable String cardId,
                                               @RequestBody IssueCardRequest request) {
        return eventGateway.publish(
            new CardIssuedEvent(cardId, request.getAmount(), request.getShopId())
        );
    }
}
----

The `publish` method returns a `CompletableFuture<Void>`, allowing you to handle the result asynchronously.

==== Publishing with `ProcessingContext`

When publishing events from within a message handler (such as an event handler or query handler), you should provide the `ProcessingContext` to maintain correlation data:

[source,java]
----
@EventHandler
public void on(PaymentReceivedEvent event,
               ProcessingContext context,
               EventGateway eventGateway) {
    // Validation logic...

    eventGateway.publish(
        context,
        new BalanceUpdatedEvent(event.getAccountId(), event.getAmount())
    );
}
----

Providing the `ProcessingContext` ensures that:

* Correlation data (trace ID, correlation ID, causation ID) flows from one message to another
* The event publication is part of the same processing lifecycle
* Distributed tracing works correctly across message boundaries

[TIP]
.Async-native API
====
All event publishing methods in Axon 5 return a `CompletableFuture<Void>`.
This allows you to:

* Chain additional operations after publication
* Handle errors gracefully
* Integrate with reactive frameworks

[source,java]
----
eventGateway.publish(event)
    .thenRun(() -> log.info("Event published successfully"))
    .exceptionally(ex -> {
        log.error("Failed to publish event", ex);
        return null;
    });
----
====

=== Using `EventSink` directly

For advanced use cases where you need more control over the event publication process, you can use the `EventSink` directly.
The `EventSink` operates on `EventMessage` instances rather than plain event objects:

[source,java]
----
import org.axonframework.messaging.eventhandling.EventMessage;
import org.axonframework.messaging.eventhandling.EventSink;
import org.axonframework.messaging.eventhandling.GenericEventMessage;

public class DirectEventPublisher {

    private final EventSink eventSink;

    public DirectEventPublisher(EventSink eventSink) {
        this.eventSink = eventSink;
    }

    public CompletableFuture<Void> publishWithMetadata() {
        EventMessage<CardIssuedEvent> eventMessage = new GenericEventMessage<>(
                    new MessageType(CardIssuedEvent),
                    new CardIssuedEvent("cardId", 100, "shopId")
                ).withMetadata(Map.of("userId", "user123", "source", "api"));

        return eventSink.publish(null, eventMessage);
    }
}
----

When using the `EventSink` directly:

* You must create `EventMessage` instances yourself
* You have full control over message metadata
* You can specify a `ProcessingContext` (or pass `null` if publishing outside a message handler)

[IMPORTANT]
====
For most use cases, prefer using `EventGateway` or `EventAppender` over direct `EventSink` usage.
These higher-level APIs handle message wrapping and context management automatically, reducing the chance of errors.
====

== Configuration

Both `EventGateway` and `EventSink` are automatically configured by Axon Framework.

=== Spring Boot configuration

When using Spring Boot with Axon, both components are available as beans and can be injected directly:

[source,java]
----
@Service
public class MyService {

    private final EventGateway eventGateway;

    public MyService(EventGateway eventGateway) {
        this.eventGateway = eventGateway;
    }

    // Use eventGateway...
}
----

=== Configuration API

When configuring Axon programmatically, you can access both components from the configuration:

[source,java]
----
ApplicationConfigurer configurer = DefaultConfigurer.defaultConfiguration();

configurer.messaging(messagingConfigurer -> {
    // EventSink is registered by default, but can be customized
    messagingConfigurer.registerEventSink(config -> new CustomEventSink());
});

Configuration configuration = configurer.start();
EventGateway eventGateway = configuration.getComponent(EventGateway.class);
EventSink eventSink = configuration.getComponent(EventSink.class);
----

== Summary

Axon Framework provides multiple ways to dispatch events, each suited for different scenarios:

[cols="1,2,2"]
|===
|Component |Use Case |Key Features

|`EventAppender`
|Publishing events from within entities
|Automatic context management, entity identifier attachment, sequence numbering

|`EventGateway`
|Publishing events from regular components
|Automatic message wrapping, simple API, optional ProcessingContext

|`EventSink`
|Advanced/low-level event publishing
|Full control over EventMessage, metadata management
|===

In most cases, you should use:

* `EventAppender` when working inside entities
* `EventGateway` when working in regular services or handlers
* `EventSink` only for advanced scenarios requiring fine-grained control
