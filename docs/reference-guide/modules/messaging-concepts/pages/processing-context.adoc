= Processing Context
:page-aliases: unit-of-work.adoc

The `ProcessingContext` is the core abstraction for managing the lifecycle of message processing in Axon Framework.
It coordinates all actions performed during the processing of a message—whether it's a command, event, or query.
While you're unlikely to interact with it directly in most cases, understanding the `ProcessingContext` helps you leverage Axon's lifecycle management capabilities when needed.

== Overview

When Axon processes a message, it creates a `ProcessingContext` that:

* **Manages the processing lifecycle** through distinct phases (pre-invocation, invocation, commit, etc.)
* **Stores resources** needed during processing (database connections, entity managers, etc.)
* **Coordinates cleanup actions** to release resources after processing
* **Provides access to framework components** from the configuration
* **Supports async-native processing** with `CompletableFuture`-based APIs

The `ProcessingContext` ensures that message processing is atomic—either completed successfully or rolled back entirely if something goes wrong.

[TIP]
====
In most cases, Axon's building blocks automatically manage the `ProcessingContext` for you.
You typically only need to interact with it when:

* Registering lifecycle callbacks for cleanup or transaction management
* Managing custom resources that span multiple processing steps
* Implementing advanced interceptors or custom infrastructure components
====

== Accessing the processing context

The `ProcessingContext` is injected as a parameter in your message handlers:

[source,java]
----
@CommandHandler
public OrderResult handle(PlaceOrderCommand command, ProcessingContext context) {
    // Access the context to register callbacks, manage resources, etc.
    context.onCommit(ctx -> {
        logger.info("Order placed successfully");
        return CompletableFuture.completedFuture(null);
    });

    return processOrder(command);
}

@EventHandler
public void on(OrderPlacedEvent event, ProcessingContext context) {
    // Register cleanup action
    context.doFinally(ctx -> releaseResources());

    updateProjection(event);
}
----

[NOTE]
====
Unlike Axon 4's `UnitOfWork`, there is **no thread-local access** to the `ProcessingContext`.
The old `CurrentUnitOfWork.get()` pattern no longer exists.
The context must be explicitly passed as a parameter where needed.
====

== Processing lifecycle

The `ProcessingContext` manages message processing through a series of phases.
Each phase serves a specific purpose in the processing lifecycle.

=== Lifecycle phases

The processing lifecycle consists of these phases, executed in order:

[cols="1,1,4"]
|===
|Phase |Order |Purpose

|**Pre-Invocation**
|-10000
|Execute setup actions before the handler is invoked. Use for validation, security checks, or preparing resources.

|**Invocation**
|0
|The main processing phase where your message handler executes.

|**Post-Invocation**
|10000
|Execute actions after handler invocation but before commit. Use for post-processing logic that should happen before persistence.

|**Prepare-Commit**
|20000
|Prepare resources for commit. Use for validation before the final commit.

|**Commit**
|30000
|Commit changes. Use for persisting state, committing transactions, publishing events, or sending messages.

|**After-Commit**
|40000
|Execute actions after successful commit. Use for notifications, logging, or triggering follow-up processes.
|===

=== Phase execution rules

* **Sequential execution**: Phases execute strictly in order from lowest to highest
* **Parallel actions**: Multiple actions within the same phase may execute in parallel
* **Phase completion**: All actions in a phase must complete before moving to the next phase
* **Failure handling**: If any action fails, subsequent phases are skipped and error handlers execute

=== Registering lifecycle actions

You can register actions to execute in any phase:

[source,java]
----
@CommandHandler
public void handle(CreateOrderCommand command, ProcessingContext context) {
    // Async action - returns CompletableFuture
    context.onCommit(ctx -> {
        return saveToDatabase(order)
            .thenApply(result -> {
                logger.info("Order saved: {}", result);
                return null;
            });
    });

    // Sync action - no return value
    context.runOnAfterCommit(ctx -> {
        notificationService.sendOrderConfirmation(command.getOrderId());
    });
}
----

All lifecycle methods come in two variants:

* **Async variant** (`on*`) - For actions that return `CompletableFuture<?>`
* **Sync variant** (`runOn*`) - For simple actions with no return value

Available lifecycle methods:

[source,java]
----
// Async variants
context.onPreInvocation(ctx -> doAsyncSetup())
context.onInvocation(ctx -> handleAsync())
context.onPostInvocation(ctx -> doAsyncPostProcessing())
context.onPrepareCommit(ctx -> validateBeforeCommit())
context.onCommit(ctx -> commitTransaction())
context.onAfterCommit(ctx -> sendNotifications())

// Sync variants
context.runOnPreInvocation(ctx -> doSetup())
context.runOnInvocation(ctx -> handleSync())
context.runOnPostInvocation(ctx -> doPostProcessing())
context.runOnPrepareCommit(ctx -> validate())
context.runOnCommit(ctx -> commit())
context.runOnAfterCommit(ctx -> notify())
----

For synchronous actions that need to return a value, wrap them in a `CompletableFuture`:

[source,java]
----
context.onCommit(ctx -> {
    String result = performSyncOperation();
    return CompletableFuture.completedFuture(result);
});
----

=== Error and completion handlers

Beyond the standard phases, you can register handlers for errors and completion:

[source,java]
----
@EventHandler
public void on(OrderPlacedEvent event, ProcessingContext context) {
    // Register error handler - invoked when any phase fails
    context.onError((ctx, phase, error) -> {
        logger.error("Processing failed in phase {}: {}", phase, error.getMessage());
        rollbackChanges();
        publishErrorEvent(event, error);
    });

    // Register completion handler - invoked when all phases succeed
    context.whenComplete(ctx -> {
        logger.info("Processing completed successfully");
        updateMetrics();
    });

    // Register finally handler - invoked regardless of success or failure
    context.doFinally(ctx -> {
        releaseResources();
        cleanupTempFiles();
    });

    processEvent(event);
}
----

**Execution order for error scenarios:**

1. Normal phases execute until one fails
2. `onError` handlers execute
3. `whenComplete` handlers are **skipped**
4. `doFinally` handlers execute

**Execution order for success scenarios:**

1. All normal phases execute successfully
2. `onError` handlers are **skipped**
3. `whenComplete` handlers execute
4. `doFinally` handlers execute

== Resource management

The `ProcessingContext` provides type-safe resource management for storing and retrieving resources needed during message processing.

=== Resource keys

Resources are identified using type-safe keys:

[source,java]
----
// Define resource keys
ResourceKey<EntityManager> EM_KEY = ResourceKey.withLabel("EntityManager");
ResourceKey<Connection> DB_CONN = ResourceKey.withLabel("DatabaseConnection");
ResourceKey<List<String>> TAGS = ResourceKey.withLabel("Tags");
----

Using typed keys prevents casting errors and provides IDE auto-completion support.

=== Storing and retrieving resources

[source,java]
----
@CommandHandler
public void handle(CreateOrderCommand command, ProcessingContext context) {
    // Add or replace resource
    EntityManager em = entityManagerFactory.createEntityManager();
    context.putResource(EM_KEY, em);

    // Get resource
    EntityManager retrieved = context.getResource(EM_KEY);

    // Check if resource exists
    if (context.containsResource(EM_KEY)) {
        // Resource is available
    }

    // Get or create resource (compute if absent)
    Connection conn = context.computeResourceIfAbsent(DB_CONN,
        () -> dataSource.getConnection());

    // Register cleanup
    context.doFinally(ctx -> {
        EntityManager manager = ctx.removeResource(EM_KEY);
        if (manager != null) {
            manager.close();
        }
    });
}
----

=== Resource lifecycle pattern

A common pattern for managing resources:

[source,java]
----
public class TransactionInterceptor implements MessageHandlerInterceptor<CommandMessage> {

    private static final ResourceKey<Transaction> TX_KEY =
        ResourceKey.withLabel("Transaction");

    @Override
    public MessageStream<?> interceptOnHandle(
            CommandMessage message,
            ProcessingContext context,
            MessageHandlerInterceptorChain<CommandMessage> chain) {

        // Create resource in pre-invocation
        context.runOnPreInvocation(ctx -> {
            Transaction tx = transactionManager.beginTransaction();
            ctx.putResource(TX_KEY, tx);
        });

        // Commit in commit phase
        context.onCommit(ctx -> {
            Transaction tx = ctx.getResource(TX_KEY);
            return tx.commitAsync();
        });

        // Rollback on error
        context.onError((ctx, phase, error) -> {
            Transaction tx = ctx.getResource(TX_KEY);
            if (tx != null) {
                tx.rollback();
            }
        });

        // Cleanup in finally
        context.doFinally(ctx -> {
            Transaction tx = ctx.removeResource(TX_KEY);
            if (tx != null) {
                tx.close();
            }
        });

        return chain.proceed(message, context);
    }
}
----

=== Updating resources

You can update existing resources using the update method:

[source,java]
----
// Update resource using a function
context.updateResource(TAGS, tags -> {
    if (tags == null) {
        tags = new ArrayList<>();
    }
    tags.add("processed");
    return tags;
});
----

== Accessing framework components

The `ProcessingContext` provides access to components registered in the Axon Framework configuration:

[source,java]
----
@EventHandler
public void on(OrderPlacedEvent event, ProcessingContext context) {
    // Access framework components
    EventBus eventBus = context.component(EventBus.class);
    CommandGateway gateway = context.component(CommandGateway.class);

    // Access named components
    QueryBus queryBus = context.component(QueryBus.class, "myQueryBus");

    // Use components
    gateway.send(new ProcessOrderCommand(event.getOrderId()));
}
----

This is particularly useful in interceptors or custom infrastructure components where you need to access framework services.

== Accessing the current message

The message being processed is stored as a resource in the context:

[source,java]
----
@CommandHandler
public void handle(MyCommand command, ProcessingContext context) {
    // Retrieve the current message
    Message message = Message.fromContext(context);

    // Cast to specific message type if needed
    CommandMessage commandMessage = (CommandMessage) message;

    // Access message properties
    String messageId = message.identifier();
    Metadata metadata = message.metadata();
    Instant timestamp = ((EventMessage) message).timestamp(); // For events
}
----

[NOTE]
====
Unlike Axon 4, the `ProcessingContext` doesn't revolve around a single message.
The message is just one resource stored in the context, allowing the context to be used for any processing scope, including batch processing or streaming scenarios.
====

== Transaction management

Axon Framework uses the `ProcessingContext` to attach transactions to message processing.
Many components allow you to configure a `TransactionManager`:

* `CommandBus` implementations
* `QueryBus` implementations
* Event processors

The transaction manager creates transactions that are bound to the processing context lifecycle.

=== Configuring transaction management

[tabs]
====
Spring Boot::
+
[source,java]
----
@Configuration
public class AxonConfig {

    @Bean
    public TransactionManager transactionManager(PlatformTransactionManager ptm) {
        return new SpringTransactionManager(ptm);
    }
}

// Spring Boot auto-configuration will automatically use this
// transaction manager for all message processing
----

Axon Configuration::
+
[source,java]
----
MessagingConfigurer.create()
    .registerCommandBusTransactionManager(config ->
        new MyTransactionManager()
    )
    .registerEventProcessorTransactionManager("myProcessor", config ->
        new MyTransactionManager()
    )
    .build();
----
====

=== How transactions work with the processing context

When a transaction manager is configured:

1. **Pre-Invocation**: Transaction is started and attached to the context as a resource
2. **Invocation**: Your handler executes within the transaction
3. **Commit**: Transaction is committed if processing succeeds
4. **Error**: Transaction is rolled back if processing fails
5. **Cleanup**: Transaction resources are released

=== Rollback configuration

You can configure when the processing context should trigger a rollback:

[source,java]
----
// Configuration options:
RollbackConfigurationType.NEVER               // Never rollback
RollbackConfigurationType.ANY_THROWABLE       // Rollback on any exception
RollbackConfigurationType.UNCHECKED_EXCEPTIONS // Rollback on RuntimeException and Error
RollbackConfigurationType.RUNTIME_EXCEPTION   // Rollback on RuntimeException only
----

The default is `ANY_THROWABLE`, meaning any exception will trigger a rollback.

== Context propagation

When dispatching new messages from within a handler, you can propagate the context to maintain correlation and share resources.

=== Using `EventAppender`

`EventAppender` automatically uses the current processing context when publishing events:

[source,java]
----
@CommandHandler
public void handle(PlaceOrderCommand command,
                  EventAppender eventAppender,
                  ProcessingContext context) {
    // EventAppender uses the context automatically
    eventAppender.append(new OrderPlacedEvent(command.getOrderId()));

    // Metadata and correlation data from context are propagated
}
----

=== Using `CommandDispatcher`

`CommandDispatcher` is automatically context-aware when injected into handlers:

[source,java]
----
@EventHandler
public CompletableFuture<Void> on(OrderPlacedEvent event,
                                  CommandDispatcher commandDispatcher) {
    // CommandDispatcher is already bound to the current ProcessingContext
    // Correlation data propagates automatically
    CommandResult result = commandDispatcher.send(
        new ProcessOrderCommand(event.getOrderId())
    );

    // Return the CompletableFuture so the handler only completes when the command finishes
    return result.toCompletableFuture()
                 .thenAccept(r -> logger.info("Command processed successfully"))
                 .exceptionally(ex -> {
                     logger.error("Command failed: {}", ex.getMessage());
                     return null;
                 });
}
----

=== Creating branched contexts

You can create a new context that shares resources from a parent context:

[source,java]
----
@EventHandler
public void on(OrderCreatedEvent event, ProcessingContext context) {
    // Create branched context with additional resource
    ProcessingContext enrichedContext = context.withResource(
        CORRELATION_ID_KEY,
        event.getOrderId()
    );

    // The enriched context has all resources from the original context
    // plus the new correlation ID
    // Lifecycle callbacks registered on either context affect both
}
----

[IMPORTANT]
====
Unlike Axon 4's `UnitOfWork.root()`, there is **no nesting** of processing contexts in Axon 5.
Each context is independent.
Use resource propagation via `withResource()` when you need to share data between contexts.
====

== Advanced usage

=== Custom phases

You can define custom phases to insert logic at specific points in the lifecycle:

[source,java]
----
// Define custom phase between pre-invocation and invocation
Phase customPhase = () -> -5000;  // Order between -10000 and 0

context.on(customPhase, ctx -> {
    // Custom logic here
    performCustomSetup();
    return CompletableFuture.completedFuture(null);
});
----

=== Checking lifecycle state

You can query the current state of the processing context:

[source,java]
----
if (context.isStarted()) {
    // Processing has started
}

if (context.isError()) {
    // An error occurred during processing
}

if (context.isCommitted()) {
    // Processing committed successfully
}

if (context.isCompleted()) {
    // Processing completed (success or failure)
}
----

=== Creating contexts for testing

For testing, you can create stub contexts:

[source,java]
----
// Create context with a message
ProcessingContext context = StubProcessingContext.forMessage(commandMessage);

// Create context with mocked components
ProcessingContext context = StubProcessingContext.withComponent(
    CommandGateway.class,
    mockGateway
);

// Manually advance to specific phase for testing
StubProcessingContext stub = new StubProcessingContext();
stub.onCommit(ctx -> verifyCommit());
stub.moveToPhase(DefaultPhases.COMMIT).join();
----

== Migration from Axon 4

If you're migrating from Axon 4's `UnitOfWork`, here are the key differences:

[cols="2,2,3"]
|===
|Axon 4 UnitOfWork |Axon 5 ProcessingContext |Notes

|`CurrentUnitOfWork.get()`
|Inject as parameter
|No thread-local access

|`uow.onPrepareCommit()`
|`context.onPrepareCommit()`
|Same phase, async by default

|`uow.onCommit()`
|`context.onCommit()`
|Same phase, async by default

|`uow.afterCommit()`
|`context.onAfterCommit()`
|Renamed for clarity

|`uow.onRollback()`
|`context.onError()`
|Receives phase and error information

|`uow.onCleanup()`
|`context.doFinally()`
|Renamed for clarity

|`uow.getOrComputeResource("key", supplier)`
|`context.computeResourceIfAbsent(ResourceKey.withLabel("key"), supplier)`
|Type-safe resource keys

|`uow.getMessage()`
|`Message.fromContext(context)`
|Message is now just a resource

|`uow.root()`
|No equivalent
|No nesting support

|Thread-local storage
|Explicit parameter passing
|More explicit, works with async
|===

Key architectural changes:

* **No thread-local access** - Context must be passed explicitly
* **No nesting** - Each context is independent
* **Async-native** - All lifecycle methods return `CompletableFuture`
* **Type-safe resources** - Uses `ResourceKey<T>` instead of string keys
* **Message as resource** - The context doesn't revolve around a single message

== Best practices

1. **Register cleanup actions**: Always use `doFinally()` to release resources, as it executes regardless of success or failure.

2. **Use typed resource keys**: Define `ResourceKey<T>` constants for all your resources to ensure type safety.

3. **Return CompletableFutures**: For async actions in lifecycle callbacks, return a proper `CompletableFuture`. For sync actions, use the `runOn*` variants.

4. **Keep handlers focused**: Don't perform complex lifecycle management in handlers. Use interceptors for cross-cutting concerns.

5. **Propagate context**: When dispatching new messages, pass the context to maintain correlation and resource access.

6. **Test with stubs**: Use `StubProcessingContext` in tests to verify lifecycle callback behavior.

7. **Document resource lifecycles**: Clearly document when resources are created, used, and released, especially in shared infrastructure code.
