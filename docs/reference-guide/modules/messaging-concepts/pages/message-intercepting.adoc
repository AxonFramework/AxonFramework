= Message Intercepting

There are two different types of interceptors: dispatch interceptors and handler interceptors.

**Dispatch interceptors** are invoked before a message is dispatched.
At that point, it may not even be known that a handler exists for that message.
They can modify the message (add metadata) or block dispatch entirely.

**Handler interceptors** are invoked just before the message handler is invoked, within the processing context.
They can perform actions before and after handling, and can access the `ProcessingContext`.

Both interceptor types return a `MessageStream`, allowing them to work seamlessly with Axon's async-native architecture.

[[command-interceptors]]
== Command interceptors

One of the advantages of using a command bus is the ability to undertake action based on all incoming commands.
Examples are logging or authentication, which you might want to do regardless of the type of command.

=== Command dispatch interceptors

Message dispatch interceptors are invoked when a command is dispatched on a command bus.
They can alter the command message by adding metadata or block the command by not proceeding with the chain.
These interceptors are always invoked on the thread that dispatches the command.

The `MessageDispatchInterceptor` interface defines a single method:

[source,java]
----
MessageStream<?> interceptOnDispatch(
    CommandMessage message,
    ProcessingContext context,  // May be null
    MessageDispatchInterceptorChain<CommandMessage> chain
);
----

Let's create a dispatch interceptor that logs each command:

[source,java]
----
public class CommandLoggingDispatchInterceptor
        implements MessageDispatchInterceptor<CommandMessage> {

    private static final Logger logger =
            LoggerFactory.getLogger(CommandLoggingDispatchInterceptor.class);

    @Override
    public MessageStream<?> interceptOnDispatch(
            CommandMessage message,
            ProcessingContext context,
            MessageDispatchInterceptorChain<CommandMessage> chain) {

        logger.info("Dispatching command: {}", message.type());

        // Proceed with the chain
        return chain.proceed(message, context);
    }
}
----

You can also modify the message before dispatching:

[source,java]
----
public class MetadataEnrichingInterceptor
        implements MessageDispatchInterceptor<CommandMessage> {

    @Override
    public MessageStream<?> interceptOnDispatch(
            CommandMessage message,
            ProcessingContext context,
            MessageDispatchInterceptorChain<CommandMessage> chain) {

        // Add metadata
        CommandMessage enrichedMessage = message.andMetadata(
            Metadata.with("timestamp", String.valueOf(System.currentTimeMillis()))
        );

        return chain.proceed(enrichedMessage, context);
    }
}
----

Register the interceptor with a `CommandBus`:

[source,java]
----
public void configureCommandBus() {
    MessagingConfigurer.create()
        .registerCommandBus(config -> {
            SimpleCommandBus commandBus = SimpleCommandBus.builder().build();
            commandBus.registerDispatchInterceptor(
                new CommandLoggingDispatchInterceptor()
            );
            return commandBus;
        })
        .start();
}
----

==== Structural validation

There is no point in processing a command if it does not contain all required information in the correct format.
A command that lacks information should be blocked as early as possible, preferably even before a transaction has been started.
Therefore, an interceptor should check all incoming commands for the availability of such information.
This is called structural validation.

Axon Framework has support for the JSR 303 Bean Validation specification.
This allows you to annotate the fields on commands with annotations like `@NotEmpty` and `@Pattern`.
You need to include a JSR 303 implementation (such as Hibernate-Validator) on your classpath.
Then, configure a `BeanValidationInterceptor` on your command bus, and it will automatically find and configure your validator implementation.

[TIP]
.Interceptor Ordering
====
You want to spend as few resources on an invalid command as possible.
Therefore, this interceptor is generally placed at the front of the interceptor chain.
In some cases, a `LoggingInterceptor` or `AuditingInterceptor` might need to be placed first, with the validating interceptor immediately following it.
====

The `BeanValidationInterceptor` also implements `MessageHandlerInterceptor`, allowing you to configure it as a handler interceptor as well.

[[command-handler-interceptors]]
=== Command handler interceptors

Message handler interceptors can take action both before and after command processing.
Interceptors can even block command processing altogether, for example for security reasons.

The `MessageHandlerInterceptor` interface defines a single method:

[source,java]
----
MessageStream<?> interceptOnHandle(
    CommandMessage message,
    ProcessingContext context,
    MessageHandlerInterceptorChain<CommandMessage> chain
);
----

Unlike dispatch interceptors, handler interceptors are invoked in the context of the command handler with an active `ProcessingContext`.
This allows them to:

* Register lifecycle callbacks (see xref:processing-context.adoc[`ProcessingContext`])
* Attach correlation data that will propagate to messages created during handling
* Manage transactions around handling
* Access processing phase information

Let's create a handler interceptor that performs authorization:

[source,java]
----
public class AuthorizationInterceptor
        implements MessageHandlerInterceptor<CommandMessage> {

    @Override
    public MessageStream<?> interceptOnHandle(
            CommandMessage message,
            ProcessingContext context,
            MessageHandlerInterceptorChain<CommandMessage> chain) {

        String userId = message.metadata().get("userId");

        if (userId == null) {
            throw new SecurityException("No user ID in metadata");
        }

        if (!"authorized-user".equals(userId)) {
            throw new SecurityException("User not authorized");
        }

        // User is authorized, proceed
        return chain.proceed(message, context);
    }
}
----

You can also perform actions after handling by using the `ProcessingContext`:

[source,java]
----
public class LoggingInterceptor
        implements MessageHandlerInterceptor<CommandMessage> {

    private static final Logger logger =
            LoggerFactory.getLogger(LoggingInterceptor.class);

    @Override
    public MessageStream<?> interceptOnHandle(
            CommandMessage message,
            ProcessingContext context,
            MessageHandlerInterceptorChain<CommandMessage> chain) {

        logger.info("Before handling: {}", message.type());

        // Register action to run after successful handling
        context.whenComplete(ctx -> {
            logger.info("Successfully handled: {}", message.type());
        });

        // Register error handler
        context.onError((ctx, phase, error) -> {
            logger.error("Error handling {}: {}", message.type(), error.getMessage());
        });

        return chain.proceed(message, context);
    }
}
----

Register the interceptor with a `CommandBus`:

[source,java]
----
public void configureCommandBus() {
    MessagingConfigurer.create()
        .registerCommandBus(config -> {
            SimpleCommandBus commandBus = SimpleCommandBus.builder().build();
            commandBus.registerHandlerInterceptor(new AuthorizationInterceptor());
            return commandBus;
        })
        .start();
}
----

[[command-handler-interceptor-annotation]]
==== `@CommandHandlerInterceptor` annotation

You can add a handler interceptor as a `@CommandHandlerInterceptor` annotated method on the aggregate or entity.
This allows you to make decisions based on the current state of the aggregate:

[source,java]
----
public class GiftCard {

    private String state;

    @CommandHandlerInterceptor
    public void intercept(RedeemCardCommand command, InterceptorChain chain) {
        if (this.state.equals(command.getState())) {
            chain.proceed();
        }
        // Otherwise, don't proceed - command is blocked
    }

    @CommandHandler
    public void handle(RedeemCardCommand command) {
        // Handle the command
    }
}
----

Note that the `@CommandHandlerInterceptor` is essentially a more specific implementation of the `@MessageHandlerInterceptor` described <<annotated-MessageHandlerInterceptor,below>>.

== Event interceptors

Similar to command messages, event messages can also be intercepted prior to publishing and handling.

=== Event dispatch interceptors

Any message dispatch interceptors registered to an event bus will be invoked when an event is published.
They have the ability to alter the event message by adding metadata or provide logging capabilities.
These interceptors are always invoked on the thread that published the event.

[source,java]
----
public class EventLoggingDispatchInterceptor
        implements MessageDispatchInterceptor<EventMessage> {

    private static final Logger logger =
            LoggerFactory.getLogger(EventLoggingDispatchInterceptor.class);

    @Override
    public MessageStream<?> interceptOnDispatch(
            EventMessage message,
            ProcessingContext context,
            MessageDispatchInterceptorChain<EventMessage> chain) {

        logger.info("Publishing event: {}", message.type());
        return chain.proceed(message, context);
    }
}
----

Register with an `EventBus`:

[source,java]
----
public void configureEventBus(EventStorageEngine storageEngine) {
    EventBus eventBus = EmbeddedEventStore.builder()
                                          .storageEngine(storageEngine)
                                          .build();
    eventBus.registerDispatchInterceptor(new EventLoggingDispatchInterceptor());
}
----

[[event-handler-interceptors]]
=== Event handler interceptors

Message handler interceptors can take action both before and after event processing.

[source,java]
----
public class EventSecurityInterceptor
        implements MessageHandlerInterceptor<EventMessage> {

    @Override
    public MessageStream<?> interceptOnHandle(
            EventMessage message,
            ProcessingContext context,
            MessageHandlerInterceptorChain<EventMessage> chain) {

        String userId = message.metadata().get("userId");

        if (userId == null || !"authorized-user".equals(userId)) {
            throw new SecurityException("Unauthorized event");
        }

        return chain.proceed(message, context);
    }
}
----

Register with an `EventProcessor`:

[source,java]
----
public void configureEventProcessing() {
    MessagingConfigurer.create()
        .eventProcessing(ep -> ep
            .registerTrackingEventProcessor("my-processor")
            .registerHandlerInterceptor("my-processor",
                config -> new EventSecurityInterceptor())
        )
        .start();
}
----

[NOTE]
.Interceptor Registration
====
Different from the `CommandBus` and `QueryBus`, which both can have handler interceptors and dispatch interceptors, the `EventBus` can only register dispatch interceptors.
This is because the sole purpose of the `EventBus` is event publishing/dispatching.

An `EventProcessor` is in charge of handling event messages, thus event handler interceptors are registered on them directly.
====

== Query interceptors

One of the advantages of using a query bus is the ability to undertake action based on all incoming queries.
Examples are logging or authentication, which you might want to do regardless of the type of query.

=== Query dispatch interceptors

Message dispatch interceptors are invoked when a query is dispatched on a query bus.
They have the ability to alter the message by adding metadata or block the handler execution.

[source,java]
----
public class QueryLoggingDispatchInterceptor
        implements MessageDispatchInterceptor<QueryMessage> {

    private static final Logger logger =
            LoggerFactory.getLogger(QueryLoggingDispatchInterceptor.class);

    @Override
    public MessageStream<?> interceptOnDispatch(
            QueryMessage message,
            ProcessingContext context,
            MessageDispatchInterceptorChain<QueryMessage> chain) {

        logger.info("Dispatching query: {}", message.type());
        return chain.proceed(message, context);
    }
}
----

==== Structural validation

There is no point in processing a query if it does not contain all required information in the correct format.
A query that lacks information should be blocked as early as possible.
Therefore, an interceptor should check all incoming queries for the availability of such information.

Axon Framework has support for JSR 303 Bean Validation.
This allows you to annotate the fields on queries with annotations like `@NotEmpty` and `@Pattern`.
Configure a `BeanValidationInterceptor` on your query bus, and it will automatically find and configure your validator implementation.

[TIP]
.Interceptor Ordering
====
You want to spend as few resources on invalid queries as possible.
Therefore, this interceptor is generally placed at the front of the interceptor chain.
====

The `BeanValidationInterceptor` also implements `MessageHandlerInterceptor`, allowing you to configure it as a handler interceptor as well.

=== Query handler interceptors

Message handler interceptors can take action both before and after query processing.

[source,java]
----
public class QuerySecurityInterceptor
        implements MessageHandlerInterceptor<QueryMessage> {

    @Override
    public MessageStream<?> interceptOnHandle(
            QueryMessage message,
            ProcessingContext context,
            MessageHandlerInterceptorChain<QueryMessage> chain) {

        String userId = message.metadata().get("userId");

        if (userId == null || !"authorized-user".equals(userId)) {
            throw new SecurityException("Unauthorized query");
        }

        return chain.proceed(message, context);
    }
}
----

[[annotated-MessageHandlerInterceptor]]
== Annotated `@MessageHandlerInterceptor`

Alongside defining overall `MessageHandlerInterceptor` instances on the component handling a message, you can also define a handler interceptor for a specific component containing the handlers.
This is achieved by adding a method with the `@MessageHandlerInterceptor` annotation.

Several options are available:

1. **InterceptorChain parameter**: The `InterceptorChain` is an _optional_ parameter which can be added to the intercepting method.
In absence of this parameter, the framework will call `InterceptorChain#proceed` once the method exits.

2. **Message type filtering**: You can define the type of `Message` the interceptor should deal with using the `messageType` parameter.

3. **Payload type filtering**: For fine-grained control, specify the `payloadType` contained in the `Message`.

*Simple `@MessageHandlerInterceptor` method:*

[source,java]
----
public class CardSummaryProjection {

    @MessageHandlerInterceptor
    public void intercept(Message message) {
        // Intercepts all messages to this component
    }

    @EventHandler
    public void on(CardIssuedEvent event) {
        // Handle event
    }
}
----

*Defining the message type:*

[source,java]
----
public class CardSummaryProjection {

    @MessageHandlerInterceptor(messageType = EventMessage.class)
    public void intercept(EventMessage event) {
        // Intercepts only event messages
    }
}
----

*Defining message and payload type:*

[source,java]
----
public class CardSummaryProjection {

    @MessageHandlerInterceptor(
        messageType = EventMessage.class,
        payloadType = CardRedeemedEvent.class
    )
    public void intercept(CardRedeemedEvent event) {
        // Intercepts only CardRedeemedEvent messages
    }
}
----

*Using InterceptorChain for control:*

[source,java]
----
public class CardSummaryProjection {

    @MessageHandlerInterceptor(messageType = QueryMessage.class)
    public void intercept(QueryMessage query, InterceptorChain chain) throws Exception {
        // Logic before handling
        chain.proceed();
        // Logic after handling
    }
}
----

*Hierarchy on aggregate member and root:*

[source,java]
----
public class GiftCard {

    @AggregateIdentifier
    private String id;

    @AggregateMember
    private List<GiftCardTransaction> transactions = new ArrayList<>();

    @MessageHandlerInterceptor
    public void intercept(Message message) {
        // This interceptor will be invoked FIRST
    }
}

public class GiftCardTransaction {

    @EntityId
    private String transactionId;

    @MessageHandlerInterceptor
    public void intercept(Message message) {
        // This interceptor will be invoked SECOND
    }
}
----

[NOTE]
.`@MessageHandlerInterceptor` hierarchy for `@EventSourcingHandler`
====
`@MessageHandlerInterceptor` follows the aggregate hierarchy when applicable.
If an aggregate root has an interceptor, as well as one or several entities, the interceptor chain will "move up" the hierarchy.

However, this support **does not** exist for event sourcing handlers!
Only the interceptors on that level of the hierarchy are invoked.
In the example above, when the `GiftCardTransaction` is event sourced, only its interceptor is invoked, disregarding the one on the `GiftCard` class.

This is a known discrepancy that cannot be easily adjusted in Axon's current structure.
It is not recommended to rely on an invocation hierarchy for `@MessageHandlerInterceptor` annotated methods while sourcing an aggregate.
====

Next to the message, payload, and `InterceptorChain`, a `@MessageHandlerInterceptor` annotated method can resolve other parameters as well.
Which parameters the framework can resolve depends on the type of `Message` being handled by the interceptor.
For more specifics, see xref:supported-parameters-annotated-handlers.adoc[Supported Parameters].

[[ExceptionHandler]]
=== `@ExceptionHandler`

The `@MessageHandlerInterceptor` also allows for a more specific version: an `@ExceptionHandler` annotated method.

The framework invokes `@ExceptionHandler` annotated methods _only_ for exceptional results of message handling.
This allows you to throw more domain-specific exceptions or translate technical exceptions to business errors.

You can wire all xref:supported-parameters-annotated-handlers.adoc[default parameters] to an exception handler, similar to command, event, and query handlers.
Hence, you can add the exception, payload, metadata, and other options.

You can introduce `@ExceptionHandler` annotated methods in any message handling component, including sagas.
You can choose to react to all exceptions or define specific exception/message combinations.

*Aggregate exception handlers:*

[source,java]
----
class GiftCard {

    // State, command handlers and event sourcing handlers omitted

    @ExceptionHandler
    public void handleAll(Exception exception) {
        // Handles all exceptions thrown within this component
    }

    @ExceptionHandler
    public void handleIssueCardExceptions(IssueCardCommand command) {
        // Handles all exceptions from the IssueCardCommand handler
    }

    @ExceptionHandler(payloadType = IssueCardCommand.class)
    public void handleIssueCardExceptions() {
        // Handles all exceptions from the IssueCardCommand handler
    }

    @ExceptionHandler
    public void handleIllegalStateExceptions(IllegalStateException exception) {
        // Handles all IllegalStateExceptions thrown within this component
    }

    @ExceptionHandler(resultType = IllegalStateException.class)
    public void handleIllegalStateExceptions(Exception exception) {
        // Handles all IllegalStateExceptions thrown within this component
    }

    @ExceptionHandler
    public void handleSpecificCase(IssueCardCommand command,
                                   IllegalStateException exception) {
        // Handles IllegalStateExceptions from IssueCardCommand handler
    }

    @ExceptionHandler(
        resultType = IllegalStateException.class,
        payloadType = IssueCardCommand.class
    )
    public void handleSpecificCase() {
        // Handles IllegalStateExceptions from IssueCardCommand handler
    }
}
----

[NOTE]
.Exception Handling for Aggregate Constructors
====
The `@ExceptionHandler` annotated methods require an existing component instance to work.
Because of this, exception handlers *do not* work for (command handling) constructors of an aggregate.

If you expect exceptions on an aggregate's constructor that you need to handle differently, use Axon's xref:commands:command-handlers.adoc#_aggregate_command_handler_creation_policy[creation policy].
====

*Projector exception handlers:*

[source,java]
----
class CardSummaryProjection {

    // Event handlers and query handlers omitted

    @ExceptionHandler
    public void handleAll(Exception exception) {
        // Handles all exceptions thrown within this component
    }

    @ExceptionHandler
    public void handleFindCardQueryExceptions(FindCardQuery query) {
        // Handles all exceptions from the FindCardQuery handler
    }

    @ExceptionHandler(payloadType = FindCardQuery.class)
    public void handleFindCardQueryExceptions() {
        // Handles all exceptions from the FindCardQuery handler
    }

    @ExceptionHandler
    public void handleIllegalArgumentExceptions(IllegalArgumentException exception) {
        // Handles all IllegalArgumentExceptions within this component
    }

    @ExceptionHandler(resultType = IllegalArgumentException.class)
    public void handleIllegalArgumentExceptions(Exception exception) {
        // Handles all IllegalArgumentExceptions within this component
    }

    @ExceptionHandler
    public void handleSpecificCase(CardIssuedEvent event,
                                   IllegalArgumentException exception) {
        // Handles IllegalArgumentExceptions from CardIssuedEvent handler
    }

    @ExceptionHandler(
        resultType = IllegalArgumentException.class,
        payloadType = CardIssuedEvent.class
    )
    public void handleSpecificCase() {
        // Handles IllegalArgumentExceptions from CardIssuedEvent handler
    }
}
----
