= Anatomy of a Message

In Axon, all communication between components is done with explicit messages, represented by the `Message` interface.
A `Message` consists of a message type, payload, and metadata.

[[message_type]]
== Message type

Every message in Axon Framework has a `MessageType`, which identifies what type of message it is - what structure and content you can expect.
This is a fundamental shift from how message types were identified in earlier versions of the framework.

The `MessageType` consists of two parts:

1. A `QualifiedName` - The business or domain name of the message type
2. A `version` - The version of the message structure

This decouples the message type from its Java class representation.
**The Java class is no longer used to identify the type of a message.**
Instead, the `MessageType` identifies what structure the message has, independent of which Java class is used to represent it.

Many messages can have the same `MessageType` - it's a type identifier, not an instance identifier.
For example, all "OrderPlaced v1.0" events share the same `MessageType`, even though each is a distinct message with its own unique <<message-identifier,identifier>>.

=== Benefits of `MessageType`

This approach provides several advantages:

* **Flexibility in representation**: Different services can use different Java classes to represent the same message type
* **Decoupling**: Services don't need to share concrete message class implementations
* **Business alignment**: Message names can reflect business terminology rather than technical class names
* **Version management**: All message types (commands, events, queries) can be versioned consistently

=== Defining message types

You define message types using the `@Command`, `@Event`, or `@Query` annotations on your message classes:

[source,java]
----
@Event(name = "OrderPlaced", version = "1.0")
public class OrderPlacedEvent {
    private final String orderId;
    private final BigDecimal amount;

    // Constructor, getters...
}
----

The annotation parameters control the `MessageType`:

* `namespace` - The namespace or bounded context (defaults to the package name)
* `name` - The business name (defaults to the simple class name)
* `version` - The message version (defaults to "0")

If you don't specify these annotations, Axon will use the fully qualified class name as the `QualifiedName` and "0" as the version, maintaining backward compatibility.

[TIP]
====
Beyond their technical purpose, these annotations serve as documentation in your code.
They make it immediately clear that a class represents a command, event, or query, improving code readability and making your domain model's intent explicit.
====

=== Payload conversion at handling time

Because message identity is decoupled from Java classes, **payloads are converted to the handler's expected type at handling time**.
This is a significant shift from earlier versions where the message had to match the handler's Java class exactly.

Different handlers can receive the same message in different Java representations:

[source,java]
----
// Handler 1: Receives as domain object (OrderPlacedEvent is @Event annotated)
@EventHandler
public void handle(OrderPlacedEvent event) {
    // Payload is converted to OrderPlacedEvent
}

// Handler 2: Receives as JSON (must specify messageType)
@EventHandler(messageType = "com.example.orders.OrderPlaced")
public void handle(JsonNode event) {
    // Same message, converted to JsonNode
}

// Handler 3: Receives as Map (must specify messageType)
@EventHandler(messageType = "com.example.orders.OrderPlaced")
public void handle(Map<String, Object> event) {
    // Same message, converted to Map
}
----

Axon uses the message's `MessageType` to identify which handlers should receive the message, then converts the payload to whatever type each handler needs.
The message identifier remains the same throughout - it's still the same message, just represented in different Java types.

[NOTE]
====
When the first parameter of your handler is not annotated with `@Event` (or `@Command`, `@Query`), you must specify the `messageType` attribute on the handler annotation.
This tells Axon which message type the handler should receive.
====

This approach **reduces the need for upcasters** in many scenarios.
Instead of creating upcasters to convert old message formats to new Java classes during deserialization, you can often just handle messages in different formats and let Axon perform the conversion.

== Payload

The payload contains the information about what happened - the specific data related to the message.
While the message type describes what the message means (for example, "OrderPlaced"), the payload contains the details about that specific occurrence (the order ID, amount, customer details, etc.).

=== Accessing the payload

You can access the payload in different ways:

[source,java]
----
Message message = // ... obtain message

// Get the payload as-is
Object payload = message.payload();

// Get the payload converted to a specific type
OrderPlacedEvent event = message.payloadAs(OrderPlacedEvent.class);

// Get the payload type
Class<?> type = message.payloadType();
----

The `payloadAs(Type)` method converts the payload to the required type at the moment you need it.
In most cases, you don't need to pass a `Converter` explicitly - if the message has passed through converter-aware components (which is typical in Axon), the conversion happens automatically.

If you need explicit control over conversion, you can provide a converter:

[source,java]
----
OrderPlacedEvent event = message.payloadAs(OrderPlacedEvent.class, customConverter);
----

This is useful when you need the same message in different formats at different points in your processing logic.

=== Converting message payloads

If you need to convert a message's payload for downstream processing, use `withConvertedPayload`:

[source,java]
----
EventMessage originalMessage = // ... event with domain object payload

// Create a new message with JSON payload
EventMessage jsonMessage = originalMessage.withConvertedPayload(
    JsonNode.class,
    converter
);
----

This creates a new `Message` instance with the converted payload, leaving the original message unchanged.

[[meta-data]]
== Metadata

Metadata describes the context in which a message was generated.
For example, metadata might contain information about the message that caused this message to be generated, or user information about who triggered the action.

In Axon, metadata is represented as a `Map<String, String>`.
**Both keys and values must be Strings.**
This simplifies serialization and aligns with how most systems and frameworks handle metadata.

Metadata is immutable - mutating methods create and return a new instance instead of modifying an existing one.

=== Creating metadata

[source,java]
----
Metadata metadata = Metadata.with("userId", "user-123") // <1>
                            .and("traceId", "trace-456"); // <2>
----

<1> Creates a `Metadata` instance with a single key-value pair
<2> Adds another entry, returning a new instance with both entries

=== Adding metadata to messages

Messages in Axon are immutable.
To add metadata, you create a new message instance with the additional metadata:

[source,java]
----
EventMessage event = new GenericEventMessage(
    messageType,
    new OrderPlacedEvent(orderId, amount)
);

// Add metadata - creates a new message instance
EventMessage eventWithMetadata = event.withMetadata(
    Metadata.with("userId", "user-123")
);

// Add to existing metadata - merges with any existing entries
EventMessage mergedMessage = eventWithMetadata.andMetadata(
    Metadata.with("correlationId", "corr-789")
);
----

The `withMetadata` method replaces all metadata with the given map.
The `andMetadata` method merges the given metadata with existing entries, with new entries overwriting existing ones with the same key.

[NOTE]
====
Because metadata values must be Strings, you need to convert any non-String values before adding them to metadata:

[source,java]
----
// Convert numbers, booleans, etc. to String
Metadata metadata = Metadata.with("count", String.valueOf(42))
                            .and("enabled", String.valueOf(true));
----
====

== Message-specific data

Different message types provide additional information beyond payload and metadata.

For example:

* An `EventMessage` provides a `timestamp()` representing when the event occurred
* A `CommandMessage` provides a `routingKey()` used to route the command to the correct handler instance

[source,java]
----
EventMessage event = // ...
Instant occurredAt = event.timestamp();
----

[source,java]
----
CommandMessage command = // ...
Optional<String> routingKey = command.routingKey();
----

[[message-identifier]]
== Message identifier

Each message has a unique identifier that identifies that specific message instance.
The identifier remains constant even if the message is represented in different Java classes or if metadata is added.

Two messages with the same identifier represent the same conceptual message, even if:

* Their payloads are represented using different Java classes (for example, domain object vs JSON)
* They have different metadata
* They exist in different services or contexts

[source,java]
----
String id = message.identifier();
----

The identifier is automatically generated when you create a message, or you can provide a specific identifier through the message constructor.

Together, the `MessageType` and `identifier` provide complete message identification:

* The `MessageType` tells you **what type** of message it is (the structure)
* The `identifier` tells you **which specific instance** of that message type it is

== Creating messages

While Axon typically creates messages for you based on method return values and parameters, you can create messages explicitly when needed:

[source,java]
----
// Create an event message
MessageType orderPlacedType = MessageType.of(
    QualifiedName.of("com.example.orders", "OrderPlaced"),
    "1.0"
);

EventMessage event = new GenericEventMessage(
    orderPlacedType,
    new OrderPlacedEvent(orderId, amount),
    Metadata.with("userId", "user-123")
);
----

However, when you use the `@Command`, `@Event`, or `@Query` annotations on your message classes, Axon derives the `MessageType` automatically, so you typically don't need to construct `MessageType` instances yourself.

== Method naming

Message methods use simple accessor naming without the "get" prefix:

* `message.identifier()` - Returns the message identifier
* `message.type()` - Returns the MessageType
* `message.payload()` - Returns the payload
* `message.payloadType()` - Returns the payload's Java type
* `message.metadata()` - Returns the metadata
* `event.timestamp()` - Returns when an event occurred
* `command.routingKey()` - Returns the command routing key (Optional<String>)
