= Configuration

This page describes how to configure command handling in your Axon application.
Configuration in Axon 5 uses the `ApplicationConfigurer` hierarchy, with specialized configurers for different concerns:

* **`MessagingConfigurer`** - For messaging infrastructure (command bus, query bus, event sink)
* **`ModellingConfigurer`** - For domain modeling components
* **`EventSourcingConfigurer`** - For event sourcing and event stores

== Configuration approaches

Axon Framework supports two configuration approaches:

**Spring Boot**::
When using Spring Boot, most configuration happens automatically through annotations and bean definitions.
Components are discovered and registered automatically.

**Configuration API**::
When not using Spring Boot, you use the configurer classes to explicitly configure components.
This gives you full control over component creation and wiring.

== Configuring event-sourced entities

Event-sourced entities are the most common pattern for stateful command handling.

[tabs]
====
Spring Boot::
+
--
Use the `@EventSourced` annotation on your entity class:

[source,java]
----
import org.axonframework.extension.spring.stereotype.EventSourced;
import org.axonframework.messaging.commandhandling.annotation.CommandHandler;
import org.axonframework.eventsourcing.annotation.EventSourcingHandler;

@EventSourced
public class GiftCard {

    private String id;
    private int remainingValue;

    @CommandHandler
    public static GiftCard handle(IssueCardCommand cmd, EventAppender eventAppender) {
        GiftCard card = new GiftCard();
        eventAppender.append(new CardIssuedEvent(cmd.cardId(), cmd.amount()));
        return card;
    }

    @CommandHandler
    public void handle(RedeemCardCommand cmd, EventAppender eventAppender) {
        if (remainingValue >= cmd.amount()) {
            eventAppender.append(new CardRedeemedEvent(id, cmd.amount()));
        }
    }

    @EventSourcingHandler
    private void on(CardIssuedEvent event) {
        this.id = event.cardId();
        this.remainingValue = event.amount();
    }

    @EventSourcingHandler
    private void on(CardRedeemedEvent event) {
        this.remainingValue -= event.amount();
    }
}
----

Spring Boot automatically:

* Discovers the entity through component scanning
* Creates an `EventSourcedRepository` for the entity
* Registers all `@CommandHandler` methods with the command bus
* Configures snapshots if a `SnapshotTriggerDefinition` bean is present

--

Configuration API::
+
--
Use `EventSourcingConfigurer` to register entities:

[source,java]
----
import org.axonframework.eventsourcing.configuration.EventSourcingConfigurer;
import org.axonframework.modelling.configuration.EntityModule;

public class AxonConfig {

    public void configureEntity() {
        EventSourcingConfigurer configurer = EventSourcingConfigurer.create();

        // Register an entity module
        configurer.componentRegistry(registry ->
            registry.registerModule(
                EntityModule.forType(GiftCard.class)
                    .build()
            )
        );
    }
}
----

This creates and registers:

* An `EventSourcedRepository` for the entity
* Command handler subscriptions for all `@CommandHandler` methods
* Event sourcing handlers for state reconstitution

--
====

=== Custom repository configuration

You can customize repository settings like snapshot triggers:

[tabs]
====
Spring Boot::
+
--
Define a repository bean with custom settings:

[source,java]
----
import org.axonframework.eventsourcing.EventSourcedRepository;
import org.axonframework.modelling.repository.Repository;

@Configuration
public class RepositoryConfig {

    @Bean
    public Repository<String, GiftCard> giftCardRepository(
            EventStore eventStore,
            SnapshotTriggerDefinition snapshotTrigger) {
        return EventSourcedRepository.<String, GiftCard>builder()
                .entityType(GiftCard.class)
                .eventStore(eventStore)
                .snapshotTriggerDefinition(snapshotTrigger)
                .build();
    }

    @Bean
    public SnapshotTriggerDefinition snapshotTrigger() {
        return new EventCountSnapshotTriggerDefinition(
            snapshotFilter(),
            50 // Snapshot every 50 events
        );
    }
}
----

Reference the custom repository in your entity:

[source,java]
----
@EventSourced(repositoryBean = "giftCardRepository")
public class GiftCard { /* ... */ }
----

--

Configuration API::
+
--
Configure the repository when registering the entity:

[source,java]
----
import org.axonframework.eventsourcing.configuration.EventSourcingConfigurer;

public class AxonConfig {

    public void configureRepository() {
        EventSourcingConfigurer configurer = EventSourcingConfigurer.create();

        configurer.componentRegistry(registry ->
            registry.registerComponent(
                Repository.class,
                config -> EventSourcedRepository.<String, GiftCard>builder()
                        .entityType(GiftCard.class)
                        .eventStore(config.getComponent(EventStore.class))
                        .snapshotTriggerDefinition(
                            new EventCountSnapshotTriggerDefinition(
                                snapshotFilter(),
                                50
                            )
                        )
                        .build()
            )
        );
    }
}
----

--
====

== Configuring command handlers

Command handlers that don't use entities need explicit registration.

[tabs]
====
Spring Boot::
+
--
Annotate your handler class with `@Component`:

[source,java]
----
import org.springframework.stereotype.Component;
import org.axonframework.messaging.commandhandling.annotation.CommandHandler;

@Component
public class GiftCardCommandHandler {

    private final Repository<String, GiftCard> giftCardRepository;

    public GiftCardCommandHandler(Repository<String, GiftCard> giftCardRepository) {
        this.giftCardRepository = giftCardRepository;
    }

    @CommandHandler
    public void handle(CancelCardCommand cmd,
                      ProcessingContext context,
                      EventAppender eventAppender) {
        giftCardRepository.load(cmd.cardId(), context)
            .thenAccept(managedCard -> {
                GiftCard card = managedCard.entity();
                if (card.canBeCancelled()) {
                    eventAppender.append(new CardCancelledEvent(cmd.cardId()));
                }
            });
    }
}
----

Spring Boot automatically discovers and registers the handler.

--

Configuration API::
+
--
Use `CommandHandlingModule` to register handlers:

[source,java]
----
import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.messaging.commandhandling.configuration.CommandHandlingModule;

public class AxonConfig {

    public void configureCommandHandlers() {
        MessagingConfigurer.create()
            .registerCommandHandlingModule(
                CommandHandlingModule.named("gift-card-commands")
                    .commandHandlers(handlers ->
                        handlers.annotatedCommandHandlingComponent(
                            config -> new GiftCardCommandHandler(
                                config.getComponent(Repository.class)
                            )
                        )
                    )
            );
    }
}
----

The `annotatedCommandHandlingComponent()` method scans for `@CommandHandler` annotations and registers them.

--
====

== Component registration patterns

When using the Configuration API, components are registered using `ComponentBuilder` functions.

=== Basic component registration

Register any component via the component registry:

[source,java]
----
configurer.componentRegistry(registry ->
    registry.registerComponent(
        MyService.class,
        config -> new MyService(
            config.getComponent(SomeDependency.class)
        )
    )
);
----

The `ComponentBuilder` function receives a `Configuration` that provides access to other registered components.

=== Component replacement

Replace default components by registering with the same type:

[source,java]
----
MessagingConfigurer.create()
    .registerCommandBus(config ->
        SimpleCommandBus.builder()
            .transactionManager(config.getComponent(TransactionManager.class))
            .build()
    );
----

The last registration wins - this replaces any previously registered `CommandBus`.

=== Component decoration

Enhance existing components using decorators:

[source,java]
----
import org.axonframework.common.configuration.ComponentDecorator;

configurer.componentRegistry(registry ->
    registry.registerDecorator(
        CommandBus.class,
        (config, component) -> new LoggingCommandBus(component)
    )
);
----

Example decorator that adds logging:

[source,java]
----
public class LoggingCommandBus implements CommandBus {

    private final CommandBus delegate;
    private final Logger logger = LoggerFactory.getLogger(LoggingCommandBus.class);

    public LoggingCommandBus(CommandBus delegate) {
        this.delegate = delegate;
    }

    @Override
    public CompletableFuture<CommandMessage<?>> dispatch(
            CommandMessage<?> command,
            ProcessingContext context) {
        logger.info("Dispatching command: {}", command.commandName());
        return delegate.dispatch(command, context)
            .whenComplete((result, error) -> {
                if (error != null) {
                    logger.error("Command failed: {}", command.commandName(), error);
                } else {
                    logger.info("Command succeeded: {}", command.commandName());
                }
            });
    }

    // Delegate other methods...
}
----

Decorators are applied in registration order and wrap the original component.

== Interceptor registration

Interceptors provide cross-cutting concerns like logging, security, or validation.

=== Dispatch interceptors

Invoked when a message is dispatched, before routing:

[tabs]
====
Spring Boot::
+
--
Define interceptors as beans:

[source,java]
----
@Configuration
public class InterceptorConfig {

    @Bean
    public CommandDispatchInterceptor loggingInterceptor() {
        return (commandMessage) -> {
            logger.info("Dispatching: {}", commandMessage.commandName());
            return commandMessage;
        };
    }
}
----

Spring Boot automatically registers interceptor beans with the appropriate bus.

--

Configuration API::
+
--
Register interceptors explicitly:

[source,java]
----
MessagingConfigurer.create()
    .registerCommandDispatchInterceptor(
        config -> (commandMessage) -> {
            logger.info("Dispatching: {}", commandMessage.commandName());
            return commandMessage;
        }
    );
----

--
====

=== Handler interceptors

Invoked before the actual handler, after routing:

[tabs]
====
Spring Boot::
+
--
Define handler interceptors as beans:

[source,java]
----
@Configuration
public class InterceptorConfig {

    @Bean
    public CommandHandlerInterceptor securityInterceptor() {
        return (message, context, chain) -> {
            checkPermissions(message, context);
            return chain.handle(message, context);
        };
    }
}
----

--

Configuration API::
+
--
Register handler interceptors:

[source,java]
----
MessagingConfigurer.create()
    .registerCommandHandlerInterceptor(
        config -> (message, context, chain) -> {
            checkPermissions(message, context);
            return chain.handle(message, context);
        }
    );
----

--
====

See xref:messaging-concepts:message-intercepting.adoc[Message intercepting] for detailed information on interceptors.

== Configuration builder pattern

When using the Configuration API, you typically chain multiple configurers:

[source,java]
----
import org.axonframework.eventsourcing.configuration.EventSourcingConfigurer;
import org.axonframework.messaging.commandhandling.configuration.CommandHandlingModule;

public class AxonConfig {

    public AxonConfiguration buildConfiguration() {
        return EventSourcingConfigurer.create()
            // Register entities
            .componentRegistry(registry ->
                registry.registerModule(
                    EntityModule.forType(GiftCard.class).build()
                )
            )
            // Register command handlers
            .registerCommandHandlingModule(
                CommandHandlingModule.named("gift-card-commands")
                    .commandHandlers(handlers ->
                        handlers.annotatedCommandHandlingComponent(
                            config -> new GiftCardCommandHandler(
                                config.getComponent(Repository.class)
                            )
                        )
                    )
            )
            // Register interceptors
            .registerCommandHandlerInterceptor(
                config -> (message, context, chain) -> {
                    logger.info("Handling: {}", message.commandName());
                    return chain.handle(message, context);
                }
            )
            // Build and start
            .start();
    }
}
----

The configurer hierarchy allows you to use specialized methods while maintaining a fluent API.

== Configuration enhancers

For advanced scenarios, use configuration enhancers to customize multiple components:

[source,java]
----
import org.axonframework.common.configuration.ConfigurationEnhancer;

public class CustomEnhancer implements ConfigurationEnhancer {

    @Override
    public void enhance(Configuration config) {
        // Customize multiple components based on configuration
        CommandBus commandBus = config.getComponent(CommandBus.class);
        EventStore eventStore = config.getComponent(EventStore.class);

        // Apply custom logic or validation
    }
}
----

Register enhancers during configuration:

[source,java]
----
configurer.componentRegistry(registry ->
    registry.registerEnhancer(new CustomEnhancer())
);
----

Enhancers are invoked during configuration building and can inspect or modify the final configuration.
