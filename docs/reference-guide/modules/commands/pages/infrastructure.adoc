= Infrastructure

Command handling in Axon Framework involves several infrastructure components that work together to dispatch commands, manage entity state, and coordinate command processing across your application.

This page covers the key infrastructure components you'll work with:

* **Repositories** - Manage entity lifecycle and state persistence
* **Command bus** - Routes and dispatches commands to handlers
* **Command gateway** - Provides a convenient API for dispatching commands
* **Command handling components** - Register and manage command handlers

== Repositories

Repositories provide an abstraction for loading and persisting entities.
When you use entities for stateful command handling (see xref:command-handlers.adoc[Command handlers]), repositories manage the entity lifecycle automatically.

=== Why repositories?

Repositories handle several concerns for you:

* **Loading entity state** - Fetch current state from storage (event store or database)
* **Lifecycle management** - Track entity instances during command processing
* **Persistence** - Save state changes when command processing completes
* **Coordination** - Ensure changes are committed as part of the processing context

Without a repository, you'd need to manually load entities, track changes, and persist them - repositories do all of this automatically.

=== Async-native API

Repository operations in Axon 5 are async-native, returning `CompletableFuture` to support non-blocking operations:

[source,java]
----
public interface Repository<ID, E> {
    // Load an existing entity
    CompletableFuture<ManagedEntity<ID, E>> load(ID identifier,
                                                  ProcessingContext context);

    // Load existing or create new entity
    CompletableFuture<ManagedEntity<ID, E>> loadOrCreate(ID identifier,
                                                          ProcessingContext context);

    // Persist a new entity
    ManagedEntity<ID, E> persist(ID identifier, E entity,
                                 ProcessingContext context);
}
----

All repository operations require an active `ProcessingContext`.
Command handlers automatically receive a `ProcessingContext` parameter that you pass to repository methods.

=== ManagedEntity

Repositories return entities wrapped in a `ManagedEntity` interface.
This wrapper tracks the entity's lifecycle and enables the repository to detect and persist changes.

[source,java]
----
public interface ManagedEntity<ID, E> {
    ID identifier();           // Get the entity identifier
    E entity();               // Get the current entity state
    E applyStateChange(UnaryOperator<E> change);  // Modify entity state
}
----

The `ManagedEntity` wrapper ensures that:

* Changes to entity state are tracked
* State modifications are persisted when the processing context commits
* The repository maintains consistent state throughout command processing

=== Using repositories in command handlers

When command handlers are not on the entity itself, you use a repository to load and manage entities manually.
This pattern is covered in xref:command-handlers.adoc#_command_centric_stateful_handlers[Command-centric stateful handlers].

[source,java]
----
@Component
public class OrderCommandHandler {

    private final Repository<String, Order> orderRepository;

    public OrderCommandHandler(Repository<String, Order> orderRepository) {
        this.orderRepository = orderRepository;
    }

    @CommandHandler
    public void handle(ShipOrderCommand command,
                      ProcessingContext context,
                      EventAppender eventAppender) {
        // Load the entity
        orderRepository.load(command.orderId(), context)
            .thenAccept(managedOrder -> {
                Order order = managedOrder.entity();
                // Apply business logic
                if (order.canShip()) {
                    eventAppender.append(new OrderShippedEvent(command.orderId()));
                }
            });
    }
}
----

=== EventSourcedRepository

The most common repository implementation is `EventSourcedRepository`, which manages event-sourced entities.

Configuration with Spring Boot:

[source,java]
----
@Configuration
public class AxonConfig {

    @Bean
    public Repository<String, Order> orderRepository(
            EventStore eventStore,
            SnapshotTriggerDefinition snapshotTrigger) {
        return EventSourcedRepository.<String, Order>builder()
                .entityType(Order.class)
                .eventStore(eventStore)
                .snapshotTriggerDefinition(snapshotTrigger)
                .build();
    }
}
----

Configuration with Configuration API:

[source,java]
----
import org.axonframework.eventsourcing.configuration.EventSourcingConfigurer;

public class AxonConfig {

    public void configureRepository() {
        EventSourcingConfigurer configurer = EventSourcingConfigurer.create();

        configurer.componentRegistry(registry ->
            registry.registerComponent(
                Repository.class,
                config -> EventSourcedRepository.<String, Order>builder()
                        .entityType(Order.class)
                        .eventStore(config.getComponent(EventStore.class))
                        .build()
            )
        );
    }
}
----

NOTE: When using `@EventSourced` annotation on your entity class with Spring Boot, the repository is automatically configured and registered. You only need manual configuration for external command handlers or custom repository settings.

== Command bus

The command bus is responsible for routing commands to their registered handlers.
It receives commands from gateways or dispatchers and invokes the appropriate command handler.

=== SimpleCommandBus

The `SimpleCommandBus` is the standard command bus implementation.
It processes commands in the same thread that dispatches them, which works well for most applications including web applications.

Key characteristics:

* **Synchronous processing** - Commands are handled in the caller's thread
* **Simple and reliable** - Straightforward processing model
* **Good performance** - Low overhead for command handling
* **Single JVM** - Cannot distribute commands across multiple instances

Spring Boot automatically configures a `SimpleCommandBus` when using the Axon Spring Boot starter (unless Axon Server is configured).

Manual configuration:

[tabs]
====
Configuration API::
+
--
[source,java]
----
import org.axonframework.messaging.core.configuration.MessagingConfigurer;

public class AxonConfig {

    public void configureCommandBus() {
        MessagingConfigurer configurer = MessagingConfigurer.create();

        configurer.registerCommandBus(config ->
            SimpleCommandBus.builder()
                    .transactionManager(config.getComponent(TransactionManager.class))
                    .build()
        );
    }
}
----
--

Spring Boot::
+
--
[source,java]
----
@Configuration
public class AxonConfig {

    @Bean
    public CommandBus commandBus(TransactionManager transactionManager,
                                GlobalMetricRegistry metricRegistry) {
        return SimpleCommandBus.builder()
                .transactionManager(transactionManager)
                .messageMonitor(metricRegistry.registerCommandBus("commandBus"))
                .build();
    }
}
----
--
====

=== Interceptors

The command bus supports interceptors for cross-cutting concerns like logging, metrics, or validation.

There are two types of interceptors:

* **Dispatch interceptors** - Invoked when a command is dispatched, before routing
* **Handler interceptors** - Invoked before the actual command handler, after routing

See xref:messaging-concepts:message-intercepting.adoc#command-interceptors[Command interceptors] for details on implementing and registering interceptors.

== Command gateway

The command gateway provides a convenient, type-safe API for dispatching commands.
While you can dispatch commands directly through the command bus, the gateway is generally the easiest option.

=== Using the default CommandGateway

The `CommandGateway` interface provides several methods for sending commands:

[source,java]
----
public interface CommandGateway {
    // Send and wait for result
    <R> R sendAndWait(Object command);

    // Send and get CompletableFuture
    <R> CompletableFuture<R> send(Object command);

    // Send without waiting for result
    void sendAndForget(Object command);
}
----

Example usage:

[source,java]
----
@RestController
public class OrderController {

    private final CommandGateway commandGateway;

    public OrderController(CommandGateway commandGateway) {
        this.commandGateway = commandGateway;
    }

    @PostMapping("/orders")
    public CompletableFuture<String> createOrder(@RequestBody CreateOrderRequest request) {
        CreateOrderCommand command = new CreateOrderCommand(
            UUID.randomUUID().toString(),
            request.getProductId(),
            request.getQuantity()
        );

        // Returns CompletableFuture<String> with the order ID
        return commandGateway.send(command);
    }

    @PostMapping("/orders/{id}/ship")
    public void shipOrder(@PathVariable String id) {
        // Fire and forget
        commandGateway.sendAndForget(new ShipOrderCommand(id));
    }
}
----

Spring Boot automatically provides a `CommandGateway` bean that you can inject.

=== Creating a custom command gateway

You can create a custom gateway interface with domain-specific methods.
Axon generates an implementation at runtime based on method signatures:

[source,java]
----
public interface OrderGateway {

    // Returns CompletableFuture for async processing
    CompletableFuture<String> createOrder(CreateOrderCommand command);

    // Void return = fire and forget
    void shipOrder(ShipOrderCommand command);

    // Synchronous with timeout
    @Timeout(value = 5, unit = TimeUnit.SECONDS)
    void cancelOrder(CancelOrderCommand command) throws TimeoutException;

    // With metadata
    String placeOrder(CreateOrderCommand command,
                     @MetadataValue("userId") String userId);
}
----

Method behavior is determined by:

* **Return type**:
  - `void` - Fire and forget (returns immediately)
  - `CompletableFuture<R>` - Async (returns immediately with future)
  - Any other type - Synchronous (blocks until result available)

* **Parameters**:
  - First parameter - The command to dispatch
  - `@MetadataValue` - Add metadata to the command
  - `CommandCallback` - Callback for result handling

* **Exceptions**:
  - Checked exceptions - Thrown if handler throws them
  - `@Timeout` annotation - Configure timeout behavior

Creating the gateway:

[tabs]
====
Spring Boot::
+
--
[source,java]
----
@Configuration
public class AxonConfig {

    @Bean
    public OrderGateway orderGateway(CommandBus commandBus) {
        return CommandGatewayFactory.builder()
                .commandBus(commandBus)
                .build()
                .createGateway(OrderGateway.class);
    }
}
----
--

Configuration API::
+
--
[source,java]
----
public class AxonConfig {

    public OrderGateway orderGateway(ApplicationConfigurer configurer) {
        return CommandGatewayFactory.builder()
                .commandBus(configurer.commandBus())
                .build()
                .createGateway(OrderGateway.class);
    }
}
----
--
====

== Command handling component registration

Command handlers need to be registered with the framework so commands can be routed to them.

=== Spring Boot auto-registration

With Spring Boot, command handlers are automatically discovered and registered when you:

* Use `@Component` or `@Service` on handler classes
* Use `@EventSourced` on entity classes with command handlers

[source,java]
----
@Component
public class OrderCommandHandler {

    @CommandHandler
    public void handle(CreateOrderCommand command) {
        // Handler implementation
    }
}
----

[source,java]
----
@EventSourced
public class Order {

    @CommandHandler
    public static Order handle(CreateOrderCommand command) {
        // Creation handler
        return new Order(command.orderId(), command.productId());
    }
}
----

=== Manual registration with Configuration API

When not using Spring Boot, register command handlers using `CommandHandlingModule`:

[source,java]
----
import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.messaging.commandhandling.configuration.CommandHandlingModule;

public class AxonConfig {

    public void configureHandlers() {
        MessagingConfigurer.create()
            .registerCommandHandlingModule(
                CommandHandlingModule.named("order-commands")
                    .commandHandlers(handlers ->
                        handlers.annotatedCommandHandlingComponent(
                            config -> new OrderCommandHandler(
                                config.getComponent(Repository.class)
                            )
                        )
                    )
            );
    }
}
----

The `annotatedCommandHandlingComponent()` method scans the handler for `@CommandHandler` annotated methods and registers them with the command bus.

For registering event-sourced entities and their repositories, use `EventSourcingConfigurer` or `ModellingConfigurer` which provide entity-specific registration methods.

== Distributed command bus

For applications that need to distribute command handling across multiple JVM instances, Axon provides distributed command bus implementations.

=== AxonServerCommandBus

The `AxonServerCommandBus` connects to https://www.axoniq.io/products/axon-server[Axon Server,window=_blank,role=external] for distributed command routing.
This is the default when using the Axon Spring Boot starter with `axon-server-connector` dependency.

With Spring Boot:

[source,xml]
----
<dependency>
    <groupId>org.axonframework</groupId>
    <artifactId>axon-spring-boot-starter</artifactId>
    <version>${axon.version}</version>
</dependency>
----

Configure connection in `application.properties`:

[source,properties]
----
axon.axonserver.servers=localhost:8124
axon.axonserver.enabled=true
----

To disable Axon Server and use local command bus instead:

[source,properties]
----
axon.axonserver.enabled=false
----

=== DistributedCommandBus

The `DistributedCommandBus` provides an alternative for distributing commands using other messaging infrastructure.

Extensions are available for:

* xref:spring-cloud-extension-reference::index.adoc[Spring Cloud]
* xref:jgroups-extension-reference::index.adoc[JGroups]

Enable distributed command bus with these extensions:

[source,properties]
----
axon.distributed.enabled=true
----

See the respective extension documentation for configuration details.

=== Routing strategy

Distributed command buses use a routing strategy to determine which instance should handle each command.
Commands with the same routing key always go to the same instance (when topology is stable).

The default `AnnotationRoutingStrategy` uses the `routingKey` attribute on the `@Command` annotation:

[source,java]
----
@Command(routingKey = "orderId")
public class ShipOrderCommand {

    private final String orderId;
    private final String trackingNumber;

    // constructor, getters
}
----

The `routingKey` attribute specifies which property of the command should be used for routing.
Commands with the same routing key value will be routed to the same instance.

[NOTE]
====
It's recommended to annotate all command classes with `@Command` to explicitly declare their message properties, including namespace, name, version, and routing key.
This makes your commands self-documenting and ensures consistent message identification across your application.
====

Custom routing strategies can be configured:

[tabs]
====
Configuration API::
+
--
[source,java]
----
import org.axonframework.messaging.core.configuration.MessagingConfigurer;

public class AxonConfig {

    public void configureRoutingStrategy() {
        MessagingConfigurer configurer = MessagingConfigurer.create();

        configurer.componentRegistry(registry ->
            registry.registerComponent(
                RoutingStrategy.class,
                config -> new AnnotationRoutingStrategy()
            )
        );
    }
}
----
--

Spring Boot::
+
--
[source,java]
----
@Configuration
public class AxonConfig {

    @Bean
    public RoutingStrategy routingStrategy() {
        // Use default (Command.class annotation)
        return new AnnotationRoutingStrategy();
    }
}
----

You can also use `MetadataRoutingStrategy` to route based on metadata values:

[source,java]
----
@Configuration
public class AxonConfig {

    @Bean
    public RoutingStrategy routingStrategy() {
        return new MetadataRoutingStrategy("routingKey");
    }
}
----
--
====
