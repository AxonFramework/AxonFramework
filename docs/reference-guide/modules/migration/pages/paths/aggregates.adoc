= Aggregate Migration
:navtitle: Aggregates

The focus of this guide is to help you migrate your existing Axon Framework 4 aggregate-based applications to Axon Framework 5 with minimal architectural changes. While we encourage exploring the benefits of DCB for new development or significant refactorings, the following steps provide an "architecture-neutral" path to get your code running on the new version.

Throughout this documentation, we will refer to **entities** instead of aggregates to align with the new API, but the underlying patterns of state-encapsulation and command handling remain familiar.

[NOTE]
.DCB is not a requirement for migration
====
While Axon Framework 5 introduces Dynamic Consistency Boundaries (DCB) and moves away from the strict `Aggregate` terminology towards a more flexible `Entity` model, it is important to note that switching to DCB is not a requirement for migrating from Axon Framework 4 to 5.
====

== Core Concepts in Axon Framework 5

Before diving into the specific changes, it is helpful to understand the primary components that replace the aggregate-centric API in Axon Framework 4.

* **`@EventSourced`**: The replacement for `@Aggregate`. It marks a class as an event-sourced entity, signaling to the framework that its state should be managed and reconstructed from an event stream.
* **`@EntityCreator`**: A mandatory annotation that tells Axon how to instantiate your entity. In Axon Framework 4, the framework often relied on a `@CommandHandler` constructor; in Axon Framework 5, the instantiation is decoupled from the command handling logic.
* **`EventAppender`**: The interface that replaces `AggregateLifecycle.apply()`. It is passed as an argument to command handlers, making the side-effect of publishing events explicit and easier to test.
* **`ProcessingContext`**: The underlying context for any message processing. While often used implicitly via `EventAppender`, it provides access to the unit of work and metadata during command execution.

== Overview

To visualize the shift, here is a side-by-side comparison of a standard `GiftCard` implementation. These examples represent the minimal, architecture-neutral way to move from Axon Framework 4 to 5.

[tabs]
====
Axon Framework 4::
+
[source,java]
----
@Aggregate
public class GiftCard {

    @AggregateIdentifier
    private String cardId;
    private int remainingValue;

    public GiftCard() {
        // Required by Axon
    }

    @CommandHandler
    public GiftCard(IssueCardCommand cmd) {
        AggregateLifecycle.apply(new CardIssuedEvent(cmd.getCardId(), cmd.getAmount()));
    }

    @CommandHandler
    public void handle(RedeemCardCommand cmd) {
        if (cmd.getAmount() > remainingValue) {
            throw new IllegalStateException("Insufficient funds");
        }
        AggregateLifecycle.apply(new CardRedeemedEvent(cardId, cmd.getAmount()));
    }

    @EventSourcingHandler
    public void on(CardIssuedEvent event) {
        this.cardId = event.getCardId();
        this.remainingValue = event.getAmount();
    }

    @EventSourcingHandler
    public void on(CardRedeemedEvent event) {
        this.remainingValue -= event.getAmount();
    }
}
----

Axon Framework 5::
+
[source,java]
----
@EventSourced // <1>
public class GiftCard {

    private String cardId;
    private int remainingValue;

    @EntityCreator // <2>
    public GiftCard() {
    }

    @CommandHandler // <3>
    public static void handle(IssueCardCommand cmd, EventAppender eventAppender) {
        eventAppender.append(new CardIssuedEvent(cmd.cardId(), cmd.amount()));
    }

    @CommandHandler // <4>
    public void handle(RedeemCardCommand cmd, EventAppender eventAppender) {
        if (cmd.amount() > remainingValue) {
            throw new IllegalStateException("Insufficient funds");
        }
        eventAppender.append(new CardRedeemedEvent(cardId, cmd.amount()));
    }

    @EventSourcingHandler
    public void on(CardIssuedEvent event) {
        this.cardId = event.cardId();
        this.remainingValue = event.amount();
    }

    @EventSourcingHandler
    public void on(CardRedeemedEvent event) {
        this.remainingValue -= event.amount();
    }
}
----
<1> `@EventSourced` replaces `@Aggregate`.
<2> `@EntityCreator` is now mandatory for instantiation.
<3> Creation logic moves to a **static** factory method.
<4> `EventAppender` is explicitly passed to handle event publication.
====

== Detailed Step by Step Migration

The following sections detail the minimal changes required to migrate your aggregates to the new entity-based model in Axon Framework 5.


=== Removal of @AggregateIdentifier

In Axon Framework 4, the `@AggregateIdentifier` annotation was used on a field in the aggregate to mark it as the identifier. 
In Axon Framework 5, the identifier is typically specified during the configuration of the entity, or injected into the `@EntityCreator`.

[source,java]
----
// Axon Framework 4
@Aggregate
public class GiftCard {
    @AggregateIdentifier
    private String cardId;
    // ...
}

// Axon Framework 5
@EventSourced
public class GiftCard {
    private String cardId; // No annotation needed on the field

    @EntityCreator // <1>
    public GiftCard() {
    }
}
----
<1> When using a no-arg `@EntityCreator`, the identifier is typically set in the `@EventSourcingHandler` of the creation event.

=== Import Changes for Handlers

The location of `@CommandHandler` and `@EventSourcingHandler` has changed to better reflect their role in the messaging and event sourcing modules. 
For a more comprehensive list of package changes, see the xref:migration:paths/index.adoc#import-and-package-changes[general import changes] section.

[cols="1,2"]
|===
| Axon Framework 4 Import | Axon Framework 5 Import

| `org.axonframework.modelling.command.CommandHandler`
| `org.axonframework.messaging.commandhandling.annotation.CommandHandler`

| `org.axonframework.eventsourcing.EventSourcingHandler`
| `org.axonframework.eventsourcing.annotation.EventSourcingHandler`
|===

=== Static Factory Methods for Creation

Axon Framework 4 often used constructors annotated with `@CommandHandler` to create new aggregate instances.
Axon Framework 5 favors **static factory methods** for command handling of creation commands, combined with the `@EntityCreator` annotation for instance instantiation. This is the recommended way to migrate your creation constructors.

[source,java]
----
// Axon Framework 4
@Aggregate
public class GiftCard {
    @CommandHandler
    public GiftCard(IssueCardCommand cmd) {
        apply(new CardIssuedEvent(cmd.getCardId(), cmd.getAmount()));
    }
}

// Axon Framework 5
@EventSourced
public class GiftCard {
    @EntityCreator
    public GiftCard() { } // Required for the framework to instantiate

    @CommandHandler
    public static void handle(IssueCardCommand cmd, EventAppender eventAppender) {
        eventAppender.append(new CardIssuedEvent(cmd.cardId(), cmd.amount()));
    }
}
----

=== EventAppender instead of AggregateLifecycle

The `AggregateLifecycle.apply()` method is replaced by the `EventAppender` interface, which is passed as a parameter to your command handling methods. This makes the dependency on the event publishing mechanism explicit.

[source,java]
----
// Axon Framework 4
@CommandHandler
public void handle(RedeemCardCommand cmd) {
    AggregateLifecycle.apply(new CardRedeemedEvent(id, cmd.getAmount()));
}

// Axon Framework 5
@CommandHandler
public void handle(RedeemCardCommand cmd, EventAppender eventAppender) {
    eventAppender.append(new CardRedeemedEvent(id, cmd.amount()));
}
----

=== @EntityCreator Annotation

The `@EntityCreator` annotation is a **hard requirement** in Axon Framework 5 for event-sourced entities. It tells Axon how to create an initial instance of the entity before applying events to it.

There are three common patterns for using `@EntityCreator`:

. **Pattern 1: No-arg constructor** (Recommended for most migrations)
+
[source,java]
----
@EntityCreator
public GiftCard() { }
----
Axon creates an empty instance. The identifier and other relevant states are then initialized in the `@EventSourcingHandler` for the first event.

. **Pattern 2: Identifier-only constructor**
+
[source,java]
----
@EntityCreator
public GiftCard(@InjectEntityId String cardId) {
    this.cardId = cardId;
}
----
Axon resolves the identifier from the first event and injects it into the constructor. Note the mandatory `@InjectEntityId` annotation.

. **Pattern 3: Creation from origin event**
+
[source,java]
----
@EntityCreator
public GiftCard(CardIssuedEvent event) {
    this.cardId = event.cardId();
    this.remainingValue = event.amount();
}
----
Axon uses the first event's payload to construct the initial instance directly.

=== @EntityMember instead of @AggregateMember

When defining child entities within an aggregate (now entity), use `@EntityMember` instead of `@AggregateMember`.

[source,java]
----
// Axon Framework 4
@AggregateMember
private List<Transaction> transactions;

// Axon Framework 5
@EntityMember
private List<Transaction> transactions;
----

=== @EventSourcedEntity instead of @AggregateRoot

The `@AggregateRoot` annotation is replaced by `@EventSourcedEntity`. In Axon Framework 5, this annotation (or `@EventSourced` in Spring) is a requirement for the framework to recognize and manage the entity.

=== Removal of @CreationPolicy

The `@CreationPolicy` annotation is removed. The recommended flow is to use a **static `@CommandHandler`** for creation. If the command should only succeed if the entity doesn't exist, the static handler naturally handles this as it is called when no instance is present. This is the direct replacement for `CreationPolicy.ALWAYS`.

If you need "create if missing" logic (equivalent to `CreationPolicy.CREATE_IF_MISSING`), you can implement it within the static handler by checking for existence via the `EventCriteria` and a dispatcher, or by providing multiple handlers. However, for a standard migration, most creation logic can be moved to static methods.

=== Polymorphic Entities

In Axon Framework 4, polymorphic aggregates were configured using `@Aggregate` on the base class and sub-classes. In Axon Framework 5, you register the hierarchy through the `EventSourcedEntityModule`.

[source,java]
----
// Axon Framework 5 Configuration snippet
configurer.modelling().registerEventSourcedEntity(
    EventSourcedEntityModule.polymorphic(GiftCard.class)
                            .registerSubtype(SpecialGiftCard.class)
                            .registerSubtype(LimitedGiftCard.class)
);
----

=== @EventSourced instead of @Aggregate (Spring)

For Spring Boot users, the `@Aggregate` annotation is replaced by `@EventSourced`.

[source,java]
----
// Axon Framework 4
@Aggregate
public class GiftCard {
    // ...
}

// Axon Framework 5
@EventSourced
public class GiftCard {
    // ...
}
----

=== EventSourcedEntityModule instead of AggregateConfigurer

The declarative configuration of entities now uses the `EventSourcedEntityModule` instead of `AggregateConfigurer`. This aligns with the new modular configuration architecture of Axon Framework 5.

[source,java]
----
// Axon Framework 5
public void configure(EventSourcingConfigurer configurer) {
    configurer.modelling().registerEventSourcedEntity(
        EventSourcedEntityModule.repository(GiftCard.class)
                                .entityIdResolver(new MyCustomIdResolver())
    );
}
----

== See Also

For more information on the new modeling patterns, including how to use the `@EventCriteriaBuilder` and immutable entities, please refer to:

- xref:commands:command-handlers.adoc#stateful-command-handlers[Stateful Command Handlers]
- xref:migration:understanding-architecture-principles.adoc#moving-away-from-aggregates[Architecture Principles: Moving away from Aggregates]
- xref:events:event-store-internals.adoc[Event Store Internals and DCB]
- link:https://www.axoniq.io/blog/dcb-in-af-5[Dynamic Consistency Boundary Blog Post]
