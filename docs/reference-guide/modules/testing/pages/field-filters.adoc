= Then-phase: Field Filters

When testing message handling, the fixture compares expected and actual messages using field-by-field equality.
Field filters control which fields are included in this comparison, allowing you to ignore non-deterministic fields like timestamps and UUIDs.

To explain the benefits of field filters, let us look at the following example event:

[source,java]
----
public record AccountCreatedEvent(
    String accountId,
    double initialBalance
) {
}
----

When testing, you want to verify the `initialBalance`, but not the `accountId` since it is generated at runtime.
Hence, it will differ for every run.
As such, a plain test as shown below would not work:

[source,java]
----
import org.axonframework.test.fixture.AxonTestFixture;

class AccountTest {

    private AxonTestFixture fixture;

    @Test
    void test() {
        fixture.given()
               .noPriorActivity()
               .when()
               .command(new CreateAccountCommand(500.00))
               .then()
               .events(new AccountCreatedEvent("???", 500.00));
               // Verify fails as we are unaware of the accountId
    }
}
----

The field filter solves this problem by instructing the fixture that certain fields can be "filtered" from verification.
Any registered field filters are applied during comparison in the then-phase following these steps:

1. The fixture recursively examines all fields of expected and actual (nested) objects.
2. For each field, all registered field filters are consulted.
3. If any filter returns `false`, the field is skipped.
4. Only fields that pass all filters are compared.

Before we look at <<registering_field_filters,registering field filters>> and <<example_field_filter_usages,common examples>>, it is good to know the alternatives.
This will allow you to take the most reasonable course of action for your application.

* The test fixtures provide lambda verification methods, like xref:basic-testing.adoc#then_event_satisfies[`eventsSatisfy(...)`] xref:basic-testing.adoc#then_event_matches[`eventsMatch(...)`], xref:basic-testing.adoc#then_command_satisfies[`commandsSatisfy(...)`], and xref:basic-testing.adoc#then_command_matches[`commandsMatch(...)`].
* Inject mockable services that generate the fields you need to ignore.
This provides control over the returned result and thus the verified result.
Hence, field filters would become obsolete when services can be mocked.

[#registering_field_filters]
== Registering field filters

To register field filters with the test fixture, you need to customize it.
Hence, instead of using `AxonTestFixture#with(ApplicationConfigurer)`, you use the `AxonTestFixture#with(ApplicationConfigurer, UnaryOperator<Customization>)` operation.
The lambda on the `Customization` provides two methods to register field filters, which are:

1. `Customization#registerIgnoredField(Class<?> declaringClass, String fieldName)`
2. `Customization#registerFieldFilter(FieldFilter)`

Thus, if you want to ignore a field for a specific message, you can use the `registerIgnoredField` operation:

[source,java]
----
import org.axonframework.common.configuration.ApplicationConfigurer;
import org.axonframework.test.fixture.AxonTestFixture;
import org.junit.jupiter.api.*;

class AccountTest {

    private ApplicationConfigurer configurer;

    private AxonTestFixture fixture;

    @BeforeEach
    void setUp() {
        fixture = AxonTestFixture.with(
                configurer,
                customization -> customization.registerIgnoredField(
                        AccountCreatedEvent.class, "accountId"
                )
        );
    }
}
----

With this filter in place, the fixture will ignore fields named `"accountId"` for messages with the payload type `AccountCreatedEvent`.
If you need more control, you can provide a (custom) `FieldFilter` through the `registerFieldFilter` method:

[source,java]
----
import org.axonframework.common.configuration.ApplicationConfigurer;
import org.axonframework.test.fixture.AxonTestFixture;
import org.junit.jupiter.api.*;

class AccountTest {

    private ApplicationConfigurer configurer;

    private AxonTestFixture fixture;

    @BeforeEach
    void setUp() {
        fixture = AxonTestFixture.with(
                configurer,
                customization -> customization.registerFieldFilter(
                        field -> !field.getName().equals("accountId")
                )
        );
    }
}
----

The above example will filter out **all** occurrences of fields name `"accountId"` regardless of the message type.
Note that the `FieldFilter` is a functional interface:

[source,java]
----
@FunctionalInterface
public interface FieldFilter {
    boolean accept(Field field);
}
----

Returning `true` will include the field in comparison.
Thus `false` will ignore it.

=== Built-in field filters

Axon provides several built-in field filters that you can use instead of constructing your own:

1. `AllFieldsFilter` - Accepts all fields (the default behavior).
2. `NonStaticFieldsFilter` - Excludes static fields from comparison.
3. `NonTransientFieldsFilter` - Excludes transient fields from comparison.
4. `IgnoreField` - Ignores a specific field; this is what `registerIgnoredField()` uses internally.
5. `MatchAllFieldFilter` - Combines multiple filters using AND logic (all filters must accept the field).

[#example_field_filter_usages]
== Example field filter usages

The tabs below show a couple of common scenarios for which you could use field filters in your test fixtures,

[tabs]
======
Filter timestamp fields::
+
--

This custom `FieldFilter` registered below will ignore fields that are named `"timestamp"`, `"createdate"`, or `"updatedate"`, and if the type is an `Instant`.

[source,java]
----
import org.axonframework.common.configuration.ApplicationConfigurer;
import org.axonframework.test.fixture.AxonTestFixture;

import java.time.Instant;

class AccountTest {

    private ApplicationConfigurer configurer;

    private AxonTestFixture fixture;

    @BeforeEach
    void setUp() {
        fixture = AxonTestFixture.with(
                configurer,
                customization -> customization.registerFieldFilter(field -> {
                    String name = field.getName();
                    return !(name.contains("timestamp")
                            || name.contains("createDate")
                            || name.contains("updateDate"))
                            && !field.getType().equals(Instant.class);
                })
        );
    }
}
----
--

Filter identifier fields::
+
--

This custom `FieldFilter` registered below will ignore fields that are contain `"id"` in the name and are of type `UUID`.

[source,java]
----
import org.axonframework.common.configuration.ApplicationConfigurer;
import org.axonframework.test.fixture.AxonTestFixture;
import org.junit.jupiter.api.*;

import java.util.UUID;

class AccountTest {

    private ApplicationConfigurer configurer;

    private AxonTestFixture fixture;

    @BeforeEach
    void setUp() {
        fixture = AxonTestFixture.with(
                configurer,
                customization -> customization.registerFieldFilter(
                        field -> !field.getType().equals(UUID.class)
                                && !field.getName().toLowerCase().contains("id")
                )
        );
    }
}
----
--

Filter annotated fields::
+
--

You can filter on annotations as well, since the `FieldFilter` receive a `Field`.
Thus, you can define a custom annotation to mark fields that should be ignored.
In the example below, we have constructed an `@IgnoreInTest` annotation that we filter on.

[source,java]
----
import org.axonframework.common.configuration.ApplicationConfigurer;
import org.axonframework.test.fixture.AxonTestFixture;
import org.junit.jupiter.api.*;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
@interface IgnoreInTest {
    // Annotation is named as-s for example purposes only!
}

record AccountCreatedEvent(
        @IgnoreInTest String accountId,
        double amount
) {
}

class AccountTest {

    private ApplicationConfigurer configurer;

    private AxonTestFixture fixture;

    @BeforeEach
    void setUp() {
        fixture = AxonTestFixture.with(
                configurer,
                customization -> customization.registerFieldFilter(
                        field -> !field.isAnnotationPresent(IgnoreInTest.class)
                )
        );
    }
}
----

--

Combining filters::
+
--
Combine multiple filters.
All filters are combined with AND logic - a field must pass all filters to be included.

[source,java]
----
import org.axonframework.common.configuration.ApplicationConfigurer;
import org.axonframework.test.fixture.AxonTestFixture;
import org.axonframework.test.matchers.NonTransientFieldsFilter;
import org.junit.jupiter.api.*;

class AccountTest {

    private ApplicationConfigurer configurer;

    private AxonTestFixture fixture;

    @BeforeEach
    void setUp() {
        fixture = AxonTestFixture.with(configurer, AccountTest::registerFilters);
    }

    private static AxonTestFixture.Customization registerFilters(
            AxonTestFixture.Customization customization
    ) {
        return customization.registerIgnoredField(AccountCreatedEvent.class, "accountId")
                            .registerIgnoredField(OrderCreatedEvent.class, "orderId")
                            .registerFieldFilter(NonTransientFieldsFilter.instance())
                            .registerFieldFilter(field -> !field.getName().contains("internal"));
    }
}
----
--
======