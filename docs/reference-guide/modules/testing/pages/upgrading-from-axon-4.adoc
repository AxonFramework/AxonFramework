= Upgrading from Axon 4

This page explains what's new in Axon Framework 5 testing and provides guidance for migrating from Axon 4 test fixtures.

== What's new in Axon 5 testing

Axon Framework 5 introduces a unified testing approach with significant improvements:

**Single unified test fixture**::
`AxonTestFixture` replaces `AggregateTestFixture`, `SagaTestFixture`, and other specialized fixtures.
One API for all testing scenarios.

**Configurer-based approach**::
Uses the same `ApplicationConfigurer` as production code.
No duplicate configuration between tests and production.

**Support for all message types**::
Test commands, events, and queries with the same fixture.
Consistent API across all message types.

**Type-safe phase transitions**::
Compile-time safety ensures correct test structure.
Different Then types based on When action (Command/Event/Nothing).

**Enhanced integration testing**::
Test with real infrastructure components (event stores, processors).
Verify serialization, conversion, and complete message flows.

**Better extensibility**::
Custom matchers, field filters, and validation logic.
Easy integration with testing frameworks.

== Why the change?

=== Problems with Axon 4 approach

**Duplicate configuration:**

In Axon 4, you configured your application one way for production and another way for tests:

[source,java]
----
// Production (Axon 4)
@Configuration
public class AxonConfig {
    @Bean
    public EventSourcingRepository<Account> accountRepository() {
        return EventSourcingRepository.builder(Account.class)
            .eventStore(eventStore())
            .build();
    }
}

// Tests (Axon 4)
var fixture = new AggregateTestFixture<>(Account.class);
fixture.registerAnnotatedCommandHandler(new AccountCommandHandler());
// Duplicate registration, different setup
----

This led to:

* Maintenance burden - changes needed in two places
* Configuration drift - tests and production diverge
* False confidence - tests pass but production breaks

**Limited integration testing:**

Axon 4 fixtures focused on unit testing individual aggregates or sagas.
Integration testing required custom setup.

**Inconsistent APIs:**

Different fixtures had different APIs and behaviors.
Learning multiple testing approaches.

=== Benefits of Axon 5 approach

**Single source of truth:**

Configure once, use everywhere:

[source,java]
----
// Configuration (Axon 5)
public class AxonConfig {
    public static EventSourcingConfigurer configurer() {
        return EventSourcingConfigurer.create()
            .registerEntity(EventSourcedEntityModule.autodetected(String.class, Account.class))
            .registerCommandHandler(AccountCommandHandler.class);
    }
}

// Production
var config = AxonConfig.configurer().build();
config.start();

// Tests
var fixture = AxonTestFixture.with(AxonConfig.configurer());
----

**True integration testing:**

Test with real event stores, processors, and infrastructure.
Verify complete message flows.

**Consistent API:**

Same testing approach for entities, command handlers, event handlers, and queries.
One API to learn.

=== When to upgrade

**Upgrade if:**

* You're starting a new project with Axon 5
* You're already migrating from Axon 4 to Axon 5
* You want better integration testing capabilities
* You're tired of maintaining duplicate configuration

**Stay on Axon 4 if:**

* Your project uses Axon 4 and works well
* You're not planning to upgrade to Axon 5
* Migration cost outweighs benefits for your project

== Key differences

=== Single fixture vs multiple fixtures

**Axon 4:**

Different fixtures for different scenarios:

[source,java]
----
// Aggregate testing
var aggregateFixture = new AggregateTestFixture<>(Account.class);

// Saga testing
var sagaFixture = new SagaTestFixture<>(OrderSaga.class);

// Different APIs, different configuration
----

**Axon 5:**

Single fixture for everything:

[source,java]
----
// One fixture for all scenarios
var configurer = EventSourcingConfigurer.create()
    .registerEntity(EventSourcedEntityModule.autodetected(String.class, Account.class));

var fixture = AxonTestFixture.with(configurer);
----

=== Configuration approach

**Axon 4:**

Fixture-specific registration methods:

[source,java]
----
var fixture = new AggregateTestFixture<>(Account.class);
fixture.registerAnnotatedCommandHandler(new MyCommandHandler());
fixture.registerInjectableResource(myService);
----

**Axon 5:**

Use standard configurer API:

[source,java]
----
var configurer = EventSourcingConfigurer.create()
    .registerEntity(EventSourcedEntityModule.autodetected(String.class, Account.class))
    .registerCommandHandler(new MyCommandHandler())
    .registerComponent(MyService.class, config -> myService);

var fixture = AxonTestFixture.with(configurer);
----

=== Test method names

**Axon 4:**

Methods named `given...`, `when...`, `expect...`:

[source,java]
----
fixture.givenNoPriorActivity()
       .when(new CreateAccountCommand("account-1"))
       .expectEvents(new AccountCreatedEvent("account-1"));
----

**Axon 5:**

Explicit phase transitions with `.given()`, `.when()`, `.then()`:

[source,java]
----
fixture.given()
       .noPriorActivity()
       .when()
       .command(new CreateAccountCommand("account-1"))
       .then()
       .events(new AccountCreatedEvent("account-1"));
----

=== Return value changes

**Axon 4:**

Creational command handlers automatically returned `@AggregateIdentifier` value:

[source,java]
----
@CommandHandler
public Account(CreateAccountCommand cmd) {
    apply(new AccountCreatedEvent(cmd.getAccountId()));
}

// Test automatically got accountId as result
----

**Axon 5:**

Handlers return exactly what the method returns:

[source,java]
----
@CommandHandler
public static String handle(CreateAccountCommand cmd, EventAppender eventAppender) {
    eventAppender.append(new AccountCreatedEvent(cmd.getAccountId()));
    return cmd.getAccountId();  // Explicit return
}

// Test verifies actual return value
.then()
.resultMessagePayload("account-1")
----

== Migration examples

=== Migrating aggregate tests

**Axon 4:**

[source,java]
----
class AccountTest {

    private AggregateTestFixture<Account> fixture;

    @BeforeEach
    void setUp() {
        fixture = new AggregateTestFixture<>(Account.class);
    }

    @Test
    void testCreateAccount() {
        fixture.givenNoPriorActivity()
               .when(new CreateAccountCommand("account-1", 500.00))
               .expectEvents(new AccountCreatedEvent("account-1", 500.00));
    }

    @Test
    void testWithdrawMoney() {
        fixture.given(new AccountCreatedEvent("account-1", 500.00))
               .when(new WithdrawMoneyCommand("account-1", 100.00))
               .expectEvents(new MoneyWithdrawnEvent("account-1", 100.00));
    }
}
----

**Axon 5:**

[source,java]
----
class AccountTest {

    private AxonTestFixture fixture;

    @BeforeEach
    void setUp() {
        var configurer = EventSourcingConfigurer.create()
            .registerEntity(EventSourcedEntityModule.autodetected(String.class, Account.class));

        fixture = AxonTestFixture.with(configurer);
    }

    @Test
    void testCreateAccount() {
        fixture.given()
               .noPriorActivity()
               .when()
               .command(new CreateAccountCommand("account-1", 500.00))
               .then()
               .events(new AccountCreatedEvent("account-1", 500.00));
    }

    @Test
    void testWithdrawMoney() {
        fixture.given()
               .event(new AccountCreatedEvent("account-1", 500.00))
               .when()
               .command(new WithdrawMoneyCommand("account-1", 100.00))
               .then()
               .events(new MoneyWithdrawnEvent("account-1", 100.00));
    }

    @AfterEach
    void tearDown() {
        fixture.stop();
    }
}
----

**Key changes:**

* `givenNoPriorActivity()` → `.given().noPriorActivity()`
* `when(command)` → `.when().command(command)`
* `expectEvents(...)` → `.then().events(...)`
* Added `fixture.stop()` in `@AfterEach`

=== Migrating Saga tests

**Axon 4:**

[source,java]
----
class OrderSagaTest {

    private SagaTestFixture<OrderSaga> fixture;

    @BeforeEach
    void setUp() {
        fixture = new SagaTestFixture<>(OrderSaga.class);
    }

    @Test
    void testOrderProcess() {
        fixture.givenAggregate("order-1")
               .published(new OrderPlacedEvent("order-1"))
               .whenPublishingA(new PaymentReceivedEvent("order-1"))
               .expectDispatchedCommands(new ShipOrderCommand("order-1"));
    }
}
----

**Axon 5:**

Sagas are not available in Axon 5.0.
Use stateful event handlers or event handlers with custom state storage:

[source,java]
----
class OrderEventHandlerTest {

    private AxonTestFixture fixture;

    @BeforeEach
    void setUp() {
        var configurer = MessagingConfigurer.create()
            .registerEventHandler(new OrderEventHandler());

        fixture = AxonTestFixture.with(configurer);
    }

    @Test
    void testOrderProcess() {
        fixture.given()
               .event(new OrderPlacedEvent("order-1"))
               .when()
               .event(new PaymentReceivedEvent("order-1"))
               .then()
               .commands(new ShipOrderCommand("order-1"));
    }

    @AfterEach
    void tearDown() {
        fixture.stop();
    }
}
----

**Key changes:**

* Replace saga with stateful event handler
* Use `.event()` instead of `.published()` and `.whenPublishingA()`
* Use `.commands()` instead of `.expectDispatchedCommands()`

== Method name mapping

Complete mapping of Axon 4 methods to Axon 5:

[cols="1,1"]
|===
|Axon 4 |Axon 5

|`givenNoPriorActivity()`
|`.given().noPriorActivity()`

|`given(events...)`
|`.given().events(events...)`

|`givenCommands(commands...)`
|`.given().commands(commands...)`

|`when(command)`
|`.when().command(command)`

|`whenPublishingA(event)`
|`.when().event(event)`

|`expectEvents(events...)`
|`.then().events(events...)`

|`expectNoEvents()`
|`.then().noEvents()`

|`expectException(type)`
|`.then().exception(type)`

|`expectSuccessfulHandlerExecution()`
|`.then().success()`

|`expectDispatchedCommands(commands...)`
|`.then().commands(commands...)`

|`expectNoDispatchedCommands()`
|`.then().noCommands()`

|`expectResultMessage(payload)`
|`.then().resultMessagePayload(payload)`

|`expectResultMessagePayload()`
|`.then().resultMessagePayload()`

|`expectResultMessagePayloadMatching(matcher)`
|`.then().resultMessagePayloadSatisfies(consumer)`
|===

== Common migration pitfalls

=== Forgetting phase transitions

**Problem:**

Axon 4 used method chaining directly:

[source,java]
----
fixture.when(command).expectEvents(...)
----

Axon 5 requires explicit phase transitions:

[source,java]
----
fixture.when().command(command).then().events(...)
----

**Solution:**

Remember the three phases: `.given()`, `.when()`, `.then()`

=== Constructor-based command handlers

**Problem:**

Axon 4 allowed `@CommandHandler` on constructors:

[source,java]
----
@CommandHandler
public Account(CreateAccountCommand cmd) {
    apply(new AccountCreatedEvent(cmd.getAccountId()));
}
----

Axon 5 requires static factory methods for creational handlers:

[source,java]
----
@CommandHandler
public static String handle(CreateAccountCommand cmd, EventAppender eventAppender) {
    eventAppender.append(new AccountCreatedEvent(cmd.getAccountId()));
    return cmd.getAccountId();
}
----

**Solution:**

Convert constructor handlers to static factory methods.
See xref:axon-framework-commands:command-handlers.adoc[] for details.

=== `AggregateLifecycle.apply()`

**Problem:**

Axon 4 used static `AggregateLifecycle.apply()`:

[source,java]
----
AggregateLifecycle.apply(new MoneyWithdrawnEvent(accountId, amount));
----

Axon 5 requires injecting `EventAppender`:

[source,java]
----
@CommandHandler
public void handle(WithdrawMoneyCommand cmd, EventAppender eventAppender) {
    eventAppender.append(new MoneyWithdrawnEvent(accountId, cmd.getAmount()));
}
----

**Solution:**

Inject `EventAppender` as a parameter and use it to append events.
See xref:axon-framework-commands:command-handlers.adoc[] for details.

=== @TargetAggregateIdentifier

**Problem:**

Axon 4 used `@TargetAggregateIdentifier` on command fields:

[source,java]
----
public class WithdrawMoneyCommand {
    @TargetAggregateIdentifier
    private final String accountId;
}
----

Axon 5 uses `@Command` annotation with `routingKey` attribute:

[source,java]
----
@Command(routingKey = "accountId")
public class WithdrawMoneyCommand {
    private final String accountId;
}
----

**Solution:**

Replace `@TargetAggregateIdentifier` with `@Command(routingKey = "fieldName")`.
See xref:axon-framework-commands:command-dispatchers.adoc[] for details.

=== Forgetting to stop fixture

**Problem:**

Axon 4 fixtures didn't require explicit cleanup.

Axon 5 requires calling `fixture.stop()`:

[source,java]
----
@AfterEach
void tearDown() {
    fixture.stop();
}
----

**Solution:**

Always add `@AfterEach` method that calls `fixture.stop()`.

== Benefits of migration

**No duplicate configuration**::
Use production configuration in tests.
Changes in one place.

**Better integration testing**::
Test with real infrastructure.
Verify complete message flows.

**Consistent API**::
Same testing approach for all scenarios.
One API to learn and maintain.

**Type-safe phases**::
Compile-time safety for test structure.
Catch errors early.

**Better extensibility**::
Easy to add custom validation.
Rich matcher support.

**Clearer test structure**::
Explicit Given-When-Then phases.
More readable tests.

== Step-by-step migration guide

Follow these steps to migrate your tests from Axon 4 to Axon 5:

**1. Update dependencies**

Upgrade to Axon Framework 5 in your `pom.xml` or `build.gradle`:

[source,xml]
----
<dependency>
    <groupId>org.axonframework</groupId>
    <artifactId>axon-test</artifactId>
    <version>5.0.0</version>
    <scope>test</scope>
</dependency>
----

**2. Replace fixture creation**

Replace `AggregateTestFixture` with `AxonTestFixture`:

[source,java]
----
// Before
var fixture = new AggregateTestFixture<>(Account.class);

// After
var configurer = EventSourcingConfigurer.create()
    .registerEntity(EventSourcedEntityModule.autodetected(String.class, Account.class));
var fixture = AxonTestFixture.with(configurer);
----

**3. Update phase transitions**

Add explicit `.given()`, `.when()`, `.then()` transitions:

[source,java]
----
// Before
fixture.givenNoPriorActivity()
       .when(command)
       .expectEvents(event);

// After
fixture.given()
       .noPriorActivity()
       .when()
       .command(command)
       .then()
       .events(event);
----

**4. Rename assertion methods**

Update method names according to the mapping table:

[source,java]
----
// Before: expectEvents()
// After: .then().events()

// Before: expectException()
// After: .then().exception()
----

**5. Update command handlers**

Remove `@CommandHandler` from constructors, use static methods:

[source,java]
----
// Before
@CommandHandler
public Account(CreateAccountCommand cmd) {
    apply(new AccountCreatedEvent(cmd.getAccountId()));
}

// After
@CommandHandler
public static String handle(CreateAccountCommand cmd, EventAppender eventAppender) {
    eventAppender.append(new AccountCreatedEvent(cmd.getAccountId()));
    return cmd.getAccountId();
}
----

**6. Replace AggregateLifecycle**

Inject `EventAppender` parameter:

[source,java]
----
// Before
AggregateLifecycle.apply(event);

// After
@CommandHandler
public void handle(MyCommand cmd, EventAppender eventAppender) {
    eventAppender.append(event);
}
----

**7. Update routing**

Replace `@TargetAggregateIdentifier` with `@Command(routingKey)`:

[source,java]
----
// Before
@TargetAggregateIdentifier
private final String accountId;

// After
@Command(routingKey = "accountId")
public class MyCommand {
    private final String accountId;
}
----

**8. Migrate Saga tests**

Convert saga tests to stateful event handler tests.
See the saga migration example above.

**9. Add fixture cleanup**

Add `@AfterEach` method:

[source,java]
----
@AfterEach
void tearDown() {
    fixture.stop();
}
----

**10. Run tests**

Run your tests and fix any compilation errors.
Update any remaining API usage based on compiler errors.

== Summary

Upgrading to Axon 5 testing provides significant benefits:

* **Unified API** - One fixture for all scenarios
* **Configurer-based** - Reuse production configuration
* **Type-safe** - Compile-time safety for test structure
* **Integration testing** - Test with real infrastructure
* **Better maintainability** - Single source of truth

The migration involves:

* Replacing fixture creation with `AxonTestFixture.with(configurer)`
* Adding explicit phase transitions (`.given()`, `.when()`, `.then()`)
* Updating method names (see mapping table)
* Updating command handlers (static methods, EventAppender)
* Converting saga tests to event handler tests

For detailed testing guidance, see:

* xref:testing-with-axon-test-fixture.adoc[] - Main testing guide
* xref:field-filters.adoc[] - Field filtering and equality comparison
* xref:advanced-testing.adoc[] - Advanced testing techniques
