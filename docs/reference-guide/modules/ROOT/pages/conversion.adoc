= Conversion
:page-aliases: serialization.adoc

Axon Framework requires conversion of messages when storing events, sending commands and queries over the network, or passing messages between different parts of your application.
This is handled through the `Converter` API, which provides a flexible and powerful way to transform message payloads between different formats and types.

== Understanding message types and conversion

Axon Framework uses a flexible approach to message identification and conversion that decouples message identity from Java class representation.

=== Message type vs Java class

Messages in Axon Framework are identified by their `MessageType`, which consists of:

* A `QualifiedName` - The fully qualified business name of the message, consisting of:
  ** A `namespace` (defaults to the package name of the message class)
  ** A `name` (the local name, defaults to the simple class name)
* A `version` - The version of the message structure (specified through annotations)

This approach means that:

* The same message can be represented by different Java classes in different applications
* Different handlers can receive the same message in different Java types
* The Java class is one possible representation of a message, not its sole identifier

For example, a message with qualified name `com.example.events.UserRegistered` and version "1.0" is the same message regardless of whether it's represented as a `UserRegisteredEvent` class in one service or a `UserCreatedEvent` class in another, as long as both specify the same `MessageType`.

=== Payload conversion at handling time

When Axon Framework processes messages, it converts payloads to the type expected by each handler at the moment the handler needs to process the message.

Messages retain their serialized form (such as JSON or Avro binary) along with metadata about their `MessageType`.
When a handler is ready to process a message, the framework converts the payload to the handler's expected type.
This happens independently for each handler, meaning different handlers can receive the same message in different representations.

____
**Migrating from Axon 4**

If you're coming from Axon 4, this represents a shift from the previous approach where:

* Messages were deserialized to their original Java class when loaded from storage
* All handlers had to work with the exact same Java type
* Upcasters were the primary tool for handling message evolution

The new approach reduces the need for upcasters in many scenarios and provides more flexibility in how different services represent the same business concepts.
____

For example, consider an event stored as JSON:

[source,java]
----
package com.example.events;

@Event(name = "UserRegistered", version = "1")
// Namespace defaults to "com.example.events" (the package name)
// Full qualified name is "com.example.events.UserRegistered"
public class UserRegisteredEvent {
    private String userId;
    private String email;
    // constructors, getters...
}
----

One event handler might process this as the full `UserRegisteredEvent` object:

[source,java]
----
@EventHandler //<1>
public void on(UserRegisteredEvent event) {
    // Receives the full object
    userRepository.save(new User(event.getUserId(), event.getEmail()));
}
----

<1> The `@EventHandler` annotation doesn't need to specify the event name, since the `UserRegisteredEvent` is annotated with `@Event` and contains the message type information.

While another handler might only need it as JSON:

[source,java]
----
@EventHandler(eventName = "com.example.events.UserRegistered") //<1>
public void on(JsonNode event) {
    // Receives the same event as a JsonNode
    // Must use the fully qualified name (namespace + name)
    String userId = event.get("userId").asText();
    // Process using JSON directly
}
----

Both handlers process the same event, but each receives it in the format most convenient for their needs.
The conversion happens automatically based on the handler's parameter type.

<1> when using a generic type like `JsonNode`, you must specify the `eventName` attribute with the fully qualified name (namespace and local name) to indicate which event the handler processes.

This approach:

* Reduces the need for upcasters in many scenarios
* Allows gradual migration when message structures change
* Enables different services to use different Java representations
* Simplifies integration with external systems that may expect different formats

== Converter types

Axon Framework 5 uses a hierarchy of converters to handle different conversion needs.

=== Base converter

The `Converter` interface is the foundation for all conversion in Axon Framework.
It provides methods to:

* Check if conversion between two types is possible (`canConvert`)
* Convert an object from one type to another (`convert`)

Implementations like `JacksonConverter` and `AvroConverter` handle the actual conversion logic.

=== Message converter

The `MessageConverter` is a specialized converter for converting message payloads.
It operates on `Message` objects and provides methods to:

* Convert a message's payload to a different type (`convertPayload`)
* Create a new message with a converted payload (`convertMessage`)

This converter is used for all command and query messages.

=== Event converter

The `EventConverter` is specifically designed for event messages.
It extends the conversion concept to work with `EventMessage` objects and provides methods to:

* Convert an event's payload to a different type (`convertPayload`)
* Create a new event message with a converted payload (`convertEvent`)

This converter is used by the event store and event processors.

=== Converter configuration levels

Axon Framework allows you to configure converters at three levels:

1. **general** - Used for everything that needs to be converted, unless specified by other levels
2. **messages** - Used to convert all command and query messages (uses `MessageConverter`)
3. **events** - Used to convert all event messages (uses `EventConverter`)

There is an implicit ordering: if no event converter is configured, the message converter is used.
If no message converter is configured, the general converter is used.

== Converter implementations

Axon Framework provides several converter implementations.

=== JacksonConverter (default)

The `JacksonConverter` is the default converter in Axon Framework.
It uses https://github.com/FasterXML/jackson[Jackson] to convert objects to and from JSON format.

Jackson produces a compact serialized form and is widely supported across different platforms and languages.
This makes it ideal for:

* Storing events in an event store
* Sending commands and queries over the network
* Integration with external systems
* Long-term storage of events

The `JacksonConverter` uses a default `ObjectMapper` configuration but can be customized:

[source,java]
----
ObjectMapper customMapper = new ObjectMapper()
    .findAndRegisterModules()
    .configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);

JacksonConverter converter = new JacksonConverter(customMapper);
----

==== XML support

If you need to serialize to XML format instead of JSON, you can configure the `JacksonConverter` with an `XmlMapper`:

[source,java]
----
XmlMapper xmlMapper = new XmlMapper();
xmlMapper.findAndRegisterModules();

JacksonConverter xmlConverter = new JacksonConverter(xmlMapper);
----

You'll need to add the `jackson-dataformat-xml` dependency to your project:

[source,xml]
----
<dependency>
    <groupId>com.fasterxml.jackson.dataformat</groupId>
    <artifactId>jackson-dataformat-xml</artifactId>
</dependency>
----

=== AvroConverter

The `AvroConverter` uses https://avro.apache.org/[Apache Avro] to serialize objects to and from https://avro.apache.org/docs/1.12.0/specification/#binary-encoding[binary single-object-encoded format].

Avro provides:

* Compact binary format
* Schema-based serialization with strong type safety
* Schema evolution support
* Excellent performance

The `AvroConverter` is designed to serve as a message and event converter.

To use Avro, you need to configure a `SchemaStore`:

[source,java]
----
SchemaStore schemaStore = // ... configure schema store

AvroConverter avroConverter = new AvroConverter(
    schemaStore,
    config -> config  // Customize configuration here
);
----

The Avro converter requires a `SchemaStore` to resolve schemas for all messages being processed.
In Spring Boot applications, the auto-configuration can create a schema store that scans the classpath for schemas using the `@AvroSchemaScan` annotation.

For production use with multiple services, consider implementing a custom `SchemaStore` that connects to a central schema registry.
Be sure to implement caching to maintain performance.

=== Custom converters

You can implement your own converter by implementing the `Converter` interface:

[source,java]
----
public class MyCustomConverter implements Converter {

    @Override
    public boolean canConvert(Type sourceType, Type targetType) {
        // Determine if conversion is possible
        return /* ... */;
    }

    @Override
    public <T> T convert(Object input, Type targetType) {
        // Perform the conversion
        return /* ... */;
    }

    @Override
    public void describeTo(@Nonnull ComponentDescriptor descriptor) {
        descriptor.describeProperty("someCustomProperty", "SomeValue");
    }
}
----

== Configuring converters

=== Plain Java configuration

To configure converters, use the `MessagingConfigurer` and register components through the component registry:

[source,java]
----
import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.conversion.Converter;
import org.axonframework.conversion.json.JacksonConverter;
import org.axonframework.messaging.core.conversion.MessageConverter;
import org.axonframework.messaging.core.conversion.DelegatingMessageConverter;
import org.axonframework.messaging.eventhandling.conversion.EventConverter;
import org.axonframework.messaging.eventhandling.conversion.DelegatingEventConverter;

public class Application {

    public static void main(String[] args) {
        MessagingConfigurer.create()
            // Register the base converter
            .componentRegistry(cr -> cr.registerComponent(
                Converter.class,
                config -> new JacksonConverter()
            ))
            // Register the message converter (wraps the base converter)
            .componentRegistry(cr -> cr.registerComponent(
                MessageConverter.class,
                config -> new DelegatingMessageConverter(config.getComponent(Converter.class))
            ))
            // Register the event converter (wraps the message converter)
            .componentRegistry(cr -> cr.registerComponent(
                EventConverter.class,
                config -> new DelegatingEventConverter(config.getComponent(MessageConverter.class))
            ))
            .build()
            .start();
    }
}
----

**Note:** If you don't explicitly configure converters, Axon Framework automatically registers:
* A `JacksonConverter` as the default `Converter`
* A `DelegatingMessageConverter` wrapping the `Converter`
* A `DelegatingEventConverter` wrapping the `MessageConverter`

=== Using Avro for events

To use Avro for events while keeping Jackson for other messages:

[source,java]
----
import org.axonframework.conversion.avro.AvroConverter;

public class Application {

    public static void main(String[] args) {
        SchemaStore schemaStore = // ... configure your schema store

        MessagingConfigurer.create()
            // Use Jackson as the default converter
            .componentRegistry(cr -> cr.registerComponent(
                Converter.class,
                config -> new JacksonConverter()
            ))
            // Use Jackson for message conversion
            .componentRegistry(cr -> cr.registerComponent(
                MessageConverter.class,
                config -> new DelegatingMessageConverter(config.getComponent(Converter.class))
            ))
            // Use Avro for event conversion
            .componentRegistry(cr -> cr.registerComponent(
                EventConverter.class,
                config -> {
                    AvroConverter avroConverter = new AvroConverter(
                        schemaStore,
                        cfg -> cfg  // Customize configuration
                    );
                    return new DelegatingEventConverter(avroConverter);
                }
            ))
            .build()
            .start();
    }
}
----

=== Spring Boot configuration

==== Using Java configuration

[source,java]
----
@Configuration
public class ConverterConfiguration {

   @Bean
   public Converter converter() {
      return new JacksonConverter();
   }

   @Bean
   public MessageConverter messageConverter(Converter converter) {
      return new DelegatingMessageConverter(converter);
   }

   @Bean
   public EventConverter eventConverter(MessageConverter messageConverter) {
      return new DelegatingEventConverter(messageConverter);
   }
}
----

==== Using application properties

[source,properties]
----
# Possible values: 'default', 'java', 'jackson'
# 'avro' can be used for 'events' and 'messages' only
axon.converter.general=jackson
axon.converter.messages=jackson
axon.converter.events=jackson
----

==== Using YAML configuration

[source,yaml]
----
# Possible values: 'default', 'java', 'jackson'
# 'avro' can be used for 'events' and 'messages' only
axon:
  serializer:
    general: jackson
    events: jackson
    messages: jackson
----

== Message type resolution

The `MessageTypeResolver` determines the `MessageType` for each message class in your application.
By default, it uses the annotations and class information to derive the qualified name and version.

=== Specifying message types

Use the message-specific annotations to define the name, namespace, and version of your messages.

**For events:**

[source,java]
----
package com.example.events;

// Namespace defaults to the package name: "com.example.events"
// Full qualified name will be: "com.example.events.UserRegistered"
@Event(name = "UserRegistered", version = "1.0")
public class UserRegisteredEvent {
    // fields, constructors, etc.
}

// Explicitly specify a different namespace
// Full qualified name will be: "com.mycompany.user.UserRegistered"
@Event(namespace = "com.mycompany.user", name = "UserRegistered", version = "1.0")
public class UserRegisteredEvent {
    // fields, constructors, etc.
}
----

**For commands:**

[source,java]
----
package com.example.commands;

@Command(name = "RegisterUser", version = "1.0")
public class RegisterUserCommand {
    // fields, constructors, etc.
}
----

**For queries:**

[source,java]
----
package com.example.queries;

@Query(name = "FindUserById", version = "1.0")
public class FindUserByIdQuery {
    // fields, constructors, etc.
}
----

**Default values:**

* If you don't specify a `namespace`, Axon uses the package name of the class
* If you don't specify a `name`, Axon uses the simple class name
* If you don't specify a `version`, Axon uses `0.0.1` as the version
* The fully qualified name is always: `namespace + "." + name`

____
**Migrating from Axon 4**

The `MessageTypeResolver` replaces the `RevisionResolver` from Axon 4.
The `@Revision` annotation has been replaced by the message-specific annotations (`@Command`, `@Event`, `@Query`) with their `version` field.
____

=== Custom message type resolution

If you need custom logic to determine message types, you can implement the `MessageTypeResolver` interface:

[source,java]
----
import org.axonframework.messaging.core.MessageTypeResolver;
import org.axonframework.messaging.core.MessageType;

public class CustomMessageTypeResolver implements MessageTypeResolver {

    @Override
    public Optional<MessageType> resolve(@Nonnull Class<?> payloadType); {
        // Custom logic to determine the MessageType
        return /* ... */;
    }
}
----

Then register it with your configuration:

[source,java]
----
ApplicationConfigurer applicationConfigurer = /* The configurer that contains this Application's configuration */
MessagingConfigurer.enhance(applicationConfigurer)
    .registerMessageTypeResolver(config -> new CustomMessageTypeResolver());
----

== Converter tuning

Several considerations can help optimize the conversion process.

=== Lenient deserialization

Lenient deserialization allows converters to ignore unknown properties when converting from a serialized format.
This is helpful when:

* Event structures have evolved and older events contain fields that no longer exist
* Different versions of an application are running concurrently
* Using rolling deployments where old and new message formats coexist temporarily

Both `JacksonConverter` and `AvroConverter` support lenient deserialization.

==== JacksonConverter

[source,java]
----
public class ConverterConfiguration {

    public Converter buildConverter() {
        return new JacksonConverter(new ObjectMapper()
            .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
            .findAndRegisterModules());
    }
}
----

==== AvroConverter

Apache Avro addresses compatibility between schema versions through its built-in schema resolution.
By design, Avro is highly permissive to schema additions, so no additional configuration is needed for lenient deserialization.
Just ensure your schema changes follow Avro's compatibility rules.

=== Generic types

When serializing objects that contain lists or collections, you may encounter issues with generic type information.

Jackson requires type information to correctly deserialize generic collections.
The recommended approach is to use the `@JsonTypeInfo` annotation:

[source,java]
----
public class MyEvent {
    @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)
    private List<Item> items;
    // constructors, getters, setters...
}
----

Alternatively, you can configure the `ObjectMapper` to enable default typing:

[source,java]
----
ObjectMapper mapper = new ObjectMapper()
    .activateDefaultTyping(
        BasicPolymorphicTypeValidator.builder()
            .allowIfBaseType(Object.class)
            .build(),
        ObjectMapper.DefaultTyping.NON_FINAL,
        JsonTypeInfo.As.PROPERTY
    );

JacksonConverter converter = new JacksonConverter(mapper);
----

**Note:** Be aware of the security implications of enabling default typing, as described in Jackson's https://github.com/FasterXML/jackson-docs/wiki/JacksonPolymorphicDeserialization[Polymorphic Deserialization] documentation.

=== Content type converters

A Converter supports certain content types to start conversion to its target type.
To provide flexibility converters, Axon will automatically convert between content types by using a `ContentTypeConverter`.

The framework searches for the shortest conversion path from type X to type Y, performs the conversion, and passes the converted value to the requesting converter.

The available `ContentTypeConverter` instances depend on the converter you're using:

* **JacksonConverter** supports conversion to and from `JsonNode` and `ObjectNode`
* **AvroConverter** supports conversion to and from `GenericRecord`
* All converters support generic conversions like `String` to `byte[]` and `byte[]` to `InputStream`

==== Custom content type converters

If Axon doesn't provide the content type conversion you need, implement the `ContentTypeConverter` interface:

[source,java]
----
public class MyContentTypeConverter implements ContentTypeConverter<MySourceType, MyTargetType> {

    @Override
    public Class<MySourceType> expectedSourceType() {
        return MySourceType.class;
    }

    @Override
    public Class<MyTargetType> targetType() {
        return MyTargetType.class;
    }

    @Override
    public MyTargetType convert(MySourceType original) {
        // Perform conversion
        return /* ... */;
    }
}
----

Register your custom content type converter with your main converter:

[source,java]
----
ChainingContentTypeConverter contentTypeConverter = new ChainingContentTypeConverter();
contentTypeConverter.registerConverter(new MyContentTypeConverter());

JacksonConverter converter = new JacksonConverter(new ObjectMapper(), contentTypeConverter);
----

== Choosing the right converter

When deciding which converter to use for your application, consider:

**Use JacksonConverter when:**

* You need human-readable serialized formats for debugging
* Interoperability with non-JVM systems is important
* You want a widely supported, standard JSON format
* You need flexibility in schema evolution

**Use AvroConverter when:**

* Storage space is a critical concern
* You want schema enforcement and strong type safety
* Your organization uses a schema registry
* You need the best performance for high-throughput scenarios

**Use JacksonConverter with XmlMapper when:**

* You must maintain XML format for legacy reasons
* External systems require XML
* You're migrating from XStream and need XML compatibility

**For most new applications, the default JacksonConverter with JSON format is the recommended choice.**
It provides the best balance of features, performance, and maintainability.
