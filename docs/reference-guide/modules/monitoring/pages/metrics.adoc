= Metrics
:navtitle: Metrics

Interesting metrics in a message centric system come in several forms and flavors, like count, capacity, and latency for example.
Axon Framework allows you to retrieve such measurements through the use of the extension modules `axon-metrics-dropwizard` and `axon-metrics-micrometer`.

With these modules you can register a number of `MessageMonitor` implementations to your messaging components, like the xref:commands:command-dispatchers.adoc#command-bus[`CommandBus`], xref:events:infrastructure.adoc#event_bus[`EventBus`], xref:queries:query-dispatchers.adoc#query-bus-and-gateway[`QueryBus`] and xref:events:event-processors/index.adoc[`EventProcessors`].

[[axon-metrics-dropwizard]]
As the name suggests, the `axon-metrics-dropwizard` module uses link:https://metrics.dropwizard.io/[Dropwizard Metrics] for registering the measurements of your infrastructure components.
Hence, the `MessageMonitors` provided by this module are registered against the Dropwizard `MetricRegistry`.

[[axon-metrics-micrometer]]
Furthermore, the `axon-metrics-micrometer` module uses link:https://micrometer.io/[Micrometer] for measurements.
This is a dimensional-first metrics collection facade, whose aim is to allow you to time, count, and gauge your code with a vendor neutral API.
Furthermore, the `MessageMonitors` provided by this module are registered against the Micrometer `MeterRegistry`.

The following monitor implementations are available through **both** modules:

. `CapacityMonitor` - Measures message capacity by keeping track of the total time spent on message handling compared to total time it is active.
This returns a number between 0 and n, n being the number of threads.
Thus, if there are 4 threads working, the maximum capacity is 4 if every thread is active 100% of the time.
. `EventProcessorLatencyMonitor` - Measures the difference between an event's timestamp and the current time, showing how far behind an xref:events:event-processors/index.adoc[event processor] is.
Note that xref:events:event-processors/streaming.adoc#replaying-events[triggering a reset] will impact this metric!
. `MessageCountingMonitor` - Counts the number of ingested, successful, failed, ignored and processed messages.
. `MessageTimerMonitor` - Keeps a timer for all successful, failed and ignored messages, as well as an overall timer for all three combined.

The `axon-metrics-dropwizard` module has one unique `MessageMonitor`, called the `PayloadTypeMessageMonitorWrapper`.
This is a `MessageMonitor` implementation that allows setting a monitor per message type instead of per message publishing/handling component.
This monitor is not mandatory for `axon-metrics-micrometer` due to Micrometer's dimensional-first support.
As a result, any measurement can be tagged with the payload type automatically.

You are free to configure any combination of `MessageMonitors` through constructors on your messaging components, simply by using the Configuration API.
The `MetricsConfigurationEnhancer` contained in both the `axon-metrics-dropwizard` and `axon-metrics-micrometer` modules provides a set of sensible defaults per type of messaging component.

[[monitor-defaults]]
The following table shows the default `MessageMonitor` implementations registered for each component type, including the registered metric's name:

[cols="1,2,2",options="header"]
|===
| Component Type | Default Message Monitors | Metric Name Pattern

| `CommandBus`
| `MessageCountingMonitor`, `MessageTimerMonitor`, `CapacityMonitor`
| `\{name}.messageCounter`, `\{name}.messageTimer`, `\{name}.capacity`

| `EventSink`
| `MessageCountingMonitor`, `MessageTimerMonitor`
| `\{name}.messageCounter`, `\{name}.messageTimer`

| `EventProcessor`
| `MessageCountingMonitor`, `MessageTimerMonitor`, `CapacityMonitor`, `EventProcessorLatencyMonitor`
| `\{name}.messageCounter`, `\{name}.messageTimer`, `\{name}.capacity`, `\{name}.latency`

| `QueryBus`
| `MessageCountingMonitor`, `MessageTimerMonitor`, `CapacityMonitor`
| `\{name}.messageCounter`, `\{name}.messageTimer`, `\{name}.capacity`

| `QueryBus` (Subscription Query Updates)
| `MessageCountingMonitor`, `MessageTimerMonitor`, `CapacityMonitor`
| `\{name}-emitter.messageCounter`, `\{name}-emitter.messageTimer`, `\{name}-emitter.capacity`
|===

The `\{name}` placeholder is either the configured component name or the simple class name of the component type (e.g., `CommandBus`, `QueryBus`) if the infrastructure component was registered without a name.

The following example shows you how to configure default metrics for your message handling components:

== Configuring message monitors

For configuring `MessageMonitors` in your application, please read the section for <<dropwizard,Dropwizard>> or <<micrometer,Micrometer>>.

[TIP]
.Spring Boot Property-based disabling
====
When using Spring Boot, you can disable metrics entirely by setting the following property:

[source,text]
----
axon.metrics.enabled=false
----

This property will influence both <<dropwizard,Dropwizard>> and <<micrometer,Micrometer>> metrics.
====

[#dropwizard]
=== Dropwizard

You need to include a dependency to `axon-metrics-dropwizard` to enable Dropwizard metrics:

[tabs]
====
Maven::
+
--
[source,xml]
----
<dependency>
    <groupId>org.axonframework.extensions.metrics</groupId>
    <artifactId>axon-metrics-dropwizard</artifactId>
    <version>${axon.version}</version>
</dependency>
----
--

Gradle::
+
--
[source,groovy]
----
implementation 'org.axonframework.extensions.metrics:axon-metrics-dropwizard:${axonVersion}'
----
--
====

With the dependency in place the <<monitor-defaults,default>> `MessageMonitors` will be set for all `CommandBus`, `EventSink`, `EventProcessor`, and `QueryBus` implementations present in the application.
If you need to specify the `MetricRegistry` used, please check the following examples:

[tabs]
====
Configuration API::
+
--
[source,java]
----
import com.codahale.metrics.MetricRegistry;
import org.axonframework.extension.metrics.dropwizard.MetricsConfigurationEnhancer;
import org.axonframework.messaging.core.configuration.MessagingConfigurer;

class MetricsConfiguration {

    public void configureDefaultMetrics(MessagingConfigurer configurer,
                                        MetricRegistry metricRegistry) {
        configurer.componentRegistry(componentRegistry -> componentRegistry.registerEnhancer(
                new MetricsConfigurationEnhancer(metricRegistry)
        ));
    }
}
----
--

Spring Boot::
+
--
[source,java]
----
import com.codahale.metrics.MetricRegistry;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
class MetricsConfiguration {

    @Bean
    public MetricRegistry metricRegistry() {
        return new MetricRegistry();
    }
}
----
--
====

[#micrometer]
=== Micrometer

You need to include a dependency to `axon-metrics-micrometer` to enable Micrometer metrics:

[tabs]
====
Maven::
+
--
[source,xml]
----
<dependency>
    <groupId>org.axonframework.extensions.metrics</groupId>
    <artifactId>axon-metrics-micrometer</artifactId>
    <version>${axon.version}</version>
</dependency>
----
--

Gradle::
+
--
[source,groovy]
----
implementation 'org.axonframework.extensions.metrics:axon-metrics-micrometer:${axonVersion}'
----
--
====

With the dependency in place the <<monitor-defaults,default>> `MessageMonitors` will be set for all `CommandBus`, `EventSink`, `EventProcessor`, and `QueryBus` implementations present in the application.
If you are using an automated configuration flow, as with Spring, be sure to set the following properties:

[source,properties]
----
# Spring Boot metrics enabled
management.endpoint.metrics.enabled=true

# Spring Boot (Prometheus) endpoint (`/actuator/prometheus`) enabled and exposed
management.metrics.export.prometheus.enabled=true
management.endpoint.prometheus.enabled=true
----

Furthermore, Micrometer offers to option to enable/disable dimensions to your measurements.
This allows you to filter the measurements on, for example, the payload type of messages.
By default, dimensions are enabled.
If you want to adjust this, please check the following examples:

[tabs]
====
Declarative configuration::
+
--
[source,java]
----
import io.micrometer.core.instrument.MeterRegistry;
import org.axonframework.extension.metrics.micrometer.MetricsConfigurationEnhancer;
import org.axonframework.messaging.core.configuration.MessagingConfigurer;

class MetricsConfiguration {

    public void configureDefaultMetrics(MessagingConfigurer configurer,
                                        MeterRegistry meterRegistry) {
        boolean disableDimensions = false;
        configurer.componentRegistry(componentRegistry -> componentRegistry.registerEnhancer(
                new MetricsConfigurationEnhancer(meterRegistry, disableDimensions)
        ));
    }
}
----
--

Automated configuration - Spring Boot::
+
--
[source,properties]
----
# The default value is `true`.
# By enabling this property you will have message (event, command, query)
#   payload type set as a micrometer tag/dimension by default.
# Additionally, the processor name will be a tag/dimension instead of it being part of the metric name.
axon.metrics.micrometer.dimensional=false
----
--
====

Lastly, if you need to specify the `MetricRegistry` used, please check the following examples:

[tabs]
====
Declarative configuration::
+
--
[source,java]
----
import io.micrometer.core.instrument.MeterRegistry;
import org.axonframework.extension.metrics.micrometer.MetricsConfigurationEnhancer;
import org.axonframework.messaging.core.configuration.MessagingConfigurer;

class MetricsConfiguration {

    public void configureDefaultMetrics(MessagingConfigurer configurer,
                                        MeterRegistry meterRegistry) {
        configurer.componentRegistry(componentRegistry -> componentRegistry.registerEnhancer(
                new MetricsConfigurationEnhancer(meterRegistry)
        ));
    }
}
----
--

Automated configuration - Spring Boot::
+
--
[source,java]
----
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
class MetricsConfiguration {

    @Bean
    public MeterRegistry meterRegistry() {
        return new SimpleMeterRegistry();
    }
}
----
--
====

=== Configuring (custom) message monitors

The scenario might occur that more fine-grained control over which `MessageMonitor` instances are defined is necessary.
The `MessagingConfigurer` provides dedicated methods to register monitors per message type:

* `registerMessageMonitor(...)` - Registers a monitor for all message types.
* `registerCommandMonitor(...)` - Registers a monitor specifically for command messages.
* `registerEventMonitor(...)` - Registers a monitor specifically for event messages.
* `registerQueryMonitor(...)` - Registers a monitor specifically for query messages.
* `registerSubscriptionQueryUpdateMonitor(...)` - Registers a monitor for subscription query update messages.

Multiple monitors can be registered for the same message type.
When retrieving a monitor, all registered monitors are combined into a `MultiMessageMonitor`, which delegates message ingestion and callbacks to all of them.

The following snippet shows how to register custom message monitors using the `MessagingConfigurer`:

[source,java]
----
import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.messaging.monitoring.MessageMonitor;

class MetricsConfiguration {

    public void configureCustomMonitors(MessagingConfigurer configurer) {
        // Register a monitor for all message types
        configurer.registerMessageMonitor(config -> new MyCustomMessageMonitor());

        // Register monitors for specific message types
        configurer.registerCommandMonitor(config -> new MyCommandMonitor());
        configurer.registerEventMonitor(config -> new MyEventMonitor());
        configurer.registerQueryMonitor(config -> new MyQueryMonitor());
    }
}
----

If registering `MessageMonitors` per message type is not fine-grained enough, we recommend the registration of a `MessageMonitorFactory`.
A `MessageMonitorFactory` is a functional interface that builds a `MessageMonitor` for a specific component type and component name.
This allows for fine-grained control over which monitors are created based on the component being monitored.
It is this `MessageMonitorFactory` which Axon Framework uses to set the <<monitor-defaults,default monitors>> in the `MetricsConfigurationEnhancer`.

The following example shows how to register a `MessageMonitorFactory` that only creates a monitor for a specific `EventProcessor`:

[source,java]
----
import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.messaging.eventhandling.EventMessage;
import org.axonframework.messaging.eventhandling.processing.EventProcessor;
import org.axonframework.messaging.monitoring.MessageMonitor;

class AxonConfig {

    public void registerEventProcessorMonitorFactory(MessagingConfigurer configurer) {
        configurer.registerEventMonitor((config, componentType, componentName) -> {
            // Only create a monitor for EventProcessors with a specific name
            if (EventProcessor.class.isAssignableFrom(componentType)
                    && "my-processor".equals(componentName)) {
                return new MyCustomEventMonitor();
            }
            // Return null to skip monitoring for other components
            return null;
        });
    }
}
----