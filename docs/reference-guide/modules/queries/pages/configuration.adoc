= Configuration

This page describes the configuration of query handlers and query infrastructure components. Query handlers are objects (typically singletons) containing `@QueryHandler` annotated methods. The query infrastructure includes the `QueryBus`, `QueryGateway`, and related components.

Configuration is done through the `MessagingConfigurer` API, which provides a fluent interface for registering query handling components and configuring query infrastructure. Spring Boot users benefit from auto-configuration that handles most of the setup automatically.

== Registering a query handler

When you register a Query Handler, that means you are registering a class containing annotated query handlers. Upon receiving such a class during configuration, Axon will scan its contents for all `@QueryHandler` annotated methods. In the registration process the following information defines a given query handling function:

. The first parameter of the method is the _query payload_.
. The method's response type is the query's _response type_.
. The value of the `queryName` field in the annotation as the query's _name_ (this is optional and in its absence will default to the query payload).

Note that it is possible to register multiple query handlers for the same query name and response type. When dispatching a query, if multiple handlers are available, the `QueryBus` implementation determines which handler to invoke (typically selecting one in a round-robin or similar fashion).

Query handlers are registered by providing a component that contains `@QueryHandler` annotated methods. Axon scans the component and automatically subscribes all query handler methods to the `QueryBus`.

[tabs]
====
Configuration API::
+
--

Given the existence of the following query handler:

[source,java]
----
public class CardSummaryProjection {

    private final Map<String, CardSummary> cardSummaryStorage = new ConcurrentHashMap<>();

    @QueryHandler
    public CardSummary handle(FetchCardSummaryQuery query) {
        // Retrieve CardSummary instance, for example from a repository
        return cardSummaryStorage.get(query.getCardSummaryId());
    }
}
----

The following shows how to register the `CardSummaryProjection` as a query handler using `MessagingConfigurer`:

[source,java]
----
import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.messaging.queryhandling.configuration.QueryHandlingModule;

MessagingConfigurer configurer = MessagingConfigurer.create()
    .registerQueryHandlingModule(
        QueryHandlingModule.create()
                          .registerQueryHandler(config -> new CardSummaryProjection())
    );

// Build and start the configuration
AxonConfiguration configuration = configurer.build();
configuration.start();
----

Alternatively, you can use the general message handler registration, which works for any type of message handler (command, event, or query):

[source,java]
----
import org.axonframework.messaging.core.configuration.MessagingConfigurer;

MessagingConfigurer configurer = MessagingConfigurer.create()
    .componentRegistry(registry -> registry.registerMessageHandler(
        config -> new CardSummaryProjection()
    ));
----
--

Spring Boot::
+
--
When using Spring Boot, simply declaring the query handler as a Spring bean is sufficient. Axon's auto-configuration will automatically detect and register it:

[source,java]
----
import org.springframework.stereotype.Component;

@Component
public class CardSummaryProjection {

    private final Map<String, CardSummary> cardSummaryStorage = new ConcurrentHashMap<>();

    @QueryHandler
    public CardSummary handle(FetchCardSummaryQuery query) {
        // Retrieve CardSummary instance, for example from a repository
        return cardSummaryStorage.get(query.getCardSummaryId());
    }
}
----

Spring Boot's auto-configuration automatically scans for beans containing `@QueryHandler` methods and registers them with the `QueryBus`.
--
====

[NOTE]
.Identical query handling methods in a single query handler
====
A query handler class can currently contain several identical query handling methods. The outcome of which method will actually be called is however unspecified.

Note that this should be regarded as an extremely uncommon scenario, as typically identical query handling methods would be spread over several query handlers.
====

== Configuring query infrastructure

Beyond registering query handlers, you may need to configure the query infrastructure components such as the `QueryBus`, `QueryGateway`, and interceptors.

=== `QueryBus` configuration

The `QueryBus` is the mechanism that dispatches queries to query handlers. By default, Axon configures an `AxonServerQueryBus` when Axon Server is available, or a `SimpleQueryBus` otherwise.

To customize the `QueryBus`:

[tabs]
====
Configuration API::
+
--
[source,java]
----
import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.messaging.queryhandling.QueryBus;
import org.axonframework.messaging.queryhandling.SimpleQueryBus;

MessagingConfigurer configurer = MessagingConfigurer.create()
    .registerQueryBus(config -> SimpleQueryBus.builder()
                                              .transactionManager(config.transactionManager())
                                              .messageMonitor(config.messageMonitor(QueryBus.class, "queryBus"))
                                              .build());
----
--

Spring Boot::
+
--
[source,java]
----
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.axonframework.messaging.queryhandling.QueryBus;
import org.axonframework.messaging.queryhandling.SimpleQueryBus;

@Configuration
public class AxonConfig {

    @Bean
    public QueryBus queryBus(TransactionManager transactionManager,
                            MessageMonitor<QueryMessage> messageMonitor) {
        return SimpleQueryBus.builder()
                            .transactionManager(transactionManager)
                            .messageMonitor(messageMonitor)
                            .build();
    }
}
----
--
====

=== `QueryGateway` configuration

The `QueryGateway` provides a convenient interface for dispatching queries. It's typically auto-configured, but you can customize it if needed:

[tabs]
====
Configuration API::
+
--
[source,java]
----
import org.axonframework.messaging.queryhandling.gateway.QueryGateway;
import org.axonframework.messaging.queryhandling.gateway.DefaultQueryGateway;

MessagingConfigurer configurer = MessagingConfigurer.create()
    .componentRegistry(registry -> registry.registerComponent(
        QueryGateway.class,
        config -> DefaultQueryGateway.builder()
                                    .queryBus(config.queryBus())
                                    .build()
    ));
----
--

Spring Boot::
+
--
With Spring Boot, the `QueryGateway` is auto-configured. You can inject it directly into your components:

[source,java]
----
@Service
public class OrderService {

    private final QueryGateway queryGateway;

    public OrderService(QueryGateway queryGateway) {
        this.queryGateway = queryGateway;
    }

    public CompletableFuture<OrderDetails> fetchOrderDetails(String orderId) {
        return queryGateway.query(new FetchOrderDetailsQuery(orderId),
                                 OrderDetails.class);
    }
}
----
--
====

=== Interceptor configuration

Interceptors allow you to intercept queries before they are dispatched or handled. There are two types:

* *Dispatch interceptors*: Intercept queries before they are dispatched to the query bus
* *Handler interceptors*: Intercept queries before they are handled by query handlers

[tabs]
====
Configuration API::
+
--
[source,java]
----
import org.axonframework.messaging.core.configuration.MessagingConfigurer;
import org.axonframework.messaging.core.MessageDispatchInterceptor;
import org.axonframework.messaging.core.MessageHandlerInterceptor;

MessagingConfigurer configurer = MessagingConfigurer.create()
    // Register a query dispatch interceptor
    .registerQueryDispatchInterceptor(config ->
        new LoggingQueryDispatchInterceptor()
    )
    // Register a query handler interceptor
    .registerQueryHandlerInterceptor(config ->
        new LoggingQueryHandlerInterceptor()
    );
----
--

Spring Boot::
+
--
With Spring Boot, declare interceptors as beans. They will be automatically registered:

[source,java]
----
import org.springframework.stereotype.Component;
import org.axonframework.messaging.core.MessageDispatchInterceptor;
import org.axonframework.messaging.queryhandling.QueryMessage;

@Component
public class LoggingQueryDispatchInterceptor
        implements MessageDispatchInterceptor<QueryMessage> {

    @Override
    public QueryMessage intercept(QueryMessage message) {
        logger.info("Dispatching query: {}", message.getPayloadType().getSimpleName());
        return message;
    }
}
----
--
====