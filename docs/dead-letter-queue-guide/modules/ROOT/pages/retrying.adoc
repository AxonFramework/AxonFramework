= Retrying Failed Dead Letter Sequences
:navtitle: Retrying failed sequences

The dead letter queue is a stop-gap. It's important to strive to have the queue empty as soon as possible. Ideally by retrying the events, and removing them from the queue.
The `DeadLetteringEventHandlingComponent` implements the `SequencedDeadLetterProcessor` interface, allowing you to process dead letters programmatically.
Additionally, it's also possible to use Axoniq Platform and process a queue manually.

== Processing dead letters

The `SequencedDeadLetterProcessor` provides two operations:

* `processAny(ProcessingContext)` - Process the oldest dead-letter sequence.
* `process(Predicate, ProcessingContext)` - Process the oldest dead-letter sequence matching the predicate.

Both methods return a `CompletableFuture<Boolean>` indicating whether a sequence was successfully processed.

== Scheduled processing example

To schedule processing dead letter sequences you can do something like:

[source,java]
----
import org.axonframework.messaging.deadletter.SequencedDeadLetterProcessor;
import org.axonframework.messaging.eventhandling.EventMessage;
import org.axonframework.messaging.core.unitofwork.ProcessingContext;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

@Component
public class ProcessDeadLetterComponent {

    private final SequencedDeadLetterProcessor<EventMessage> deadLetterProcessor; // <1>
    private final ProcessingContext processingContext; // <2>

    public ProcessDeadLetterComponent(
            SequencedDeadLetterProcessor<EventMessage> deadLetterProcessor,
            ProcessingContext processingContext
    ) {
        this.deadLetterProcessor = deadLetterProcessor;
        this.processingContext = processingContext;
    }

    @Scheduled(fixedDelay = 30_000, initialDelay = 30_000) // <3>
    public void process() {
        deadLetterProcessor.processAny(processingContext) // <4>
                           .whenComplete((success, error) -> {
                               if (error != null) {
                                   // Handle error
                               } else if (success) {
                                   // A sequence was processed successfully
                               }
                           });
    }
}
----

<1> Inject the `SequencedDeadLetterProcessor` for your processor's event handling component.
<2> A `ProcessingContext` is required for processing. You can obtain one from the configuration or create an appropriate implementation.
<3> Spring-specific way to wait 30 seconds, then invoke the method every 30 seconds.
You want a large interval to not stress the system too much.
Especially as you don't know what's going wrong, it might be the application is already having a hard time.
<4> The `processAny()` rotates the sequence to try based on when it was last tried.
Once there are multiple sequences present, it might take some time before they're all processed with this approach.

== Processing with filtering

You can also filter which sequences to process:

[source,java]
----
import org.axonframework.messaging.deadletter.SequencedDeadLetterProcessor;
import org.axonframework.messaging.eventhandling.EventMessage;
import org.axonframework.messaging.core.unitofwork.ProcessingContext;

public class DeadLetterService {

    private final SequencedDeadLetterProcessor<EventMessage> processor;
    private final ProcessingContext processingContext;

    public void retryHighPriorityEvents() {
        // Process only sequences where the first event is a HighPriorityEvent
        processor.process(
                deadLetter -> deadLetter.message().getPayload() instanceof HighPriorityEvent,
                processingContext
        ).join();
    }
}
----

== Processing all sequences

To process all sequences in the queue:

[source,java]
----
import org.axonframework.messaging.deadletter.DeadLetter;
import org.axonframework.messaging.deadletter.SequencedDeadLetterProcessor;
import org.axonframework.messaging.deadletter.SequencedDeadLetterQueue;
import org.axonframework.messaging.eventhandling.EventMessage;
import org.axonframework.messaging.core.unitofwork.ProcessingContext;

import java.util.Iterator;
import java.util.concurrent.CompletableFuture;

public class DeadLetterService {

    private final SequencedDeadLetterProcessor<EventMessage> processor;
    private final SequencedDeadLetterQueue<EventMessage> queue;
    private final ProcessingContext processingContext;

    public CompletableFuture<Void> retryAllSequences() {
        return queue.deadLetters()
                    .thenCompose(deadLetterSequences -> {
                        CompletableFuture<Void> result = CompletableFuture.completedFuture(null);

                        for (Iterable<DeadLetter<? extends EventMessage>> sequence : deadLetterSequences) {
                            Iterator<DeadLetter<? extends EventMessage>> sequenceIterator = sequence.iterator();
                            if (!sequenceIterator.hasNext()) {
                                continue;
                            }

                            String firstLetterId = sequenceIterator.next()
                                                                   .message()
                                                                   .identifier();

                            result = result.thenCompose(v -> processor.process(
                                    deadLetter -> deadLetter.message().identifier().equals(firstLetterId),
                                    processingContext
                            ).thenApply(ignored -> null));
                        }

                        return result;
                    });
    }
}
----

By default, the framework enqueues a letter again, unless a processor can process it successfully.
How to change this, is part of the next section.
