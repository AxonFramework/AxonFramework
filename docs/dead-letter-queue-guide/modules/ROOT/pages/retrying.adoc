= Retrying Failed Dead Letter Sequences
:navtitle: Retrying failed sequences

The dead letter queue is a stop-gap. It's important to strive to have the queue empty as soon as possible. Ideally by retrying the events, and removing them from the queue.
The `DeadLetteringEventHandlingComponent` implements the `SequencedDeadLetterProcessor` interface, allowing you to process dead letters programmatically.
Additionally, it's also possible to use Axoniq Platform and process a queue manually.

== Processing dead letters

The `SequencedDeadLetterProcessor` provides two operations:

* `processAny(ProcessingContext)` - Process the oldest dead-letter sequence.
* `process(Predicate, ProcessingContext)` - Process the oldest dead-letter sequence matching the predicate.

Both methods return a `CompletableFuture<Boolean>` indicating whether a sequence was successfully processed.

== Scheduled processing example

When you enable the dead letter queue, the framework registers `SequencedDeadLetterProcessor` instances as components.
You can retrieve all processors using `getComponents` on the configuration.
Dead letter processing requires a `ProcessingContext`, which you get from `UnitOfWorkFactory`:

[source,java]
----
@Component
public class ScheduledDeadLetterProcessor {

    private final Configuration configuration;
    private final UnitOfWorkFactory unitOfWorkFactory;

    @Scheduled(fixedDelay = 30_000, initialDelay = 30_000) // <1>
    public void processDeadLetters() {
        configuration.getComponents(SequencedDeadLetterProcessor.class) // <2>
                     .values()
                     .forEach(this::processAny);
    }

    @SuppressWarnings("unchecked")
    private void processAny(SequencedDeadLetterProcessor<EventMessage> processor) {
        UnitOfWork unitOfWork = unitOfWorkFactory.create(); // <3>
        unitOfWork.executeWithResult(processingContext ->
                processor.processAny(processingContext) // <4>
        ).join();
    }
}
----

<1> Spring-specific way to invoke the method every 30 seconds. Use a large interval to not stress the system.
<2> Get all `SequencedDeadLetterProcessor` instances from all modules.
<3> Create a `UnitOfWork` to get the `ProcessingContext` with proper transaction management.
<4> The `processAny()` rotates the sequence to try based on when it was last tried.

By default, the framework enqueues a letter again, unless a processor can process it successfully.
How to change this, is part of the next section.
