= Implementing Dead Letter Queues (DLQ)
:navtitle: Implementing dead letter queue

To enable a DLQ you need to configure the `SequencedDeadLetterQueue` component.
Like most components related to event processing, there are implementations available for JPA, JDBC, and Mongo.
To best leverage transactions, it's best to choose the same implementation as the `TokenStore` and likely also for your projection. Please note that for best results, this also means having them located in the same database, or the same collection.

There are two ways of configuring the `SequencedDeadLetterQueue`.

== Configure the dead letter queue for a processor

The recommended approach is to configure the DLQ through the `deadLetterQueue(...)` method on the processor configuration.
The `DeadLetterQueueConfiguration` class provides a fluent API to configure the DLQ behavior:

[source,java]
----
public class EventProcessingDlqConfig {

    public void configureEventProcessing(MessagingConfigurer configurer) {
        configurer.eventProcessing(eventConfigurer -> eventConfigurer.pooledStreaming(
                this::configurePooledStreamingProcessor
        ));
    }

    private PooledStreamingEventProcessorsConfigurer configurePooledStreamingProcessor(
            PooledStreamingEventProcessorsConfigurer pooledStreamingConfigurer
    ) {
        return pooledStreamingConfigurer.processor(
                "my-processor",
                config -> config.eventHandlingComponents(/* event handling components omitted */)
                                .customize((cfg, processorConfig) -> processorConfig
                                        .deadLetterQueue(dlq -> dlq
                                                .enabled()
                                                .clearOnReset(true)
                                                .cacheMaxSize(1024)
                                        )
                                )
        );
    }
}
----

As DLQs add complexity and introduce some overhead, you should only enable them for processors that need this behavior.

== Configure a custom queue implementation

To use a persistent dead-letter queue implementation (for example, JPA or JDBC-backed), configure a factory function that creates the queue for each component:

[source,java]
----
public class EventProcessingDlqConfig {

    public void configureEventProcessing(MessagingConfigurer configurer) {
        configurer.eventProcessing(eventConfigurer -> eventConfigurer.pooledStreaming(
                this::configurePooledStreamingProcessor
        ));
    }

    private PooledStreamingEventProcessorsConfigurer configurePooledStreamingProcessor(
            PooledStreamingEventProcessorsConfigurer pooledStreamingConfigurer
    ) {
        return pooledStreamingConfigurer.processor(
                "my-processor",
                config -> config.eventHandlingComponents(/* event handling components omitted */)
                                .customize((cfg, processorConfig) -> processorConfig
                                        .deadLetterQueue(dlq -> dlq
                                                .enabled()
                                                .factory(componentName -> JpaSequencedDeadLetterQueue.builder()
                                                        .processingGroup(componentName)
                                                        .maxSequences(256)
                                                        .maxSequenceSize(256)
                                                        .entityManagerProvider(entityManagerProvider)
                                                        .transactionManager(transactionManager)
                                                        .serializer(serializer)
                                                        .build()
                                                )
                                        )
                                )
        );
    }
}
----

== Spring Boot configuration

With Spring Boot autoconfiguration, you can enable dead letter event processing for a specific processor using properties:

[source,text]
----
axon.eventhandling.processors.my-processor.dlq.enabled=true
----

When using Spring Boot with JPA, JDBC, or Mongo, a default dead-letter queue factory is configured automatically based on your persistence layer.

You can also configure caching to prevent unnecessary calls to the database, at the cost of keeping some of the sequence identifiers in memory:

[source,text]
----
axon.eventhandling.processors.my-processor.dlq.cache-max-size=2048
----

== Enable for all processors by default

If you want to enable the dead-letter queue for all processors by default, you can use the `defaults(...)` method:

[source,java]
----
public class EventProcessingDlqConfig {

    public void configureEventProcessing(MessagingConfigurer configurer) {
        configurer.eventProcessing(eventConfigurer -> eventConfigurer.pooledStreaming(
                pooledStreamingConfigurer -> pooledStreamingConfigurer
                        // Enable DLQ for all processors by default
                        .defaults((cfg, processorConfig) -> processorConfig
                                .deadLetterQueue(dlq -> dlq.enabled())
                        )
                        // Disable for a specific processor if needed
                        .processor(
                                "no-dlq-processor",
                                config -> config.eventHandlingComponents(/* event handling components omitted */)
                                                .customize((cfg, processorCfg) -> processorCfg
                                                        .deadLetterQueue(dlq -> dlq.disabled())
                                                )
                        )
        ));
    }
}
----

Although enabling a DLQ allows processing to continue in case of errors, it doesn't retry the failed events automatically.
The next section explains some of the options to enable retries.
