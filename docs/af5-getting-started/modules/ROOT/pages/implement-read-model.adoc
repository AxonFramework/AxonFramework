= Feature: Build Course Statistics Read Model (Projection)

In this tutorial, we'll implement a read model (projection) that provides course statistics including enrollment numbers and capacity information.
This enables administrators and instructors to quickly access optimized views of course data for reporting, dashboards, and real-time monitoring without rebuilding the entire state from events for every read.

== What is a Read Model (Projection)?

A read model, also called a projection, is a view of data that's optimized for queries rather than commands.
It's built by processing events from the event store and maintaining a specialized data structure that supports specific read patterns.

Read models are **query-optimized** (structured for performant reads), **eventually consistent** (updated asynchronously), and **purpose-built** (each projection serves specific query needs using dedicated persistence mechanisms like SQL, Graph DB, etc.)
Common use cases include creating search indexes, building dashboards and reporting views, generating real-time analytics, and supporting complex queries across tags in the event store.

== Understanding the Course Statistics Feature

image::FacultyContext_EventModeling.png[]

The Event Modeling diagram shows various green sticky notes representing read models (views). The Course Statistics read model is one such view (*Courses* green sticky note) that provides real-time course enrollment and capacity information.
In Event Modeling terminology, these green sticky notes represent "views" that are continuously updated as events flow through the system.

== Setting Up the Read Model

We'll build a complete read model system with these classes:
â€” Read Model** - The data structure representing course statistics
- **Repository** - Interface for storing and retrieving read models
- **Projection** - Event handlers that build and update the read model
- **Configuration** - Wiring everything together with event processing

=== Step 1: Define the Read Model Data Structure

First, let's create the read model that represents course statistics:

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/read/coursestats/CoursesStatsReadModel.java
----
package io.axoniq.demo.university.faculty.read.coursestats;

import io.axoniq.demo.university.shared.ids.CourseId;

public record CoursesStatsReadModel( // <1>
        CourseId courseId,
        String name,
        int capacity,
        int subscribedStudents
) {

    CoursesStatsReadModel name(String name){ // <2>
        return new CoursesStatsReadModel(courseId, name, capacity, subscribedStudents);
    }

    CoursesStatsReadModel capacity(int capacity){
        return new CoursesStatsReadModel(courseId, name, capacity, subscribedStudents);
    }

    CoursesStatsReadModel subscribedStudents(int subscribedStudents){
        return new CoursesStatsReadModel(courseId, name, capacity, subscribedStudents);
    }

}
----

<.> Immutable record representing course statistics - includes all data needed for course overview queries
<.> Convenience methods for creating updated versions while maintaining immutability

=== Step 2: Create the Repository Interface

Now let's define the repository interface for storing and retrieving course statistics:

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/read/coursestats/CourseStatsRepository.java
----
package io.axoniq.demo.university.faculty.read.coursestats;

import io.axoniq.demo.university.shared.ids.CourseId;

import java.util.Optional;

public interface CourseStatsRepository {
    CoursesStatsReadModel save(CoursesStatsReadModel stats); // <1>

    Optional<CoursesStatsReadModel> findById(CourseId courseId); // <2>

    default CoursesStatsReadModel findByIdOrThrow(CourseId courseId) { // <3>
        return findById(courseId).orElseThrow(() ->
            new RuntimeException("Course with id " + courseId + " does not exist!"));
    }

}
----

<.> Save or update course statistics
<.> Find statistics by course ID, returning Optional for safe handling
<.> Convenience method that throws an exception if the course doesn't exist

=== Step 3: Implement an In-Memory Repository

For this tutorial, we'll use a simple in-memory implementation. In production, you'd typically use a real database:

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/read/coursestats/InMemoryCourseStatsRepository.java
----
package io.axoniq.demo.university.faculty.read.coursestats;

import io.axoniq.demo.university.shared.ids.CourseId;

import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;

class InMemoryCourseStatsRepository implements CourseStatsRepository {

    private final ConcurrentHashMap<CourseId, CoursesStatsReadModel> stats = new ConcurrentHashMap<>(); // <1>

    @Override
    public CoursesStatsReadModel save(CoursesStatsReadModel stats) {
        this.stats.put(stats.courseId(), stats); // <2>
        return stats;
    }

    @Override
    public Optional<CoursesStatsReadModel> findById(CourseId courseId) {
        return Optional.ofNullable(stats.get(courseId)); // <3>
    }

}
----

<.> Thread-safe concurrent map for storing read models in memory
<.> Save by course ID as the key
<.> Safe retrieval that handles missing entries

=== Step 4: Implement the Projection with Event Handlers

Now let's create the projection that builds the read model from events:

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/read/coursestats/CoursesStatsProjection.java
----
package io.axoniq.demo.university.faculty.read.coursestats;

import io.axoniq.demo.university.faculty.events.*;
import org.axonframework.eventhandling.annotation.EventHandler;

class CoursesStatsProjection {

    private final CourseStatsRepository repository;

    public CoursesStatsProjection(CourseStatsRepository repository) { // <1>
        this.repository = repository;
    }

    @EventHandler
    void handle(CourseCreated event) { // <2>
        CoursesStatsReadModel readModel = new CoursesStatsReadModel(
                event.courseId(),
                event.name(),
                event.capacity(),
                0 // Start with zero students
        );
        repository.save(readModel);
    }

    @EventHandler
    void handle(CourseRenamed event) { // <3>
        CoursesStatsReadModel readModel = repository.findByIdOrThrow(event.courseId());
        var updatedReadModel = readModel.name(event.name());
        repository.save(updatedReadModel);
    }

    @EventHandler
    void handle(CourseCapacityChanged event) { // <4>
        CoursesStatsReadModel readModel = repository.findByIdOrThrow(event.courseId());
        var updatedReadModel = readModel.capacity(event.capacity());
        repository.save(updatedReadModel);
    }

    @EventHandler
    void handle(StudentSubscribedToCourse event) { // <5>
        CoursesStatsReadModel readModel = repository.findByIdOrThrow(event.courseId());
        var updatedReadModel = readModel.subscribedStudents(readModel.subscribedStudents() + 1);
        repository.save(updatedReadModel);
    }

    @EventHandler
    void handle(StudentUnsubscribedFromCourse event) { // <6>
        CoursesStatsReadModel readModel = repository.findByIdOrThrow(event.courseId());
        var updatedReadModel = readModel.subscribedStudents(readModel.subscribedStudents() - 1);
        repository.save(updatedReadModel);
    }

}
----

<.> Create an initial read model when a course is created with zero students
<.> Update the course name when renamed
<.> Update capacity when changed
<.> Increment student count when a student subscribes
<.> Decrement student count when a student unsubscribes

=== Step 5: Configure the Read Model Components

Finally, let's wire everything together with a proper Axon Framework 5 configuration:

[source,java]
.src/main/java/io/axoniq/demo/university/faculty/read/coursestats/CourseStatsConfiguration.java
----
package io.axoniq.demo.university.faculty.read.coursestats;

import org.axonframework.eventhandling.GlobalSequenceTrackingToken;
import org.axonframework.eventhandling.configuration.EventProcessorModule;
import org.axonframework.eventhandling.pooled.PooledStreamingEventProcessorModule;
import org.axonframework.eventsourcing.configuration.EventSourcingConfigurer;

import java.util.concurrent.CompletableFuture;

public class CourseStatsConfiguration {

    public static EventSourcingConfigurer configure(EventSourcingConfigurer configurer) {
        PooledStreamingEventProcessorModule projectionProcessor = EventProcessorModule // <1>
                .pooledStreaming("Projection_CourseStats_Processor")
                .eventHandlingComponents(
                        c -> c.annotated(cfg -> new CoursesStatsProjection(cfg.getComponent(CourseStatsRepository.class))) // <2>
                )
                // Due to a minor bug in the InMemoryEventStorageEngine this customization is needed if you want to use the implementation in the tests
                .customized((c, cus) -> cus.initialToken(s -> CompletableFuture.completedFuture(new GlobalSequenceTrackingToken(0))));

        return configurer
                .componentRegistry(cr -> cr.registerComponent(CourseStatsRepository.class, cfg -> new InMemoryCourseStatsRepository())) // <3>
                .modelling(modelling -> modelling.messaging(messaging -> messaging.eventProcessing(eventProcessing ->
                        eventProcessing.pooledStreaming(ps -> ps.processor(projectionProcessor)) // <4>
                )));
    }

    private CourseStatsConfiguration() {
        // Prevent instantiation
    }

}
----

<.> Create a pooled streaming event processor for handling projection events
<.> Register the projection with dependency injection of the repository
<.> Register the repository implementation as a component
<.> Register the event processor with the framework

== Testing the Read Model

Let's create comprehensive tests to verify our read model works correctly:

[source,java]
.src/test/java/io/axoniq/demo/university/faculty/read/coursestats/CourseStatsProjectionTest.java
----
package io.axoniq.demo.university.faculty.read.coursestats;

import io.axoniq.demo.university.UniversityApplicationTest;
import io.axoniq.demo.university.faculty.events.*;
import io.axoniq.demo.university.shared.ids.CourseId;
import io.axoniq.demo.university.shared.ids.StudentId;
import org.awaitility.Awaitility;
import org.axonframework.eventsourcing.configuration.EventSourcingConfigurer;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

public class CourseStatsProjectionTest extends UniversityApplicationTest { // <1>

    @Override
    protected EventSourcingConfigurer overrideConfigurer(EventSourcingConfigurer configurer) { // <2>
        return CourseStatsConfiguration.configure(configurer);
    }

    @Nested
    class CourseCreation { // <3>

        @Test
        void givenNotExistingCourse_WhenGetById_ThenNotFound() {
            // given
            var courseId = CourseId.random();

            // when
            var found = courseStatsRepository().findById(courseId);

            // then
            assertThat(found).isEmpty();
        }

        @Test
        void givenCourseCreated_WhenGetById_ThenFoundCourseWithInitialCapacity() {
            // given
            var courseId = CourseId.random();
            eventOccurred(
                    new CourseCreated(courseId, "Event Sourcing in Practice", 42)
            );

            // when & then
            CoursesStatsReadModel expectedReadModel = new CoursesStatsReadModel(
                    courseId,
                    "Event Sourcing in Practice",
                    42,
                    0 // Initially no students
            );
            assertReadModel(expectedReadModel);
        }
    }

    @Nested
    class CourseUpdates {

        @Test
        void givenCourseCreated_WhenCourseRenamed_ThenReadModelUpdatedWithNewName() {
            // given
            var courseId = CourseId.random();
            var originalName = "Event Sourcing in Practice";
            var newName = "Advanced Event Sourcing";

            eventOccurred(new CourseCreated(courseId, originalName, 42));
            eventOccurred(new CourseRenamed(courseId, newName));

            // when & then
            CoursesStatsReadModel expectedReadModel = new CoursesStatsReadModel(
                    courseId,
                    newName, // Updated name
                    42,
                    0
            );
            assertReadModel(expectedReadModel);
        }

        @Test
        void givenCourseCreated_WhenCourseCapacityChanged_ThenReadModelUpdatedWithNewCapacity() {
            // given
            var courseId = CourseId.random();
            var originalCapacity = 42;
            var newCapacity = 100;

            eventOccurred(new CourseCreated(courseId, "Event Sourcing in Practice", originalCapacity));
            eventOccurred(new CourseCapacityChanged(courseId, newCapacity));

            // when & then
            CoursesStatsReadModel expectedReadModel = new CoursesStatsReadModel(
                    courseId,
                    "Event Sourcing in Practice",
                    newCapacity, // Updated capacity
                    0
            );
            assertReadModel(expectedReadModel);
        }
    }

    @Nested
    class StudentEnrollments {

        @Test
        void givenCourseCreated_WhenStudentSubscribedToCourse_ThenReadModelUpdatedWithIncreasedSubscribedStudents() {
            // given
            var courseId = CourseId.random();
            var studentId = StudentId.random();

            eventOccurred(new CourseCreated(courseId, "Event Sourcing in Practice", 42));
            eventOccurred(new StudentSubscribedToCourse(studentId, courseId));

            // when & then
            CoursesStatsReadModel expectedReadModel = new CoursesStatsReadModel(
                    courseId,
                    "Event Sourcing in Practice",
                    42,
                    1 // One student subscribed
            );
            assertReadModel(expectedReadModel);
        }

        @Test
        void givenCourseCreatedWithStudentSubscribed_WhenStudentUnsubscribedFromCourse_ThenReadModelUpdatedWithDecreasedSubscribedStudents() {
            // given
            var courseId = CourseId.random();
            var studentId = StudentId.random();

            eventOccurred(new CourseCreated(courseId, "Event Sourcing in Practice", 42));
            eventOccurred(new StudentSubscribedToCourse(studentId, courseId));
            eventOccurred(new StudentUnsubscribedFromCourse(studentId, courseId));

            // when & then
            CoursesStatsReadModel expectedReadModel = new CoursesStatsReadModel(
                    courseId,
                    "Event Sourcing in Practice",
                    42,
                    0 // Back to zero students
            );
            assertReadModel(expectedReadModel);
        }
    }

    private void assertReadModel(CoursesStatsReadModel expectedReadModel) { // <4>
        Awaitility.await().untilAsserted(() -> {
            var found = courseStatsRepository().findById(expectedReadModel.courseId());
            assertThat(found).isNotEmpty();
            assertThat(found).hasValue(expectedReadModel);
        });
    }

    private CourseStatsRepository courseStatsRepository() { // <5>
        return sut.getComponent(CourseStatsRepository.class);
    }

}
----

<.> Extend the test infrastructure base class
<.> Configure our read model components for testing
<.> Group tests logically using nested test classes
<.> Async assertion using Awaitility, because the projection is eventually consistent, we need to wait for it to be updated
<.> Helper to access the repository from the test configuration

== Key Read Model Concepts

=== Write Model Vs Query Model

|===
|Aspect |Write Model |Query Model

|**Purpose** |Command processing, business logic |Query processing, optimized views
|**Consistency** |Strong consistency |Eventually consistent
|**Performance** |Optimized for writes |Optimized for reads
|**Complexity** |Business logic complexity |Simple data transformation
|===

== Integration with the Main Application

To use this read model in your main application, register the configuration:

[source,java]
.src/main/java/io/axoniq/demo/university/UniversityAxonApplication.java
----
public class UniversityAxonApplication {

    public static ApplicationConfigurer configurer() {
        return configurer(c -> {
            // Other configurations...
            CourseStatsConfiguration.configure(c); // <1>
        });
    }

    // rest omitted for brevity
}
----

<1> Register the read model configuration to enable course statistics tracking

== Summary

In this tutorial, you have learned how to implement read models (projections) with Axon Framework 5. Key takeaways:

- **Read models** provide query-optimized views of your data built from events
- **Event handlers** in projections update read models as events are processed
- **Repository pattern** abstracts read model storage and retrieval
- **Testing** uses async assertions to handle eventually consistent updates

Read models enable powerful query capabilities, real-time dashboards, and optimized APIs while maintaining the benefits of Event Sourcing and CQRS architecture.
They form the foundation for building responsive user interfaces and analytical systems in event-driven applications.